---
layout: post
title: "[Unreal Engine] Section 1 - Warehouse Wreckage"
excerpt: "Playing with Physics, Spawning projectiles, Aiming the projectile, BXP Level Build, Asset, Game mechanism, Reloading Levels"

tags:
  - [언리얼 엔진, Unreal, CPP]

toc: true

date: 2024-07-10
last_modified_at: 2024-07-10
---
## 프로젝트 설정
### 1. 컨텐츠 드로어
- 컨텐츠 드로어 : 좌측 하단에 위치. 폴더와 파일들을 열 수 있는 창을 띄운다.  

  - `Content` -> `StarterContent` -> `Maps` : 맵이란, 이 게임에 존재하는 **레벨**이다.  
  해당 폴더 내 노란색 표시된 파일들을 클릭하여 레벨을 로드할 수 있다.

<br>

### 2. 블루프린트 에디터
- 좌측 상단의 액터 생성 버튼 바로 오른쪽 아이콘을 클릭하면, 블루프린트 관련 메뉴들이 있다.  

  - 여기서 `레벨 블루프린트 열기` 를 클릭하여 블루프린트 에디터를 열 수 있다.

- 블루프린트 에디터의 정중앙에 있는 것은 `Event Graph` 라고 하며,  
여기에서 블루프린트 작성을 할 수 있다.  

  - 이벤트 그래프를 우클릭해보면, 어마어마하게 많은 기능들이 있음을 알 수 있다.  

<br>

## 블루프린트 에디터
### 1. 문자열 출력
- 블루프린트 에디터에서 우클릭을 하면 기능 리스트가 나열되었다.  

  - 이 중 어느 하나를 클릭해보자. 클릭하여 생성되는 오브젝트를 `Node(노드)` 라고 한다.  

- `Print String` 노드와 `Event BeginPlay` 노드를 Output Pin - Input Pin 끼리 연결해보자.  
이제 게임을 시작할 때(`Event BeginPlay`) 지정한 문자열이 출력(`Print String`)되는 기능을 추가한 것이다.

- 추가적으로 하나의 `Print String`을 더 만들어보고, 첫 번째 출력 노드와 연결해보자.  

  - 참고로 Output Pin에서 Connection을 끌어다가 빈 공간에 위치시키면, 해당 Connection을 Input으로 받을 새로운 노드 생성 창을 자동으로 띄운다.  

- 이렇게 두 번째 출력 노드를 생성하고 시작해보면, 아주 빠르게 두 이벤트가 연달아 발생한 것을 볼 수 있다.  
추가적으로 먼저 생성한 출력 노드 이벤트가 아래로 간 것도 확인할 수 있다.


<br>

## Playing with Physics
- 기본적으로 모든 물체는 물리 법칙의 영향을 받지 않는다.  
예를들어 물체를 공중에 띄운 후 시작을 하여도 물체는 떨어지지 않고 공중에 매달려있게 된다.  

  - 이는 CPU가 물리법칙을 적용하는데 부담을 가지기 때문에,  
  기본적으로는 씬 안의 오브젝트에 물리법칙을 Default로 적용하지는 않는 것이다.  

### 1. Applying Physics to Object
- 물체에 물리 법칙을 적용해보자.  

- 어떠한 물체를 선택하면, 오른쪽 탭에는 해당 물체에 대한 다양한 정보들이 표시된다.   

  - 이 중에서 위쪽은 아이템 리스트들이 표시되며, 아래쪽의 디테일 탭이 해당 물체에 대한 Property이다.  

  - 아래쪽에 `일반`, `액터`, `LOD`, ... 등의 필터들이 있는데, 우린 이 중에서 `피직스` 탭에 주목할 것이다.  

- `피직스` 탭에서, `피직스 시뮬레이트` 체크박스에 체크를 하게되면, 해당 물체에 물리 법칙이 적용된다.  

  - 이는 사용자가 직접 새로 추가한 오브젝트에도 적용된다.  

<br>

### 2. Antigravity
- 동일하게 물체의 `피직스` 탭에서, `중력 활성화` 체크박스에 체크를 해제 하게되면,  
해당 물체는 중력의 영향을 전혀 받지 않는 것 처럼 속성이 바뀐다.  

<br>

### 3. Mass
- 기본적으로는 `질량` 속성에 체크박스가 비활성화되어 해당 물체에 Default 질량 값이 적용되어 있지만,  
해당 체크박스를 활성화 하게되면 직접 질량값을 지정해 줄 수 있다.  

  - 이를 이용하여 물리 법칙에 영향이 가도록 변경할 수 있다.  

<br>

## Object and Reference
### 1. Object
- 객체지향 프로그래밍에서 주로 다루는 객체, Object 개념 맞다.  

  - Data : 객체가 가지는 속성
  - Functionality : 객체가 할 수 있는 행동

- 액터도 오브젝트다.

  - Component : 액터에 들어가는 또 다른 오브젝트다.  

  <br>

### 2. Reference
- 메모리에서 해당 오브젝트가 위한 주소(Address)를 가리키는 참조(Reference).

- 레벨에서 어떠한 액터 오브젝트를 선택하고,  
블루프린트 에디터에서 우클릭을 하게되면 가장 최상단에 해당 액터에 대한 레퍼런스 생성이 뜬다.  
클릭하여 해당 액터 오브젝트에 대한 레퍼런스를 생성할 수 있다.  

  - 해당 레퍼런스를 이용하여 액터와 컴포넌트에 접근할 수 있다.

  - 레퍼런스 노드의 오른쪽에 있는 파란색 원을, `Data Pin` 이라고 한다.  
  `Data Pin`은, 노드에 대한 input 또는 output 데이터이다.  
  **노드로 무엇을 실행할 지**를 결정한다.

  - 데이터 핀과 구분되는 일반적인 흰색 핀들을, `Execution Pin` 이라고 부른다.  
  **노드를 언제 실행할 지**를 결정한다.  

  <br>

- 큐브 레퍼런스 노드를 만들어 데이터 핀을 끌어다가 빈 곳에 놓아보자.

  - 큐브에 있는 모든 기능이 나열될 것이다.  
  큐브에는 `StaticMeshComponent` 라는 이름의 컴포넌트가 존재하며, 이 오브젝트에 대한 레퍼런스를 가져오고싶다.  

  - `get static mesh component` 라는 이름의 노드를 찾을 수 있을 것이다.  
  선택하면 입력이 큐브 레퍼런스이며, 출력은 스태틱 메시 컴포넌트 레퍼런스인 새로운 노드가 생긴다.

  - 또다시 컴포넌트의 데이터 핀을 끌어다가, 스태틱 메시 컴포넌트의 기능을 요청할 수 있다.  
  예를들어 `get display name` 메소드를 사용할 수 있다.  

    - 해당 메소드의 리턴값은 스트링이므로, 이전에 사용해보았던 `Print String` 함수의 데이터로 줄 수도 있겠다.  
    (만약 이 과정에서 데이터의 타입이 맞지 않는다면, 자동으로 변환 노드를 거치도록 변환 노드가 생성된다.)

<br>

## Add Impulse
### 1. Keyboard Event
- 이번엔 스페이스바와 같은 어떠한 키보드 입력이 있었을 때, 무언가 이벤트가 발생하도록 하고싶다.  

  - 블루프린트 에디터에서 우클릭 후 `space bar`와 같이 검색하여 키보드 이벤트 노드를 생성할 수 있다.  

  - 이러한 이벤트 노드는, 특이하게도 Output Pin이 두 개나 존재한다.  
  예를들어 하나는 `Pressed`, 하나는 `Released` 와 같이 말이다. 이들은 이름 그대로이다.  

<br>

### 2. Applying Impulse
- 우리는 스페이스 바를 눌렀을 때 점프를 기대한다.  
이를 위하여 오브젝트에 위로 향하는 포스를 적용하고 싶다.  
정확히는 `임펄스`를 적용한다고 하는데, 이는 피직스 용어에서 다루는 뜻에 약간의 차이가 존재한다.  
  
  - 포스(Force) : 정해진 시간에 걸쳐 적용되는 힘

  - 임펄스(Impulse) : 즉각적으로 적용되는 힘

- 오브젝트에 임펄스를 가하기 위하여, 해당 오브젝트 컴포넌트의 레퍼런스 노드에서 `Add Impuse` 기능을 찾아 노드로 추가한다.  

  - 이 노드의 Input Pin에 스페이스 바 이벤트 노드를 연결하면,  
  스페이스바가 눌렸을 때 임펄스가 가해짐을 나타낸다.  

  - 이 노드는 Input 데이터 핀들이 여러 개가 존재함을 볼 수 있다.

    - 이 중에서 단연 눈에 보이는 것은 `Impulse` 데이터일 텐데, 이는 가해지는 임펄스의 방향과 가해질 힘의 값을 나타낼 것이다.  
    이 데이터를 수정하여 임펄스를 가해보자.  

    - 그런데 임펄스 값은 얼마가 적절할까? 힘과 질량은 밀접한 관계가 있다.  
    `F = ma` -> `힘 = 질량 * 가속도` 이다. 비슷하게,  
    `Impulse = Mass * Velocity Change`, 즉 질량과 속도 변화율의 차이이다.  
    따라서 특정한 양의 속도변화, 즉 움직임을 원한다면  
    질량이 늘어날 수록 더 큰 값을 할당해 주어야 할 것이다.  

    - 하지만 이러한 계산 없이도 항상 일정하게 임펄스를 줄 수 있다.  
    데이터 핀들 중에서 `Val Change` 라는 이름의 데이터에 체크하게되면,  
    질량을 무시하고 원하는 속력을 바로 제공할 수 있다.  
    따라서 `Impulse` 데이터에 입력한 값 만큼의 속력을 바로 제공할 수 있게된다.  

<br>

## Classes and Instances
- 객체지향 프로그래밍에서 다루는 클래스의 개념이다.  
객체를 생성하는 틀. Frame.

### 1. Blueprint Class
- 예를들어 우리가 이번 섹션에서 만들 게임의 경우, 발사체 오브젝트들이 무수히 많이 생성될 텐데,  
이 오브젝트들은 모두 비슷한 속성을 띄며 하나의 틀(클래스)을 잘 만들어 둔다면 쉽게 대량으로 찍어낼 수 있을 것이다.  

- 클래스를 생성하고자 하는 오브젝트를 클릭하고,  
`디테일` 탭의 `추가` 버튼 우측에 존재하는 `블루프린트 편집` 을 클릭하면 새로운 블루프린트 클래스를 생성할 수 있으며,  
블루프린트 클래스 에디터가 열린다.  

  - 관습적으로 이름은 `BP_` 로 시작하도록 짓는다.  

- 블루프린트 클래스 에디터에서는 해당 오브젝트의 속성들을 변경해 줄 수 있다.  

  - 이전애 학습해두었던 `피직스`나, `Material`과 같은 속성들을 변경하여 새로운 인스턴스 툴을 만들어보자.  

<br>

### 2. Instances
- 이렇게 만든 클래스를 드래그하여 레벨에 가져다 놓는다면, 똑같이 생긴 사본(Instance)을 얻을 수 있게 될 것이다.  

- 이렇게 만들어진 인스턴스들은, 모두 하나의 클래스에서 만들어져 나온 사본들이기 때문에,  
클래스에서 해당 오브젝트의 속성을 변경하게 되면 몇 개의 인스턴스들이건 모두 함께 영향을 받을 것이다.  

## Projectile
### 1. Spawning Projectiles

### 2. Aiming the Projectile

## BXP Level Build

## Asset

## Game mechanism

## Reloading Levels