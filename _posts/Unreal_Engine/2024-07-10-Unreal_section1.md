---
layout: post
title: "[Unreal Engine] Section 1 - Warehouse Wreckage"
excerpt: "Playing with Physics, Spawning projectiles, Aiming the projectile, BXP Level Build, Asset, Game mechanism, Reloading Levels"

tags:
  - [언리얼 엔진, Unreal, CPP]

toc: true

date: 2024-07-10
last_modified_at: 2024-07-10
---
## 프로젝트 설정
### 1. 컨텐츠 드로어
- 컨텐츠 드로어 : 좌측 하단에 위치. 폴더와 파일들을 열 수 있는 창을 띄운다.  

  - `Content` -> `StarterContent` -> `Maps` : 맵이란, 이 게임에 존재하는 **레벨**이다.  
  해당 폴더 내 노란색 표시된 파일들을 클릭하여 레벨을 로드할 수 있다.

<br>

### 2. 블루프린트 에디터
- 좌측 상단의 액터 생성 버튼 바로 오른쪽 아이콘을 클릭하면, 블루프린트 관련 메뉴들이 있다.  

  - 여기서 `레벨 블루프린트 열기` 를 클릭하여 블루프린트 에디터를 열 수 있다.

- 블루프린트 에디터의 정중앙에 있는 것은 `Event Graph` 라고 하며,  
여기에서 블루프린트 작성을 할 수 있다.  

  - 이벤트 그래프를 우클릭해보면, 어마어마하게 많은 기능들이 있음을 알 수 있다.  

<br>

## 블루프린트 에디터
### 1. 문자열 출력
- 블루프린트 에디터에서 우클릭을 하면 기능 리스트가 나열되었다.  

  - 이 중 어느 하나를 클릭해보자. 클릭하여 생성되는 오브젝트를 `Node(노드)` 라고 한다.  

- `Print String` 노드와 `Event BeginPlay` 노드를 Output Pin - Input Pin 끼리 연결해보자.  
이제 게임을 시작할 때(`Event BeginPlay`) 지정한 문자열이 출력(`Print String`)되는 기능을 추가한 것이다.

- 추가적으로 하나의 `Print String`을 더 만들어보고, 첫 번째 출력 노드와 연결해보자.  

  - 참고로 Output Pin에서 Connection을 끌어다가 빈 공간에 위치시키면, 해당 Connection을 Input으로 받을 새로운 노드 생성 창을 자동으로 띄운다.  

- 이렇게 두 번째 출력 노드를 생성하고 시작해보면, 아주 빠르게 두 이벤트가 연달아 발생한 것을 볼 수 있다.  
추가적으로 먼저 생성한 출력 노드 이벤트가 아래로 간 것도 확인할 수 있다.


<br>

## Playing with Physics
- 기본적으로 모든 물체는 물리 법칙의 영향을 받지 않는다.  
예를들어 물체를 공중에 띄운 후 시작을 하여도 물체는 떨어지지 않고 공중에 매달려있게 된다.  

  - 이는 CPU가 물리법칙을 적용하는데 부담을 가지기 때문에,  
  기본적으로는 씬 안의 오브젝트에 물리법칙을 Default로 적용하지는 않는 것이다.  

### 1. Applying Physics to Object
- 물체에 물리 법칙을 적용해보자.  

- 어떠한 물체를 선택하면, 오른쪽 탭에는 해당 물체에 대한 다양한 정보들이 표시된다.   

  - 이 중에서 위쪽은 아이템 리스트들이 표시되며, 아래쪽의 디테일 탭이 해당 물체에 대한 Property이다.  

  - 아래쪽에 `일반`, `액터`, `LOD`, ... 등의 필터들이 있는데, 우린 이 중에서 `피직스` 탭에 주목할 것이다.  

- `피직스` 탭에서, `피직스 시뮬레이트` 체크박스에 체크를 하게되면, 해당 물체에 물리 법칙이 적용된다.  

  - 이는 사용자가 직접 새로 추가한 오브젝트에도 적용된다.  

<br>

### 2. Antigravity
- 동일하게 물체의 `피직스` 탭에서, `중력 활성화` 체크박스에 체크를 해제 하게되면,  
해당 물체는 중력의 영향을 전혀 받지 않는 것 처럼 속성이 바뀐다.  

<br>

### 3. Mass
- 기본적으로는 `질량` 속성에 체크박스가 비활성화되어 해당 물체에 Default 질량 값이 적용되어 있지만,  
해당 체크박스를 활성화 하게되면 직접 질량값을 지정해 줄 수 있다.  

  - 이를 이용하여 물리 법칙에 영향이 가도록 변경할 수 있다.  

<br>

## Object and Reference
### 1. Object
- 객체지향 프로그래밍에서 주로 다루는 객체, Object 개념 맞다.  

  - Data : 객체가 가지는 속성
  - Functionality : 객체가 할 수 있는 행동

- 액터도 오브젝트다.

  - Component : 액터에 들어가는 또 다른 오브젝트다.  

  <br>

### 2. Reference
- 메모리에서 해당 오브젝트가 위한 주소(Address)를 가리키는 참조(Reference).

- 레벨에서 어떠한 액터 오브젝트를 선택하고,  
블루프린트 에디터에서 우클릭을 하게되면 가장 최상단에 해당 액터에 대한 레퍼런스 생성이 뜬다.  
클릭하여 해당 액터 오브젝트에 대한 레퍼런스를 생성할 수 있다.  

  - 해당 레퍼런스를 이용하여 액터와 컴포넌트에 접근할 수 있다.

  - 레퍼런스 노드의 오른쪽에 있는 파란색 원을, `Data Pin` 이라고 한다.  
  `Data Pin`은, 노드에 대한 input 또는 output 데이터이다.  
  **노드로 무엇을 실행할 지**를 결정한다.

  - 데이터 핀과 구분되는 일반적인 흰색 핀들을, `Execution Pin` 이라고 부른다.  
  **노드를 언제 실행할 지**를 결정한다.  

  <br>

- 큐브 레퍼런스 노드를 만들어 데이터 핀을 끌어다가 빈 곳에 놓아보자.

  - 큐브에 있는 모든 기능이 나열될 것이다.  
  큐브에는 `StaticMeshComponent` 라는 이름의 컴포넌트가 존재하며, 이 오브젝트에 대한 레퍼런스를 가져오고싶다.  

  - `get static mesh component` 라는 이름의 노드를 찾을 수 있을 것이다.  
  선택하면 입력이 큐브 레퍼런스이며, 출력은 스태틱 메시 컴포넌트 레퍼런스인 새로운 노드가 생긴다.

  - 또다시 컴포넌트의 데이터 핀을 끌어다가, 스태틱 메시 컴포넌트의 기능을 요청할 수 있다.  
  예를들어 `get display name` 메소드를 사용할 수 있다.  

    - 해당 메소드의 리턴값은 스트링이므로, 이전에 사용해보았던 `Print String` 함수의 데이터로 줄 수도 있겠다.  
    (만약 이 과정에서 데이터의 타입이 맞지 않는다면, 자동으로 변환 노드를 거치도록 변환 노드가 생성된다.)

<br>

## Add Impulse
### 1. Keyboard Event
- 이번엔 스페이스바와 같은 어떠한 키보드 입력이 있었을 때, 무언가 이벤트가 발생하도록 하고싶다.  

  - 블루프린트 에디터에서 우클릭 후 `space bar`와 같이 검색하여 키보드 이벤트 노드를 생성할 수 있다.  

  - 이러한 이벤트 노드는, 특이하게도 Output Pin이 두 개나 존재한다.  
  예를들어 하나는 `Pressed`, 하나는 `Released` 와 같이 말이다. 이들은 이름 그대로이다.  

<br>

### 2. Applying Impulse
- 우리는 스페이스 바를 눌렀을 때 점프를 기대한다.  
이를 위하여 오브젝트에 위로 향하는 포스를 적용하고 싶다.  
정확히는 `임펄스`를 적용한다고 하는데, 이는 피직스 용어에서 다루는 뜻에 약간의 차이가 존재한다.  
  
  - 포스(Force) : 정해진 시간에 걸쳐 적용되는 힘

  - 임펄스(Impulse) : 즉각적으로 적용되는 힘

- 오브젝트에 임펄스를 가하기 위하여, 해당 오브젝트 컴포넌트의 레퍼런스 노드에서 `Add Impuse` 기능을 찾아 노드로 추가한다.  

  - 이 노드의 Input Pin에 스페이스 바 이벤트 노드를 연결하면,  
  스페이스바가 눌렸을 때 임펄스가 가해짐을 나타낸다.  

  - 이 노드는 Input 데이터 핀들이 여러 개가 존재함을 볼 수 있다.

    - 이 중에서 단연 눈에 보이는 것은 `Impulse` 데이터일 텐데, 이는 가해지는 임펄스의 방향과 가해질 힘의 값을 나타낼 것이다.  
    이 데이터를 수정하여 임펄스를 가해보자.  

    - 그런데 임펄스 값은 얼마가 적절할까? 힘과 질량은 밀접한 관계가 있다.  
    `F = ma` -> `힘 = 질량 * 가속도` 이다. 비슷하게,  
    `Impulse = Mass * Velocity Change`, 즉 질량과 속도 변화율의 차이이다.  
    따라서 특정한 양의 속도변화, 즉 움직임을 원한다면  
    질량이 늘어날 수록 더 큰 값을 할당해 주어야 할 것이다.  

    - 하지만 이러한 계산 없이도 항상 일정하게 임펄스를 줄 수 있다.  
    데이터 핀들 중에서 `Val Change` 라는 이름의 데이터에 체크하게되면,  
    질량을 무시하고 원하는 속력을 바로 제공할 수 있다.  
    따라서 `Impulse` 데이터에 입력한 값 만큼의 속력을 바로 제공할 수 있게된다.  

<br>

## Classes and Instances
- 객체지향 프로그래밍에서 다루는 클래스의 개념이다.  
객체를 생성하는 틀. Frame.

### 1. Blueprint Class
- 예를들어 우리가 이번 섹션에서 만들 게임의 경우, 발사체 오브젝트들이 무수히 많이 생성될 텐데,  
이 오브젝트들은 모두 비슷한 속성을 띄며 하나의 틀(클래스)을 잘 만들어 둔다면 쉽게 대량으로 찍어낼 수 있을 것이다.  

- 클래스를 생성하고자 하는 오브젝트를 클릭하고,  
`디테일` 탭의 `추가` 버튼 우측에 존재하는 `블루프린트 편집` 을 클릭하면 새로운 블루프린트 클래스를 생성할 수 있으며,  
블루프린트 클래스 에디터가 열린다.  

  - 관습적으로 이름은 `BP_` 로 시작하도록 짓는다.  

- 블루프린트 클래스 에디터에서는 해당 오브젝트의 속성들을 변경해 줄 수 있다.  

  - 이전애 학습해두었던 `피직스`나, `Material`과 같은 속성들을 변경하여 새로운 인스턴스 툴을 만들어보자.  

<br>

### 2. Instances
- 이렇게 만든 클래스를 드래그하여 레벨에 가져다 놓는다면, 똑같이 생긴 사본(Instance)을 얻을 수 있게 될 것이다.  

- 이렇게 만들어진 인스턴스들은, 모두 하나의 클래스에서 만들어져 나온 사본들이기 때문에,  
클래스에서 해당 오브젝트의 속성을 변경하게 되면 몇 개의 인스턴스들이건 모두 함께 영향을 받을 것이다.   

## Projectile
### 1. Spawning Projectiles
- 발사체같은 액터를 스폰해보자. 이런 액터들은 레벨에 기존에 존재하는 것이 아닌,  
존재하지 않고 있다가 어떠한 이벤트가 발생하였을 때마다 새로 생성되는 편이 자연스럽다.  

- 예를들어 스페이스바 이벤트 노드의 Output Pin으로부터 드래그하여, `Spawn Actor` 노드를 생성하고 연결하자.  

  - 스폰 액터 노드 역시 여러개의 데이터핀을 가지고 있고, 데이터들을 선택할 수 있도록 주어져있다.  

  - `Class` 데이터에 스폰할 인스턴스에 해당하는 클래스를 지정해주자.  

  - `Transform` 데이터는 무엇일까?  
  트랜스폼이란, 오브젝트의 위치, 회전, 스케일 조합이다.  
  오브젝트들이 기본적으로 가지고있는 `Transform` 프로퍼티를 의미한다.  

    - `Transform` 데이터는 우클릭하여 `구조체 핀 분할` 하게 되면 상세 데이터를 입력할 수 있다.  

  - 신기하게도 스폰 액터 노드에 파란색 `Return Pin`이 존재하는데,  
  리턴 값은 바로 스폰한 해당 오브젝트 인스턴스에 대한 레퍼런스를 의미한다.  

    - 이 리턴 값을 통하여 스태틱 메시 컴포넌트 등의 속성을 가져와,  
    임펄스를 추가하는 등의 추가적인 작업이 가능하겠다.  

    <br>

### 2. Data Types
- 다음으로 넘어가기 전에, 여러가지 데이터 타입들에 대하여 짚고 넘어가자.  
지금까지도 블루프린트 노드들을 다루면서 여러가지 데이터 타입들을 마주했지만,  
앞으로도 계속 마주치게 될 것이기 때문에 가볍게 정리하고 넘어가야 한다.  

- 데이터 타입을 나눔으로써, 이 데이터로 무엇을 할 수 있는지 제한할 수 있는 방법이 된다.  
데이터의 Shape 이라고 보면 된다.  
Shape이 맞지 않은 잘못된 유형의 데이터는 Wrong type 핀에 연결할 수 없다.  

- Data Types
  - 기본 타입
    - `Integer` : 정수형
    - `Float` : 부동소수점형
    - `String` : 문자열형
    - `Bool `: Boolean형
  - 객체
    - `Struct` : 구조체
      - 구조체는 레퍼런스를 사용하짐 않고 복사한다.
      - 앞에서 보았던 `Vectors`, `Rotator` 들 또한 `x`, `y`, `z` 필드를 가지는 구조체이다.  
      - `Transforms`는 위치, 회전, 스케일의 세 개의 구조체를 합친 더 큰 복합 구조체이다.  
    - `Objects` 
      - Actors (Cube, Projectile, ...)
      - Components (StaticMeshComponent, ...)

### 3. Aiming the Projectile
- 발사체 같은 인스턴스들을 스폰하는 방법은 이제 알았다.  
우리는 1인칭 슈팅게임을 만들고자 하므로, 발사체를 바라보는 방향으로, 그리고 내 위치에서 스폰되도록 하여야한다.  

- 게임을 플레이 중인 상태에서 `F8`을 누르면, 게임을 플레이 중임에도 불구하고 오브젝트를 선택할 수 있는 상태가 되며,  
`Pawn` 이라는 검은색 구체가 나타나는데, 이는 현재 우리가 플레이하던 말(체스의 pawn)을 의미한다.  
폰은 게임에서 플레이어를 물리적으로 묘사한 것이다.  

- 폰은 게임을 실행하지 않은 상태에서는 존재하지 않고,  
대신에 씬에서 `Player Start` 오브젝트로 폰의 시작 위치를 정해줄 수 있다.  

- 그렇다면 게임을 시작해야만 생성되는 Pawn 오브젝트에 대한 레퍼런스를 어떻게 가져올 수 있을까?

  - 레벨 블루프린트에서 `Get Player Pawn`노드를 생성하자.  
  이 노드는 실행 핀이 존재하지 않지만,  
  하나의 데이터 핀과 리턴 핀이 존재한다.  

    - 데이터 핀 : `Player Index` - 멀티 플레이어에서 플레이어를 선택하는데 이용되며, 싱글 플레이에서는 `0`이 자신을 의미한다.  

    - 리턴 핀 : `Pawn Object Reference`

- `Get Player Pawn` 노드의 리턴 값으로서, 폰의 레퍼런스를 얻었다.  
발사체가 자신으로부터 스폰되게 하기 위하여, 폰의 위치가 필요하다.  
`Get Actor Location` 노드를 생성한다.  

  - `Get Actor Location` 노드는 리턴 핀이 노란색이다.  
  바로 데이터 타입이 `Vector`인 것이다.  
  이 리턴 값을 발사체 스폰 위치 데이터에 연결하면 정확히 우리가 원하는 행동을 얻을 수 있을 것이다.  

  - 그리고 임펄스 값을 `Z`축이 아닌 `X`축으로 주게 된다면, 우리가 원하는 발사체 발사를 구현할 수 있을 것이다.  

- 하지만 문제가 하나 있다. 슈팅게임이므로, 내가 바라보는 방향으로 발사체를 발사해야 하지만  
현재는 카메라를 아무리 돌려도 방향이 정해져있다.  

  - 이는 실제로 게임 내에서 폰의 `Rotation` 속성을 확인해보면 알 수 있는데,  
  아무리 카메라를 돌리고 속성을 다시 확인해 보아도 그대로인 것을 알 수 있다.  
  이는 언리얼의 폰 회전과 카메라 회전은 별개로 설정되었기 때문이다.  

  - 따라서 `Get Actor Rotation` 노드를 연결하여 보아도, 발사체는 바라보는 방향으로 날아가지 않을 것이다.  
  이는 당연하게도 폰의 `Rotation`은 그대로이기 때문이다.  

  - 대신, `Get Control Rotation` 노드를 이용해보자.  

    - 다만, 이 노드의 리턴 값을 발사체의 `Spawn Transform Rotation` 데이터에 연결한다고 하여도,  
    발사체가 회전될 뿐, 발사되는 방향이 바뀌지는 않는다.  

    - 아마도, 임펄스의 방향이 `Control Rotation`에 따라 달라지도록 해야할 것이다.  

  - 바라보는 방향에 대한 `Vector` 값을 얻기 위하여,  
  발사체 노드의 레퍼런스로부터 `Get Forward Vector` 노드를 생성하고, 전방 벡터 값을 얻어낸다.  

    - `Control Rotation` 노드로부터 전방 벡터 값을 얻어낼 수도 있지만,  
    이는 구체의 회전이 항상 똑같아지는 사소한 문제가 있다.  

    - 한 가지 문제는, 이러한 방향 벡터들의 기본 값은 항상 `1`(Ones Vector)이다.  
    따라서, 이를 임펄스 방향에 직접 연결하면 매우 약할 것이다.  

    - 그렇기에 `Multiply` 노드를 어댑터로 연결하여 접속시키면 드디어 발사체를 제대로 발사할 수 있게 되었다 !  

      - 추가적으로 `Multiply` 노드의 두 번째 데이터인 배수 벡터는,  
      우클릭하여 하나의 통합된 `Interger` 또는 `Float` 값 등으로 통합시킬 수 있다.  

<br>

## Asset
- 언리얼에서 기본으로 주어지는 맵이나 오브젝트들은 아주 Awesome 하지만,  
그래도 밋밋하다.  
외부 에셋을 가져와서 씬에 추가해준다면, 훨씬 더 다채로운 게임이 될 것이다.  

### 1. Bring Outer Assets
- 에픽 게임즈 런처의 `MarketPlace` 탭에 가면, 공개된 수많은 외부 에셋들을 골라 사용할 수 있다.  
일부는 유료상품이며, 일부는 무료로 공개되어있다.  

- 원하는 에셋을 구매하여, 프로젝트에 추가하면 다운로드가 완료된다.  

- 다운로드 받은 에셋은 동일하게 콘텐츠 드로어에서 확인해볼 수 있으며,  
콘텐츠 폴더에 하나의 폴더 형태로 들어있을 것이다.  

  - 참고로, 컨텐츠 드로어를 여는 단축키는 `Ctrl` + `Space` 이다.  

<br>

### 2. Use Asset Materials
- 가지고있는 에셋에서 사용하고 싶은 오브젝트를 내 워크스페이스에 추가하려면 어떻게 할까?

- 방법은 아주 간단하다. 컨텐츠 드로어에서 해당 오브젝트를 폴더에서 찾아서,  
단순히 드래그 & 드롭 해주면 간편하게 오브젝트를 내 씬 안에 들여놓을 수 있다.  
이 오브젝트에 어떠한 행동이든 속성이든 추가 및 변경 가능하다.  

<br>

## BSP Level Build
- 이제 외부 에셋을 가져와 다채롭게 꾸미는 작업도 가능해졌으므로, 아무래도 이제 맵 부터 바꾸고 싶다.  

### 1. Make New Level
- 우선 기존 테스트용 레벨에서 벗어나 새로운 레벨에서 작업을 해야 할 것이다.  
좌측 상단의 `File` -> `새 레벨` 에서 새로운 레벨을 생성할 수 있다.  

<br>

### 2. 지오메트리 브러시 (BSP)
- 이제 맵에서 기본으로 주어지는 지형은 삭제하고,  
우리가 원하는대로 지형을 구성해 나가며 맵을 채울 것이다.  
이를 위하여, 지오메트리 브러시(BSP) 라는 언리얼의 기능을 사용할 것이다.  

- 지오메트리 브러시를 이용하기 위하여, 우리가 액터를 생성하던 때에 사용한 아이콘을 클릭하여  
`액터 배치 패널`을 클릭한다.  
아마도 기존에 액터를 추가하던 방식보다 더욱 세밀하고 다양하게 액터를 생성할 수 있는 탭이 뜰 것이다.  

- 여기서 우리는 `지오매트리` 탭에서 작업을 할 것이다.  
우리가 돌아다닐 기본적인 컨테이너를 만들기 위해 `Box` 지형을 생성하고,  
적당한 크기로 확장한 후 하나는 `Subtractive` 속성을, 하나는 조금 더 큰 크기로 덮어주고 `Additive` 속성을 주어보자.  
`Subtractive` 속성은 어떠한 다른 `Additive` 속성의 지형 속에 들어갔을 때,  
해당 공간을 빼주는(`Subtractive`), 그리하여 도넛처럼 속을 파내주는 역할을 한다.  

- 이를 이용하여 `Subtractive` 지형들을 몇 개 더 만들고,  
벽에 창문과 같은 구멍을 뚫어주는 작업도 응용할 수 있을 것이다.  

<br>

### 3. Matrials and Lights
- 지오메트리 브러시를 사용하여 멋있는 바닥과 벽, 천장들을 만들었지만, 마치 포토샵에서 투명배경을 연상케하는 격자무늬는 다소 보기 안좋다.  
이러한 기본 재질 말고, 직접 재료와 조명을 추가하여 더 있어보이게 꾸며보자.  

- 아주 간단하다. 컨텐츠 드로어에서 Material로 사용할 수 있는 아이템을 찾아서, 적용하고 싶은 지오메트리에 드래그&드롭 하면 끝이다.  

  - 컨텐츠 드로어에서 Matrial 같은 특정 속성의 아이템들을 쉽게 찾고싶다면,  
  검색 칸 바로 왼쪽의 필터링 기능을 이용하면 간편하다.  

- 조명은 아웃라이너에서 `light`을 검색했을 때 나타나는 `Directional Light`를 컨트롤하여 다룰 수 있다.  
방향성을 가진 광원이며, 각도에 따라 빛이 들어오는 양이 달라질 것이다.  

<br>

## Actor Component
- 우리는 앞서 어떠한 액터든 무언가 Component를 가지고 있는 것을 보았으며, 대표적으로 `StaticMeshComponent`가 있었다.  

### 1. Child Component
- 우리는 선반의 뼈대 액터와 선반의 나무판자 액터를 하나처럼 다루고 싶다.  
그래서 뼈대를 양 쪽에 두고, 선반을 가운데에 잘 놓았다.  
그런데 이 액터들이 매우 불안정하다! 서로 잘 붙어 있는 것 같지만, 실제로는 서로 낑겨서 물리법칙을 마구 무시하며 프로그램이 망가진다.  
이들을 하나의 액터 처럼 다루고 싶다.  

- 이 액터들은 하나의 스태틱 메시 컴포넌트를 가지고 있지만, 하나 이상 가질 수도 있다 !  
원하는 만큼 추가할 수 있는 것이다.  

  - 한번,선반의 나무판자 액터를 직접 씬에 드래그하여 추가하는 게 아니라,  
  선반 뼈대 액터의 스태틱 메시 컴포넌트에 드래그해보자.  

  - 이랬더니, 뼈대 액터의 스태틱 메시 컴포넌트를 부모로 하는 자식 컴포넌트로서 액터가 들어갔다 !  

    - 이제 스태틱 메시 컴포넌트는 `루트 컴포넌트`가 되었다.  

  - 이렇게 하여 실제로 하나의 액터가 되었기 때문에,  
  부모 액터의 위치를 변경하면, 속성으로 들어있는 자식 액터 또한 함께 움직인다.  

  - 또한, 부모 액터의 경우 `Location` 속성이 레벨 기준이라 매우 복잡한 값을 가질 수 있어도,  
  자식 속성으로 들어가게 된 액터의 경우,  
  부모 액터의 위치를 기준으로 값이 결정되었기 때문에,  
  `x:0  y:0  z:0` 부터 시작하게 된다.  
  이는 매우 위치를 결정하는 데에 있어 편리함을 가져다 준다 !  

  <br>

### 2. Collision Meshes
- 액터를 추가할 때, 어떤 기존 선반이나 바닥같은 평평한 물체 위에 액터를 추가하는 것은 안정적이며,  
언리얼은 자동으로 정확히 바로 위에 설치할 수 있도록 지원해 준다.  

- 그런데, 이렇게 평평하지는 않아도, 상식적으로 서로 쌓아올릴 수 있어야하는 배럴같은 액터들을 쌓아 올려 보면,  
잘 쌓았다고 생각이 듬에도 불구하고 게임을 시작하자마자 튀어오르는 등, 매우 불안정 할 것이다.  

- 이유는, 언리얼에서 충돌을 계산하는 방식 때문이다.  

  - 메시에 대하여 알아보자.  
  뷰포트 좌측 상단의 뷰 모드를 `와이어프레임`으로 변경하면,  
  컴퓨터가 재료를 볼 때의 복잡한 메시들을 볼 수 있다.  
  게임 엔진에서는 물릭학을 더욱 쉽게 적용할 수 있도록, 모든 세상을 쪼개어 이러한 메시로서 사용한다.  

  - 이번엔 뷰 모드를 `플레이어 콜리젼`으로 변경하면,  
  다소 단순화된 충돌 메시를 관찰할 수 있다.  
  아까 전에 쌓아올릴 때 매우 불안정 했던 배럴 액터들 같은 경우,  
  알고보니 충돌 메시가 평평하지 않고 울퉁불퉁했다.  

- 언리얼에서는 이러한 액터들의 메시를 쉽게 변경할 수있다.  
수정하고자 하는 메시를 더블클릭하면, 해당 메시와 단 둘이 있게되는 정적 메시 에디터가 열린다.  
해당 메시가 어떻게 생겼는지 자세히 관찰할 수 있다.  

  - 여기서, 좌측 상단의 `콜리전` 탭에서 모든 콜리전을 제거해보자.  
  
  - 그리고 다시 원래 메인 레벨로 돌아가서 보면, 콜리젼 뷰에서도 아무것도 보이지 않으며,  
  게임을 시작하게 되면 물리학을 적용했음에도 땅을 뚫고 떨어져버린다.  
  충돌할 게 아무 것도 없어졌기 때문이다.  

  - 이제 다시 콜리젼을 생성할 건데, 더 안정적일 수 있도록  
  더 낮은 차원의 면체로 콜리젼을 생성할 것이다.  
  `콜리젼`탭에서, 박스나 10면체와 같은 콜리젼을 생성하자.  

<br>

## Game mechanism
### 1. Variables
- 변수는 무언가 정보를 저장하고 담아주는 데에 유용하게 사용되겠다.  

- 블루프린트에서 변수는 어떻게 생성할 까?

  - 블루프린트 에디터에서, 좌측 상단의 `창` -> `내 블루프린트` 를 클릭하면, 좌측에 새로운 창이 뜬다.  
  이 창에서, 기존에는 추가할 수 없던 더 많은 종류의 노드들을 추가할 수 있게 된다.  
  이 중에는 변수와 함수도 포함된다.  

  - 변수의 이름과 타입을 지정해주고, 기본값도 지정해줄 수 있다. (컴파일 해야함)  
  그리고 변수를 이벤트 그래프에 가져다 놓으면,  
  `Getter` 메소드 또는 `Setter` 메소드를 이끌어낼 수 있게 해준다.  
    
    - `Ctrl` + `드래그` : `Getter`
    - `Alt` + `드래그` : `Setter`

<br>

### 2. Booleans & Branches
- 프로그램에서 특정한 경우에 특정한 행동 또는 제약을 걸고 싶을 수 있기 때문에,  
Boolean Expression을 걸고 싶을 수 있다.  

- 블루프린트에서 Boolean Expression을 다루는 노드를 Branch Node 라고 한다.  
특정한 행동이 `True` 인지 `False` 인지에 따라 각 실행 핀에 연결된 행동을 이어나갈 수 있다.  

- 대표적으로 `Greater`, `Equal`, `Less` 등 처럼 `Boolean`을 리턴하는 노드와 연계하여 사용한다.  

<br>

### 3. Functions
- 블루프린트 에디터에 노드들이 너무 많아지면서, 알아보기 힘든 수준이 되었다.  
이들을 같은 역할을 하는 것들끼리 모아서 정리하고싶다.  

#### [1] Comment Block
- 블루프린트를 정리하는 방식으로 `코멘트 블록`이라는 기능이 있다.  
묶을 노드들을 모두 선택하여 `C`를 누르면 하나로 묶이게 되고, 해당 블록에 이름을 달 수 있다.  

- 하지만 우리는 함수라는 기능이 있기 때문에, 이는 사용하지 않을 것이다. (물론 유용하다)

#### [2] Function
- 함수는, 게임에서 무언가 행동을 하기 위한 블루프린트 블록을 실행한다.  

- 이미 우리가 사용하고 있던 많은 노드들 또한 함수였다.  
무언가를 받아서, 무언가를 배출하는, 때로는 아무것도 받거나 배출하지 않는 것들도, 모두 함수였다.  

- 그런데 우리는 우리의 own 함수들을 직접 만들 수도 있다.  
그렇게 하여, 같은 기능을 하는 노드들을 하나의 함수로 묶어서 더욱 organize 할 수 있을 것이다.  

- 함수를 사용함으로서 코드 블록의 재사용성도 높일 수 있다.  

- 함수를 만드는 방법은 간단하다.  
하나로 묶을 노드들을 모두 선택하고, 우클릭하여 `함수로 접기`를 선택하면 된다.  
적절한 이름을 입력하여 함수 생성을 마무리한다. (이름을 잘 짓는 것은 매우 중요하다)

  - camelCase 방식으로 함수 이름을 잘 작성하면, 노드 이름에 자동적으로 띄어쓰기가 반영된다.  

<br>

#### [3] Function Argument & Return
- 우선, 기존 노드들을 묶어서 함수로 만들 수 있다는 사실은 알게되었다.  
하지만 때로는, 아예 함수를 백지상태부터 새로 만들어 나가고 싶을 수도 있다.  

- 함수를 처음 부터 새로 만들고 싶다면,  
`My Blueprint` 탭의 `Functions` 영역 우측의 `+` 버튼을 클릭하여 생성한다.  

- 함수에 넣고 싶은 노드들을 넣을 수 있으며,  
우리가 주목해야할 포인트는 함수 에디터의 오른쪽 `Details` 탭이다.  
여기서 `Inputs` 옵션과 `Outputs` 옵션을 확인할 수 있는데, 이곳에서 파라미터를 추가할 수 있다.  

<br>

#### [4] Pure Function
- 때로는 실행 핀이 필요 없는 함수도 있을 수 있다.  

- 이는 함수에 Side Effect가 없는 함수임을 의미하는데,  
사이트 이펙트가 존재하는 함수는 호출하였을 때, 눈에 보이는 무언가의 효과를 발생시킴을 의미한다.  

- 이러한 함수를 다른 말로 `Pure Function`(순수 함수) 라고도 부른다.  
오직 리턴 값 만을 가진다.  

- 어떠한 함수를 순수 함수로 만들고 싶다면,  
해당 함수를 클릭하여 `Details` 탭에서 `Pure`를 체크해주면 된다.  
그렇게하면, 실행 핀이 사라지게 된다.  
만약 기존의 실행 핀에 연결이 있었다면, 해당 연결은 사라지거나 적절한 다음 노드로 Directly 연결될 것이다.  

- 물론, Pure Function으로의 변환은 Side Effect가 없어야만 할 것이다.  
그렇지 않으면 위험할 수 있다.  

<br>

#### [5] Member Function
- 객체지향 프로그래밍을 공부했다면,  
클래스는 멤버 변수들과 멤버 함수들로 구성되어 있음을 알 것이다.  

- 멤버 함수는 해당 클래스에 대한 인스턴스에서 호출되는 함수이다.  

- 멤버 함수를 만들어주고 나면,  
레벨 블루프린트와 같이 외부에서 해당 인스턴스를 리턴하거나 하는 경우에  
해당 리턴 값(인스턴스)으로부터 멤버 함수를 호출하도록 할 수 있다.  
비록 해당 멤버 함수는 실행 핀이 없는 것처럼 보여도 말이다.  

  - 정확히는 실행 핀이 없는 것으로 보여도,  
  Implicitly 모든 멤버 함수는 `self`라는 현재 타겟 파라미터를 가지고 있다고 보면 된다.  

  - `self` 노드를 사용하여 레퍼런스를 가져와 객체의 속성을 `get` 할 수도 있다.  

- 멤버 함수를 사용하여, 어떠한 특정 객체에 속하는 기능만 수행하는 노드 집합들을,  
해당 클래스의 멤버 함수로 생성하고 밖에서 호출하는 형태로 작성한다면,  
함수의 재사용성도 높아지고 Cohesion도 뛰어나지게 될 것이다.  

## Reloading Levels
### 1. Level Node
- 현재 레벨을 다시 불러오기 위하여 게임을 종료하는 것은 Nonsense.  
특정 노드를 사용하여 현재 레벨을 다시 불러오고 싶다.  
이 때 사용하는 노드가 `레벨 노드`이다.  

- 레벨 노드는 두 가지 종류가 있지만 만약 `Open Level(by name)`을 사용한다면,  
`Get Current Level Name` 노드를 사용하여 레벨 이름을 얻어내 사용할 수 있겠다.  

### 2. Delay Node
- 게임이 즉시 재시작된다면, 사용자로 하여금 당혹감을 줄 수도 있겠다.  
따라서, 일정 시간의 딜레이를 준 후, 사용자에게 해당 딜레이 이후 재시작됨을 알리고 이후의 일을 수행한다면 더 좋을 것이다.  

- 이럴 때 `지연 노드`가 사용된다. 노드의 이름은 `Delay`.  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 Udemy에서 제공한  
*Unreal Engine 5 C++ 개발자: C++ 학습하고 비디오 게임 제작하기*  
강좌를 바탕으로 작성되었습니다.  

</div>
</details> 