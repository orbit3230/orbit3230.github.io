---
layout: post
title: "[데이터베이스] 12주차 - 트랜잭션, 동시성 제어, 회복"
excerpt: "트랜잭션, 동시성 제어, 트랜잭션 고립 수준, 회복"

tags:
  - [데이터베이스]

toc: true

date: 2025-11-17
last_modified_at: 2025-11-20
---
## 트랜잭션, 동시성 제어, 회복
### 1. 트랜잭션  
- 트랜잭션(Transaction) : DBMS에서 데이터를 다루는 논리적인 작업의 단위

- 데이터베이스에서 트랜잭션을 정의하는 이유
  - 데이터베이스에서 데이터를 다룰 때 장애가 발생하면 데이터를 복구하는 작업의 단위가 됨
  - 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때 작업을 서로 분리하는 단위가 됨

- 트랜잭션은 전체가 수행되거나 전혀 수행되지 않아야 함(all or nothing)

<br>

- 계좌이체 트랜잭션 예시  
![transaction_example][def]  

- 트랜잭션 수행 과정  
![transaction_process_1][def2]  
![transaction_process_2][def3]  

- 트랜잭션의 종료(COMMIT)를 알리는 방법
  - [방법 1] (1)-(2)-(3)-(4)-COMMIT-(5)-(6)
  - [방법 2] (1)-(2)-(3)-(4)-(5)-(6)-COMMIT  
  - DBMS는 사용자에게 빠른 응답성을 보장하기 위해 [방법 1]을 선택  
  ![transaction_commit_method][def4]  

<br>

- 트랜잭션의 ACID 성질
  - Atomicity(원자성) : 트랜잭션에 포함된 작업은 전부 수행되거나, 아니면 전부 수행되지 않아야(all or nothing) 함
    - 오라클의 트랜젝션 제어 명령어(TCL)  
    ![oracle_tcl_commands][def5]  

  - Consistency(일관성) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 함
    - 일관성은 테이블이 생성 시 `CREATE`문과 `ALTER`문의 무결성 제약조건을 통해 명시  
    ![integrity_constraints][def6]  

  - Isolation(고립성) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함
    - 고립성을 유지하기 위해서는 트랜잭션이 변경 중인 임시 데이터를 다른 트랜잭션이 읽고 쓸 때 제어가 필요  
    ![isolation_example][def7]

  - Durability(지속성) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함  
  ![durability_example][def8]  

<br>

- 트랜잭션의 성질과 DBMS 기능 간 관계  
![transaction_properties_vs_dbms_features](TODO)  

<br>

### 2. 동시성 제어
- 동시성 제어(Concurrency Control) : 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능  

- 트랜잭션의 읽기/쓰기 시나리오  
![transaction_read_write_scenarios](TODO)  

<br>

- 갱신손실(lost update)
  - 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생
  - 데이터베이스에서 절대 발생해서는 안 되는 현상  
  ![lost_update_example](TODO)  

<br>

- 락(Lock)
  - 갱신손실 문제를 해결하려면 상대방 트랜잭션이 데이터를 사용하는지 여부를 알 수 있는 규칙이 필요
  - 데이터를 수정 중이라는 사실을 알리는 방법의 잠금장치

- 락을 이용한 갱신손실 문제 해결  
![lost_update_solution_with_locks](TODO)  

- 락의 유형
  - 락은 트랜잭션이 읽기를 할 때 사용하는 락인 **공유락**(**LS**, Shared Lock)과,  
  읽고 쓰기를 할 때 사용하는 **배타락**(**LX**, Exclusive Lock)으로 구분  

  - 공유락과 배타락을 사용하는 규칙
    - 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다.
    - 트랜잭션이 데이터 `X`를 읽기만 할 경우 `LS(X)`를 요청하고, 읽거나 쓰기를 할 경우 `LX(X)`를 요청한다.  
    - 다른 트랜잭션이 데이터에 `LS(X)`를 걸어둔 경우, `LS(X)`의 요청은 허용하고 `LX(X)`는 허용하지 않는다.
    - 다른 트랜잭션이 데이터에 `LX(X)`를 걸어둔 경우, `LS(X)`와 `LX(X)` 모두 허용하지 않는다.
    - 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

  - 락 호환행렬

  |요청\상태|LS 상태|LX 상태|
  |:---:|:---:|:---:|
  |LS 요청|허용|대기|
  |LX 요청|대기|대기|  

<br>

### 3. 트랜잭션 고립 수준  

<br>

### 4. 회복  

<br>          
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 최황규 교수님의 데이터베이스 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/ZkT8PWU.png
[def2]: https://i.imgur.com/oKb5IqC.png
[def3]: https://i.imgur.com/z1HdOz2.png
[def4]: https://i.imgur.com/l1byK1Y.png
[def5]: https://i.imgur.com/Kn5KkfB.png
[def6]: https://i.imgur.com/KRQuJFZ.png
[def7]: https://i.imgur.com/1LQ0vDI.png
[def8]: https://i.imgur.com/HAG9HOS.png