---
layout: post
title: "[데이터베이스] 12주차 - 트랜잭션, 동시성 제어, 회복"
excerpt: "트랜잭션, 동시성 제어, 트랜잭션 고립 수준, 회복"

tags:
  - [데이터베이스]

toc: true

date: 2025-11-17
last_modified_at: 2025-12-04
---
## 트랜잭션, 동시성 제어, 회복
### 1. 트랜잭션  
- 트랜잭션(Transaction) : DBMS에서 데이터를 다루는 논리적인 작업의 단위

- 데이터베이스에서 트랜잭션을 정의하는 이유
  - 데이터베이스에서 데이터를 다룰 때 장애가 발생하면 데이터를 복구하는 작업의 단위가 됨
  - 데이터베이스에서 여러 작업이 동시에 같은 데이터를 다룰 때 작업을 서로 분리하는 단위가 됨

- 트랜잭션은 전체가 수행되거나 전혀 수행되지 않아야 함(all or nothing)

<br>

- 계좌이체 트랜잭션 예시  
![transaction_example][def]  

- 트랜잭션 수행 과정  
![transaction_process_1][def2]  
![transaction_process_2][def3]  

- 트랜잭션의 종료(COMMIT)를 알리는 방법
  - [방법 1] (1)-(2)-(3)-(4)-COMMIT-(5)-(6)
    - **지연 갱신 방법**(deferred update)
  - [방법 2] (1)-(2)-(3)-(4)-(5)-(6)-COMMIT  
    - **즉시 갱신 방법**(immediate update)
  - DBMS는 사용자에게 빠른 응답성을 보장하기 위해 [방법 1]을 선택  
  ![transaction_commit_method][def4]  

<br>

- 트랜잭션의 ACID 성질
  - Atomicity(원자성) : 트랜잭션에 포함된 작업은 전부 수행되거나, 아니면 전부 수행되지 않아야(all or nothing) 함
    - 오라클의 트랜젝션 제어 명령어(TCL)  
    ![oracle_tcl_commands][def5]  

  - Consistency(일관성) : 트랜잭션을 수행하기 전이나 수행한 후나 데이터베이스는 항상 일관된 상태를 유지해야 함
    - 일관성은 테이블이 생성 시 `CREATE`문과 `ALTER`문의 무결성 제약조건을 통해 명시  
    ![integrity_constraints][def6]  

  - Isolation(고립성) : 수행 중인 트랜잭션에 다른 트랜잭션이 끼어들어 변경 중인 데이터 값을 훼손하는 일이 없어야 함
    - 고립성을 유지하기 위해서는 트랜잭션이 변경 중인 임시 데이터를 다른 트랜잭션이 읽고 쓸 때 제어가 필요  
    ![isolation_example][def7]

  - Durability(지속성) : 수행을 성공적으로 완료한 트랜잭션은 변경한 데이터를 영구히 저장해야 함  
  ![durability_example][def8]  

<br>

- 트랜잭션의 성질과 DBMS 기능 간 관계  
![transaction_properties_vs_dbms_features][def9]  

<br>

### 2. 동시성 제어
- 동시성 제어(Concurrency Control) : 트랜잭션이 동시에 수행될 때, 일관성을 해치지 않도록 트랜잭션의 데이터 접근을 제어하는 DBMS의 기능  

- 트랜잭션의 읽기/쓰기 시나리오  
![transaction_read_write_scenarios][def10]  

<br>

- 갱신손실(lost update)
  - 두 개의 트랜잭션이 한 개의 데이터를 동시에 갱신할 때 발생
  - 데이터베이스에서 절대 발생해서는 안 되는 현상  
  ![lost_update_example][def11]  

<br>

- 락(Lock)
  - 갱신손실 문제를 해결하려면 상대방 트랜잭션이 데이터를 사용하는지 여부를 알 수 있는 규칙이 필요
  - 데이터를 수정 중이라는 사실을 알리는 방법의 잠금장치

- 락을 이용한 갱신손실 문제 해결  
![lost_update_solution_with_locks][def12]  

- 락의 유형
  - 락은 트랜잭션이 읽기를 할 때 사용하는 락인 **공유락**(**LS**, Shared Lock)과,  
  읽고 쓰기를 할 때 사용하는 **배타락**(**LX**, Exclusive Lock)으로 구분  

  - 공유락과 배타락을 사용하는 규칙
    - 데이터에 락이 걸려있지 않으면 트랜잭션은 데이터에 락을 걸 수 있다.
    - 트랜잭션이 데이터 `X`를 읽기만 할 경우 `LS(X)`를 요청하고, 읽거나 쓰기를 할 경우 `LX(X)`를 요청한다.  
    - 다른 트랜잭션이 데이터에 `LS(X)`를 걸어둔 경우, `LS(X)`의 요청은 허용하고 `LX(X)`는 허용하지 않는다.
    - 다른 트랜잭션이 데이터에 `LX(X)`를 걸어둔 경우, `LS(X)`와 `LX(X)` 모두 허용하지 않는다.
    - 트랜잭션이 락을 허용받지 못하면 대기 상태가 된다.

  - 락 호환행렬

  |요청\상태|LS 상태|LX 상태|
  |:---:|:---:|:---:|
  |LS 요청|허용|대기|
  |LX 요청|대기|대기|  

  <br>

- 2단계 락킹(2 Phase Locking, 2PL)
  - 락을 걸고 해제하는 시점에 제한을 두지 않으면 두 개의 트랜잭션이 동시에 실행될 때 데이터의 일관성이 깨질 수 있어 이를 방지하는 기법
  - 확장단계(Growing Phase, Expanding Phase) : 트랜잭션이 필요한 락을 획득하는 단계. 이 단계에서는 이미 획득한 락을 해제하지 않음
  - 수축단계(Shrinking Phase) : 트랜잭션이 락을 해제하는 단계. 이 단계에서는 새로운 락을 획득하지 않음  

- 락을 사용하되 2단계 락킹을 사용하지 않은 경우  
![no_2pl_example][def13]  

- 2단계 락킹을 사용한 경우  
![2pl_example][def14]  

<br>

- 데드락(Deadlock)
  - 두 개 이상의 트랜잭션이 각각 자신의 데이터에 대하여 락을 획득하고 상대방 데이터에 대하여 락을 요청하면 서로 대기 상태에 빠져 영원히 진행되지 않는 현상. 교착 상태라고도 함.  

- 데드락 예시  
![deadlock_example_1][def15]  
![deadlock_example_2][def16]  

- Wait-for 그래프  
![wait_for_graph_example][def17]  

<br>

### 3. 트랜잭션 고립 수준 ★
- 오손 읽기(Dirty Read)
  - 읽기 작업을 하는 트랜잭션 1이 쓰기 작업을 하는 트랜잭션 2가 작업한 중간 데이터를 읽기 때문에 생기는 문제
  - 작업 중인 트랜잭션 2가 어떤 이유에서 작업을 철회(ROLLBACK)할 경우 트랜잭션 1은 무효가 된 데이터를 읽게 되고 잘못된 결과를 도출하는 현상

- 오손 읽기 예시  
![dirty_read_example_1][def18]  
![dirty_read_example_2][def19]  

<br>

- 반복불가능 읽기(Non-Repeatable Read)
  - 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(UPDATE) 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
  - 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전의 결과와 다른 결과가 나오는 현상  

- 반복불가능 읽기 예시  
![non_repeatable_read_example][def20]  

<br>

- 유령데이터 읽기(Phantom Read)
  - 트랜잭션 1이 데이터를 읽고 트랜잭션 2가 데이터를 쓰고(INSERT) 트랜잭션 1이 다시 한 번 데이터를 읽을 때 생기는 문제
  - 트랜잭션 1이 읽기 작업을 다시 한 번 반복할 경우 이전에 없던 데이터(유령 데이터)가 나타나는 현상  

- 유령데이터 읽기 예시  
![phantom_read_example][def21]  

<br>

- 트랜잭션 고립 수준 명령어(transaction isolation level instruction) : DBMS는 트랜잭션을 동시에 실행시키면서 락보다 좀 더 완화된 방법으로 문제를 해결하기 위해 트랜잭션 고립 수준을 제공  
![transaction_isolation_levels][def22]  
  - `READ UNCOMMITTED` : 고립 수준이 가장 낮은 명령어. 아무런 공유락을 걸지 않음.  
  `SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;`  

  - `READ COMMITTED` : 오손(dirty) 페이지의 참조를 피하기 위해 자신의 데이터를 읽는 동안 공유락을 걸지만, 트랜잭션이 끝나기 전에라도 해지 가능. (`SELECT`문에 공유락을 걸고, 끝나면 바로 해제)  
  `SET TRANSACTION ISOLATION LEVEL READ COMMITTED;`  

  - `REPEATABLE READ` : 자신의 데이터에 설정된 공유락과 배타락을 트랜잭션이 종료할 때까지 유지하여 다른 트랜잭션이 자신의 데이터를 갱신(UPDATE)하지 못하게 함. (`SELECT`문에 공유락을 걸고, 트랜잭션이 끝날 때까지 유지)  
  `SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;`  

  - `SERIALIZABLE` : 고립 수준이 가장 높은 명령어. 실행 중인 트랜잭션은 다른 트랜잭션으로부터 완벽하게 분리된다. (`SELECT`문에 공유락을 걸고, 트랜잭션이 끝날 때까지 유지하며, 인덱스에 공유락을 설정하여 다른 트랜잭션의 `INSERT`문도 금지됨)  
  `SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;`  

<br>

### 4. 회복  
- 회복(Recovery) : 데이터베이스에 장애가 발생했을 때 데이터베이스를 일관성 있는 상태로 되돌리는 DBMS의 기능

- 로그 파일(log file)
  - 트랜잭션이 반영한 모든 데이터의 변경사항을 데이터베이스에 기록하기 전에 미리 기록해두는 별도의 데이터베이스
  - DBMS는 트랜잭션이 수행 중이거나 수행이 종료된 후 발생하는 데이터베이스 손실을 방지하기 위해 트랜잭션의 기록을 추적하는 로그 파일을 사용
  - 안전한 하드디스크에 저장되며 전원과 관계없이 기록이 보존됨

- 로그 파일에 저장된 로그의 구조  
`<트랜잭션번호, 로그의 타입, 데이터 항목 이름, 수정 전 값, 수정 후 값>`  
![log_file_example][def23]  
  - `로그의 타입` : `START`, `INSERT`, `UPDATE`, `DELETE`, `ABORT`, `COMMIT` 등  

- 트랜잭션 수행과 로그 파일  
![transaction_execution_and_log_file][def24]  

- 로그 파일을 이용한 회복
  - 데이터의 변경 기록을 저장해 둔 로그 파일을 이용하면 시스템 장애도 복구 가능  
  - 트랜잭션 Example  
  ![transaction_example_for_recovery][def25]  

  - 로그 파일 Example  
  ![log_file_example_for_recovery][def26]  

  - 시스템 운영 중 장애가 발생하여 시스템이 다시 가동되었을 때 DBMS는 로그 파일을 먼저 살펴본다. DBMS는 트랜잭션이 종료되었는지 혹은 중단되었는지 여부를 판단하여 종료된 트랜잭션은 종료를 확정하기 위하여 재실행(`REDO`)하고, 중단된 트랜잭션은 없던 일로 되돌리기 위해 취소(`UNDO`) 작업을 수행한다.

    - 트랜잭션의 재실행(`REDO`)
      - 로그파일에 트랜잭션 시작(`START`)이 있고 종료(`COMMIT`)가 있는 경우
      - 트랜잭션이 모두 완료되었으나, 변경 내용이 버퍼에서 데이터베이스에 기록되지 않았을 가능성이 있으므로 다시 기록하는 작업
    
    - 트랜잭션의 취소(`UNDO`)
      - 로그파일에 트랜잭션의 시작(`START`)만 있고 종료(`COMMIT`)가 없는 경우
      - 트랜잭션이 완료되지 않았으므로, 트랜잭션이 변경한 내용을 모두 취소하는 작업  

  - ★ 트랜잭션 로그와 회복 방법  
  ![log_file_example_for_recovery][def27]  
    - 즉시 갱신 방법을 사용한 경우  
    ![immediate_update_recovery_example][def28]  

    - 지연 갱신 방법을 사용한 경우  
    ![deferred_update_recovery_example][def29]  

  <br>

- 체크포인트를 이용한 회복
  - 로그를 이용한 회복은, 어느 시점까지 되돌아가야 하는 지 알 수 없음.
  - 또한 트랜잭션이 많은 경우, 하루 이상 되돌아가서 복구하는 것은 사실상 불가능.
  - 체크포인트(checkpoint) : 몇 십 분 단위로 데이터베이스와 트랜잭션 로그 파일을 동기화한 후, 동기화한 시점을 로그 파일에 기록하는 방법.
    - 회복 시 많은 양의 로그를 검색하고 갱신하는 시간을 줄일 수 있다.  

- 체크포인트가 있으면, 로그를 이용한 회복 기법이 더 간단해진다.
  - 체크포인트 이전에 `COMMIT` 기록이 있는 경우
    - 아무 작업이 필요 없다. 로그에 체크포인트가 나타나는 시점은 이미 변경 내용이 데이터베이스에 모두 기록된 후.

  - 체크포인트 이후에 `COMMIT` 기록이 있는 경우
    - `REDO`를 진행. 체크포인트 이후에 변경 내용이 데이터베이스에 반영되지 않았음.

  - 체크포인트 이후에 `COMMIT` 기록이 없는 경우
    - 즉시 갱신 방법 : `UNDO`를 진행. 버퍼의 내용이 반영되었을 수도 있기 때문.
    - 지연 갱신 방법 : 아무 작업이 필요 없다. 지연 갱신 방법은 `COMMIT` 이전에는 버퍼의 내용을 데이터베이스에 반영하지 않기 때문.  

- 트랜잭션 로그 기록과 체크포인트  
![log_file_with_checkpoint_example][def30]  
  - 즉시 갱신 방법을 사용했다면 `T2`, `T3`는 아무 작업이 필요 없고, `T4`, `T5`는 `REDO`, `T1`, `T6`는 `UNDO`가 필요
  - 지연 갱신 방법을 사용했다면 `T2`, `T3`는 아무 작업이 필요 없고, `T4`, `T5`는 `REDO`가 필요하며, `T1`, `T6`는 아무 작업이 필요 없음  

- ★ 트랜잭션 `T1`, `T2`, `T3`가 동시에 실행된 후 다음과 같이 로그 기록을 남겼다.  
![log_file_with_checkpoint_example_2][def31]  
  - 즉시 갱신 기법을 사용하여 회복을 한다면 `REDO(T2)`, `UNDO(T3)`가 진행된다. `T1`에 대해서는 아무 작업이 필요 없다.  

<br>          
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 최황규 교수님의 데이터베이스 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/ZkT8PWU.png
[def2]: https://i.imgur.com/oKb5IqC.png
[def3]: https://i.imgur.com/z1HdOz2.png
[def4]: https://i.imgur.com/l1byK1Y.png
[def5]: https://i.imgur.com/Kn5KkfB.png
[def6]: https://i.imgur.com/KRQuJFZ.png
[def7]: https://i.imgur.com/1LQ0vDI.png
[def8]: https://i.imgur.com/HAG9HOS.png
[def9]: https://i.imgur.com/HyftYIp.png
[def10]: https://i.imgur.com/LT35XFm.png
[def11]: https://i.imgur.com/y51WDWs.png
[def12]: https://i.imgur.com/AcXvfia.png
[def13]: https://i.imgur.com/iKcULSs.png
[def14]: https://i.imgur.com/gQRoTIz.png
[def15]: https://i.imgur.com/bPivzAR.png
[def16]: https://i.imgur.com/mm358It.png
[def17]: https://i.imgur.com/Jtlf0KY.png
[def18]: https://i.imgur.com/6n3LGie.png
[def19]: https://i.imgur.com/I1gWeVB.png
[def20]: https://i.imgur.com/lm2Ks4J.png
[def21]: https://i.imgur.com/GQwNOH9.png
[def22]: https://i.imgur.com/Mud00MR.png
[def23]: https://i.imgur.com/janVEIT.png
[def24]: https://i.imgur.com/8ypazZh.png
[def25]: https://i.imgur.com/L7XpRQv.png
[def26]: https://i.imgur.com/eYegyik.png
[def27]: https://i.imgur.com/L7XpRQv.png
[def28]: https://i.imgur.com/Tl7DSDS.png
[def29]: https://i.imgur.com/CJq3bVD.png
[def30]: https://i.imgur.com/xraDugz.png
[def31]: https://i.imgur.com/WRzBmi2.png