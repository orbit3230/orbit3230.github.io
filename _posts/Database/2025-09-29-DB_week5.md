---
layout: post
title: "[데이터베이스] 5주차 - SQL 고급"
excerpt: "내장 함수, 부속 질의, 뷰, 인덱스"

tags:
  - [데이터베이스]

toc: true

date: 2025-09-29
last_modified_at: 2025-10-13
---
## SQL 고급
### 1. 내장 함수
- SQL에서는 함수의 개념을 사용하는데, 수학의 함수와 마찬가지로 특정 값이나 열의 값을 입력받아 그 값을 계산하여 결과 값을 알려줌  
![sql_function][def]  

- SQL의 함수는 DBMS가 제공하는 내장 함수(built-in function)와 사용자가 필요에 따라 직접 만드는 사용자 정의 함수(user-defined function)로 나눌 수 있음  

<br>

- **SQL 내장 함수**
  - SQL 내장 함수는 상수나 속성 이름을 입력 값으로 받아 단일 값을 결과로 반환
  - 모든 내장 함수는 최초에 선언될 때 유효한 입력 값을 받아야 함
  - `SELECT` 절, `WHERE` 절, `UPDATE SET` 절 등에서 사용
  - 오라클에서 제공하는 주요 내장 함수  
  ![oracle_function][def2]  

<br>

- 숫자 함수  

|함수|설명|예|
|---|---|---|
|`ABS(숫자)`|숫자의 절댓값 계산|`ABS(-4.5)` = `4.5`|
|`CEIL(숫자)`|숫자보다 크거나 같은 최소의 정수|`CEIL(4.1)` = `5`|
|`FLOOR(숫자)`|숫자보다 작거나 같은 최대의 정수|`FLOOR(4.1)` = `4`|
|`ROUND(숫자, m)`|`m` 자리를 기준으로 숫자 반올림|`ROUND(5.36, 1)` = `5.40`|
|`LOG(n, 숫자)`|숫자의 자연로그 값 반환|`LOG(10) = 2.30259`|
|`POWER(숫자, n)`|숫자의 `n` 제곱 값 계산|`POWER(2, 3)` = `8`|
|`SQRT(숫자)`|숫자의 제곱근 값 계산(양수)|`SQRT(9.0)` = `3.0`|
|`SIGN(숫자)`|숫자가 음수이면 `-1, `0`이면 `0`, 양수이면 `1`|`SIGN(3.45)` = `1`|

- Example 1 - `-78` 과 `+78`의 절댓값

```sql
SELECT ABS(-78), ABS(78)
FROM Dual;
```

- `Dual` 테이블은 dummy 테이블로, 오라클에서 제공하는 가상 테이블

- Example 2 - `4.875`를 소수 첫째 자리까지 반올림한 값  

```sql
SELECT ROUND(4.875, 1)
FROM Dual;
```

- Example 3 - 고객별 평균 주문 금액을 백 원 단위로 반올림한 값  

```sql
SELECT custid "고객번호", ROUND(SUM(saleprice)/COUNT(*), -2) "평균금액"
FROM Orders
GROUP BY custid;
```

<br>

- 문자 함수

|함수|설명|
|---|---|
|`CHR(k)`|정수 아스키코드를 문자로 변환|
|`CONCAT(s1, s2)`|두 문자열을 연결|
|`INITCAP(s)`|문자열의 첫 글자를 대문자로 변환|
|`LOWER(s)`|대상 문자열을 모두 소문자로 변환|
|`LPAD(s, n, c)`|대상 문자열(`s`)의 왼쪽부터 지정한 자릿수(`n`)까지 지정한 문자(`c`)로 채움|
|`LTRIM(s1, s2)`|대상 문자열의 왼쪽부터 지정한 문자들을 제거|
|`REPLACE(s1, s2, s3)`|대상 문자열(`s1`)에서 지정한 문자열(`s2`)을 다른 문자열(`s3`)로 대체|
|`RPAD(s, n, c)`|대상 문자열(`s`)의 오른쪽부터 지정한 자릿수(`n`)까지 지정한 문자(`c`)로 채움|
|`RTRIM(s1, s2)`|대상 문자열의 오른쪽부터 지정한 문자들을 제거|
|`SUBSTR(s, n, k)`|대상 문자열(`s`)에서 `n`번째 위치부터 `k`개의 문자를 잘라서 반환|
|`TRIM(c FROM s)`|대상 문자열(`s`)에서 지정한 문자(`c`)를 제거 (default : 공백 문자)|  
|`UPPER(s)`|대상 문자열을 모두 대문자로 변환|
|`INSTR(s1, s2, n, k)`|대상 문자열(`s1`)에서 지정한 문자열(`s2`)이 `n`번째 위치부터 `k`번째로 나타나는 위치 반환 (default : `n=1`, `k=1`)|
|`LENGTH(s)`|대상 문자열의 길이(글자 수) 반환|

- Example 4 - 도서 제목에 `Ronaldo`가 포함된 도서를 `Messi`로 변경한 후 도서 목록 출력  

```sql
SELECT bookid, REPLACE(bookname, 'Ronaldo', 'Messi') bookname, publisher, price
FROM Book;
```

- Example 5 - 글자의 수를 세어주는 함수 (단위가 byte가 아닌 문자 단위. byte 단위는 `LENGTHB` 함수 사용)

```sql
SELECT bookname "제목", LENGTH(bookname) "글자수", LENGTHB(bookname) "바이트수"
FROM Book
WHERE publisher = "Real Madrid";
```

- Example 6 - 고객 중에서 같은 성을 가진 사람이 몇 명이나 되는지 성별 인원수

```sql
SELECT SUBSTR(name, 1, 1) "성", COUNT(*) "인원"
FROM Customer
GROUP BY SUBSTR(name, 1, 1);
```

<br>

- 날짜 함수

|함수|설명|
|---|---|
|`TO_DATE(char, datetime)`|문자형(`char`)데이터를 `DATE`형으로 변환(`yyyy-mm-dd` 형식)|
|`TO_CHAR(date, datetime)`|`DATE`형 데이터를 문자열(`VARCHAR2`)로 변환(`yyyy-mm-dd` 형식)|
|`ADD_MONTHS(date, 숫자)`|날짜에 지정한 달을 더해 `DATE`형으로 반환(`1`: 다음달, `-1`: 이전달)|
|`LAST_DAY(date)`|날짜에 달의 마지막 날을 `DATE`형으로 반환|
|`SYSDATE`|DBMS 시스템상의 당일 날짜를 `DATE`형으로 반환하는 인자가 없는 함수|

- `datatime`의 주요 인자

|인자|설명|
|---|---|
|`d`|요일 순서(1~7)|
|`day`|요일(월~일)|
|`dy`|요일의 약자(월~일)|
|`dd`|한 달 중 날짜(1~31)|
|`ddd`|한 해 중 날짜(1~366)|
|`hh`, `hh12`|12시간제 시간(1~12)|
|`hh24`|24시간제 시간(0~23)|
|`mi`|분(0~59)|
|`mm`|월(1~12)|
|`mon`|월 약어(Jan~Dec)|
|`month`|월(January~December)|
|`ss`|초(0~59)|
|`yyyy`|년(4자리)|
|`yyy`, `yy`, `y`|연도의 마지막 `3`, `2`, `1`자리|

- Example 7 - 주문일로부터 `10`일 후 매출을 확정할 때, 각 주문의 확정일자  

```sql
SELECT orderid "주문번호", orderdate "주문일", orderdate+10 "확정일"
FROM Orders;
```

- Example 8 - `2025년 9월 29일`에 주문받은 도서의 주문번호, 주문일, 고객번호, 도서번호를 출력. 단, 주문일은 `yyyy-mm-dd` 형식으로 출력  

```sql
SELECT orderid "주문번호", TO_CHAR(orderdate, 'yyyy-mm-dd') "주문일", custid "고객번호", bookid "도서번호"
FROM Orders
WHERE orderdate = TO_DATE('20250929', 'yyyymmdd');
```

![to_date][def3]  

- Example 9 - DBMS 서버에 설정된 현재 시간과 오늘 날짜 확인  

```sql
SELECT SYSDATE, TO_CHAR(SYSDATE, 'yyyy-mm-dd dy hh24:mi:ss') "SYSDATE_1"
FROM Dual;
```

<br>

- `NULL`값 : 아직 지정되지 않은 값 ★
  - `NULL`값은 `0`, `' '`(공백), `''`(빈 문자열)과 다름
  - `NULL`값은 비교 연산자(`=`, `!=`, `<`, `>`, `<=`, `>=`)로 비교할 수 없음
  - `NULL`값의 연산을 수행하면 결과 역시 `NULL`

- 집계 함수를 사용할 때 주의할 점
  - `NULL` + `숫자` 연산의 결과는 `NULL`
  - 집계 함수 계산 시 `NULL`이 포함된 행은 집계에서 제외 (단, `COUNT(*)`는 모두 `NULL`이 아닌 이상 행의 개수를 셈)
  - 해당되는 행이 하나도 없을 경우 `SUM`, `AVG` 함수의 결과는 `NULL`, `COUNT` 함수의 결과는 `0`  

- `NULL` 값을 확인하는 방법 - `IS NULL`, `IS NOT NULL`  

```sql
SELECT *
FROM Mybook
WHERE price IS NULL;
```

- `NVL` : `NULL` 값을 다른 값으로 대체하는 함수

- Example 10 - 이름과 전화번호가 포함된 고객목록 출력. 단, 전화번호가 없는 고객은 `연락처 없음`으로 표시  

```sql
SELECT name "이름", NVL(phone, '연락처 없음') "전화번호"
FROM Customer;
```

<br>

- `ROWNUM` : Oracle에서 내부적으로 생성되는 가상 column으로, SQL 조회 결과의 순번을 나타냄
  - 내장 함수는 아니지만, 자주 사용됨
  - 자료를 일부분만 확인하여 처리할 때 유용

- Example 11 - 고객 목록에서 고객번호, 이름, 전화번호를 앞의 두 명만 출력  

```sql
SELECT ROWNUM "순번", custid, name, phone
FROM Customer
WHERE ROWNUM <= 2;
```

<br>

### 2. 부속 질의
- 부속 질의(subquery) : 하나의 SQL 문 안에 다른 SQL 문이 중첩된(nested) 질의
  - 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용
  - 보통 데이터가 대량일 때 데이터를 모두 합쳐서 연산하는 조인보다, 필요한 데이터만 찾아서 공급하는 부속 질의가 더 효율적
  - 주 질의(main query)와 부속 질의(subquery)로 구성  
  ![subquery][def4]  

- 부속 질의의 종류

|명칭|위치|영문 및 동의어|설명|
|---|---|---|---|
|중첩 질의|`WHERE` 절|Nested Subquery<br>Predicate Subquery|`WHERE` 절에 술어와 함께 사용되며, 결과를 한정시키기 위해 사용. 상관 or 비상관 형태|
|스칼라 부속 질의|`SELECT` 절|Scalar Subquery|`SELECT`, `UPDATE SET` 절에 주로 사용되며, 단일 값을 반환|
|인라인 뷰|`FROM` 절|Inline View|`FROM` 절에서 결과를 뷰(view) 형태로 반환|

<br>

- 중첩 질의 연산자의 종류

|술어|연산자|반환 행|반환 열|상관|
|---|---|---|---|---|
|비교|`=`, `<>`, `<`, `>`, `<=`, `>=`|단일|단일|가능|
|집합|`IN`, `NOT IN`|다중|다중|가능|
|한정|`ALL`, `SOME(ANY)`|다중|단일|가능|
|존재|`EXISTS`, `NOT EXISTS`|다중|다중|필수|

- Example 12 - 평균 주문금액 이하의 주문에 대하여 주문번호와 금액 출력  

```sql
SELECT orderid, saleprice
FROM Orders
WHERE saleprice <= (SELECT AVG(saleprice) FROM Orders);
```

- Example 13 - 각 고객의 평균 주문금액보다 큰 금액의 주문 내역에 대해서 주문번호, 고객번호, 금액 출력  

```sql
SELECT orderid, custid, saleprice
FROM Orders md
WHERE saleprice > (SELECT AVG(saleprice) FROM Orders so WHERE md.custid = so.custid);
```

- Example 14 - 포르투갈에 거주하는 고객에게 판매한 도서의 총판매액

```sql
SELECT SUM(saleprice) "total"
FROM Orders
WHERE custid IN (SELECT custid FROM Customer WHERE address LIKE '%Portugal%');
```

- Example 15 - `3`번 고객이 주문한 도서의 최고 금액보다 더 비싼 도서를 구입한 주문의 주문번호와 금액

```sql
SELECT orderid, saleprice
FROM Orders
WHERE saleprice > ALL (SELECT saleprice FROM Orders WHERE custid = 3);
```

- Example 16 - `EXISTS` 연산자로 포르투갈에 거주하는 고객에게 판매한 도서의 총판매액

```sql
SELECT SUM(saleprice) "total"
FROM Orders od
WHERE EXISTS (SELECT * FROM Customer cs WHERE address LIKE '%Portugal%' AND od.custid = cs.custid);
```

<br>

- Example 17 - 고객별 판매액 (고객이름과 고객별 판매액 출력)

```sql
SELECT (SELECT name FROM Customer cs WHERE cs.custid = od.custid) "name", SUM(saleprice) "total"
FROM Orders od
GROUP BY od.custid;
```

![subquery_example17][def5]  

- Example 18 - `Orders` 테이블에서 각 주문에 맞는 도서이름 출력

```sql
ALTER TABLE Orders ADD bookname VARCHAR2(40);
UPDATE Orders
SET bookname = (SELECT bookname FROM Book WHERE Book.bookid = Orders.bookid);
```

<br>

- Example 19 - 고객 번호가 `2` 이하인 고객의 판매액

```sql
SELECT cs.name, SUM(od.saleprice) "total"
FROM (SELECT custid, name FROM Customer WHERE custid <= 2) cs, Orders od
WHERE cs.custid = od.custid
GROUP BY cs.name;
```

![subquery_example19][def6]  

<br>

### 3. 뷰
- 뷰(view) : 하나 이상의 테이블을 합하여 만든 가상의 테이블
  - 장점
    - 편리성(& 재사용성) : 자주 사용되는 복잡한 질의를 미리 정의해 놓고 필요할 때마다 사용할 수 있음
    - 보안성 : 각 사용자별로 필요한 데이터만 선별하여 보여줄 수 있음. 중요한 질의의 경우 암호화 가능
    - 논리적 독립성 : 개념 스키마의 데이터베이스 구조가 변하여도 외부 스키마에 영향 X

  - 특징
    - (1) 원본 데이터 값에 따라 함께 자동 갱신
    - (2) 독립적인 인덱스 생성이 어려움
    - (3) 삽입, 삭제, 갱신 연산에 많은 제약이 따름  

- 뷰 생성  
![create_view][def7]  

- 뷰 시각화  
![view_example][def8]  

- 기본 문법  

```sql
CREATE VIEW 뷰이름 [(열 이름 [, ... n])]
AS <SELECT 문>
```

- `Book` 테이블에서 `축구`라는 문구가 포함된 자료만 보여주는 명령  

```sql
SELECT *
FROM Book
WHERE bookname LIKE '%축구%';
```

- 위 `SELECT`문을 이용해 작성한 뷰 정의문

```sql
CREATE VIEW vw_Book
AS SELECT *
   FROM Book
   WHERE bookname LIKE '%축구%';
```

<br>

- Example 20 - 주소에 `Portugal`을 포함하는 고객들로 구성된 뷰를 만들고 조회. 뷰의 이름은 `vw_Customer`  

```sql
CREATE VIEW vw_Customer
AS SELECT *
   FROM Customer
   WHERE address LIKE '%Portugal%';
```

```sql
SELECT *
FROM vw_Customer;
```

- Example 21 - `Orders` 테이블에 고객이름과 도서이름을바로 확인할 수 있는 뷰를 만들고, `Ronaldo` 고객이 구입한 도서의 주문번호, 도서이름, 주문액 출력.  

```sql
CREATE VIEW vw_Orders (orderid, custid, name, bookid, bookname, saleprice, orderdate)  
AS SELECT od.orderid, od.custid, cs.name, od.bookid, bk.bookname, od.saleprice, od.orderdate
   FROM Orders od, Customer cs, Book bk
   WHERE od.custid = cs.custid AND od.bookid = bk.bookid;
```

```sql
SELECT orderid, bookname, saleprice
FROM vw_Orders
WHERE name = 'Ronaldo';
```

<br>

- 뷰의 수정  

```sql
CREATE OR REPLACE VIEW 뷰이름 [(열 이름 [, ... n])]
AS <SELECT 문>
```

- Example 22 - `vw_Customer` 뷰를 수정하여 주소에 `Argentina`를 포함하는 고객으로 구성된 뷰로 변경  

```sql
CREATE OR REPLACE VIEW vw_Customer (custid, name, address)
AS SELECT custid, name, address
   FROM Customer
   WHERE address LIKE '%Argentina%';
```

```sql
SELECT *
FROM vw_Customer;
```

<br>

- 뷰의 삭제  

```sql
DROP VIEW 뷰이름 [, ... n];
```

- Example 23 - `vw_Customer` 뷰 삭제  

```sql
DROP VIEW vw_Customer;
```

```sql
SELECT *
FROM vw_Customer;
-- 오류 발생
```

- 뷰는 원본 테이블에 영향을 주지 않아, 삭제가 간단함

<br>

### 4. 인덱스
- 데이터의 물리적 저장  
![data_storage](TODO)  
  - 데이터 파일
    - 운영체제 상에 물리적으로 존재
    - 사용자 데이터와 개체를 저장
    - 테이블과 인덱스로 구성
  - 컨트롤 파일
    - 다른 파일들의 위치 정보를 저장
    - 데이터베이스 구조의 변경사항이 있을 때 자동으로 갱신
    - 오라클 DB의 마운트, 오픈의 필수 파일
    - 복구 시 동기화 정보 저장
  - 온라인 리두(redo) 로그 파일
    - 데이터의 모든 변경사항을 기록
    - 데이터베이스 복구에 사용되는 로그 정보 저장
    - 최소 두 개의 온라인 리두 로그 파일 그룹을 가짐

<br>

- 인덱스의 필요성
  - query 시 data block의 읽는 횟수를 최소화해야 함.
  - disk에 있는 데이터는 memory에 있는 데이터에 비하여 읽어들이는 속도가 `10000`배 이상 느림
  ![disk_vs_memory_1](TODO)  
  ![disk_vs_memory_2](TODO)  

- 인덱스(index, 색인) : 데이터를 쉽고 빠르게 찾을 수 있도록 만든 데이터 구조  
![b_tree](TODO)  
  - 위와 같은 구조를 B-tree라고 함  
  ![b_tree_example](TODO)  
  - 하나의 리프 노드가 하나의 데이터에 대응

- 인덱스의 특징
  - 인덱스는 테이블에서 한 개 이상의 속성을 이용하여 생성
  - 빠른 검색과 함께 효율적인 레코드 접근이 가능
  - 순서대로 정렬된 속성과 데이터의 위치만 저장하므로, 테이블보다 작은 공간을 차지
  - 저장된 값들은 테이블의 부분 집합
  - 일반적으로 B-tree 형태의 구조
  - 데이터의 수정, 삭제 등의 변경이 발생하면 인덱스의 재구성이 필요

<br>

- 오라클 인덱스는 B-tree 변형 구조를 사용하며, 명칭은 B-tree로 동일  
![b_tree_oracle](TODO)  

<br>

- 인덱스 생성  
  - 고려사항
    - 인덱스는 `WHERE` 절에 자주 사용되는 속성으로
    - 인덱스는 `JOIN`에 자주 사용되는 속성으로
    - 단일 테이블에 인덱스가 많으면 오히려 속도가 느려질 수 있음 (테이블 당 4~5개 권장)
    - 속성이 가공되는 경우 사용하지 않음
    - 속성의 선택도가 낮을 때 유리 (속성의 모든 값이 다른 경우)

  - 문법  

  ```sql
  CREATE [REVERSE] [UNIQUE] INDEX [인덱스이름]
  ON 테이블이름 (열 [ASC | DESC] [ {, 열 [ASC | DESC]} ... ])[;]
  ```

  - Example 24 - `Book` 테이블의 `bookname` 열을 대상으로 비 클러스터 인덱스 `ix_Book` 생성

  ```sql
  CREATE INDEX ix_Book ON Book (bookname);
  ```

  - Example 25 - `Book` 테이블의 `publisher`, `price` 열을 대상으로 인덱스 `ix_Book2` 생성

  ```sql
  CREATE INDEX ix_Book2 ON Book (publisher, price);
  ```

<br>

- 인덱스의 재구성
  - 문법

  ```sql
  ALTER [REVERSE] [UNIQUE] INDEX 인덱스이름
  [ON {ONLY} 테이블이름 (열 이름 [{, 열이름 } ...]) REBUILD][;]
  ```

  - Example 26 - 인덱스 `ix_Book`을 재생성

  ```sql
  ALTER INDEX ix_Book REBUILD;
  ```

  - Example 27 - 인덱스 `ix_book`을 삭제  

  ```sql
  DROP INDEX ix_Book;
  ```

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 최황규 교수님의 데이터베이스 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/hzLp1XM.png
[def2]: https://i.imgur.com/JqLsWOo.png
[def3]: https://i.imgur.com/BKJ0tfX.png
[def4]: https://i.imgur.com/QwRtyjF.png
[def5]: https://i.imgur.com/lFIhWgt.png
[def6]: https://i.imgur.com/czPf7Gk.png
[def7]: https://i.imgur.com/ABEHHk5.png
[def8]: https://i.imgur.com/Zr8mt9I.png