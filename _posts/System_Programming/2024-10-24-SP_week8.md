---
layout: post
title: "[시스템 프로그래밍] 8주차 - Machine Level Programming (3)"
excerpt: "Procedures"

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-10-21
last_modified_at: 2024-10-21
---
## Procedures
- **Procedures**의 메커니즘
  - **Passing control**
    - procedure code의 시작점으로 control이 넘어간다.
    - return point에서 다시 돌아간다.  
  - **Passing data**
    - Procedure arguments
    - Return value
  - **Memory management**
    - procedure 실행 도중 할당 (local variables)
    - return에서 해제(deallocation)

- 이 모든 메커니즘들은 기계어 명령어로 구현되어 있다.  
- x86-64의 프로시저 구현은 오직 이 메커니즘들로 이루어져 있다.  

### 1. Stack Structure
- 메모리 영역은 stack discipline으로 관리된다.   
- 낮은 주소를 향해 성장한다.
- `%rsp` : stack pointer register
  - 스택의 가장 낮은 주소를 가진다.  
  - stack의 top element를 가리킨다.  
![stack_pointer](TODO)  

- `pushq Src` : Src를 스택에 push한다.  
  - `%rsp`를 8 만큼 감소시킨 후,  
  operand를 `%rsp`가 가리키는 주소에 저장한다.  

- `popq Dest` : 스택의 top element를 pop하여 Dest에 저장한다.  
  - `%rsp`가 가리키는 주소의 operand를 Dest에 저장한 후,  
  `%rsp`를 8 만큼 증가시킨다.  

  <br>

### 2. Calling Conventions
#### [1] Passing Control
- Code Examples  

```c
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

- 두 함수는 아래와 같이 컴파일 된다.  
![multstore](TODO) ![mult2](TODO)  

- 위 어셈블리 코드를 잘 보면,  
함수를 호출할 때는 `callq` 명령어와 함께 주소를,  
함수를 끝낼 때는 `retq` 명령어를 사용하는 것을 볼 수 있다.  

<br>

- Procedure Control Flow : 프로시저 call과 return을 위하여 스렉을 사용한다.  
  - Procedure call : `call label`
    - 스택에 return address를 push
    - `label`로 jump
  - Return address
    - 호출 직후의 다음 명령어 주소
  - Procedure return : `ret`
    - 스택에서 address를 pop
    - 해당 주소로 jump

![control_flow_example_1](TODO)
![control_flow_example_2](TODO)
![control_flow_example_3](TODO)
![control_flow_example_4](TODO)

<br>

#### [2] Passing Data
- 프로시저에서 데이터의 흐름은 레지스터로 이루어지기도 하고, 스택으로 이루어지기도 한다.  
  - 레지스터 사용 : 6개 이하의 argument  
    - `%rdi`, `%rsi`, `%rdx`, `%rcx`, `%r8`, `%r9`  
    - return value : `%rax`  
    ![register_usage](TODO)
  - 스택 사용 : 6개가 넘는 argument  
    - 필요할 때(6개가 넘어갈 때)만 스택 공간을 할당한다.  

    <br>

- Data Flow Examples  

```c
void multstore(long x, long y, long *dest) {
    long t = mult2(x, y);
    *dest = t;
}
long mult2(long a, long b) {
    long s = a * b;
    return s;
}
```

- In assembly,  
![data_flow_example](TODO)  

<br>

#### [3] Managing local data
#### Stack based languages
- 재귀를 지원하는 언어  
  - e.g., C, Pascal, Java, ...
  - 코드가 "Reentrant" 해야한다.  
    - 하나의 procedure의 연속된 여러 인스턴스 생성
  - 각 인스턴스 생성 시 상태를 저장할 공간이 필요하다.  
    - Arguments
    - Local variables
    - Return pointer  

- Stack discipline
  - TODO
    - TODO
  - TODO

- Stack은 Frames에 할당된다.  
  - TODO  

<br>

- Call Chain Example  
![call_chain_example](TODO)  

<br>

- Stack Frames  
![stack_frames](TODO)  
  - Contents
    - Return information
    - Local Storage (필요 시)
    - Temporary space (필요 시)  

  - Management
    - TODO

    <br>

- Stack Frame Example
![stack_frame_example](TODO)  

<br>

#### x86-64/Linux Stack Frame
![x86-64_stack_frame](TODO)  
- Current Stack Frame ("Top" to Bottom)
  - TODO

- Caller Stack Frame
  - Return address
    - `call` 명령어에 의해 pushed 되었음
    - 호출을 위한 arguments  

- Example
  - TODO

<br>

#### Register Saving Conventions
- 프로시저 `yoo`가 `who`를 호출하면,  
  - `yoo` : **caller**
  - `who` : **callee**

- 레지스터가 temporary storage로서 사용될 수 있을까?  

- Conventions
  - **Caller Saved**
    - Caller가 호출 전에 미리 temporary value들을 자신의 frame에 저장한다.
  - **Callee Saved**
    - Callee가 사용 전에 temporary value들을 자신의 frame에 저장한다.
    - Caller에게 return하기 전에 복원한다.  

    <br>

- x86-64 Linux Register Usage  
![x86-64_register_usage_1](TODO)
  - `%rax`
    - return value
    - Caller saved
    - 프로시저에 의해 수정될 수 있음

  TODO from here

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>