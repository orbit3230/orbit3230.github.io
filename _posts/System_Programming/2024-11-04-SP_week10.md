---
layout: post
title: "[시스템 프로그래밍] 10주차 - Machine Level Programming (4)"
excerpt: "Array Allocation, Array Example, Multidimensional Array, Nested Array, Multi-Level Array, Structure Representation, Generation Pointer to Structure Memeber, Structures & Alignment, Arrays of Structures, Floating Point, Programming with SSE3"

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-11-04
last_modified_at: 2024-11-07
---
## Arrays
### 1. Array Allocation  
- Basic Principle  
`T A[L]`
  - `T` : 배열의 원소 타입
  - `L` : 배열의 길이
  - 메모리에서 `L * sizeof(T)` 만큼의 연속된 공간을 할당한다.  
![array_allocation][def]  

  - 식별자 `A`는 배열의 `0`번째 원소를 가리키는 포인터로서 사용될 수 있다.  
  (Type `T*`)  

  ![array_val][def2]

  |Reference|Type|Value|
  |:---:|:---:|:---:|
  |`val[4]`|`int`|`3`|
  |`val`|`int*`|`x`|
  |`val+1`|`int*`|`x + 4`|
  |`&val[2]`|`int*`|`x + 8`|
  |`val[5]`|`int`|??|
  |`*(val+1)`|`int`|`5`|
  |`val + i`|`int*`|`x + 4*i`|  

<br>

### 2. Array Example

```c
#define ZLEN 5
typedef int zip_dig[ZLEN];

zip_dig knu = {1, 5, 2, 1, 3};
zip_dig mit = {0, 2, 1, 3, 9};
zip_dig ucb = {9, 4, 7, 2, 0};
```

![array_example][def3]  

- `zip_dig knu`라는 선언은 `int knu[5]`와 동일하다.  
- Example array가 연속적인 `20`byte blocks에 할당되었다.  

<br>

#### [1] Array Accessing Example

```c
int get_digit(zip_dig z, int digit) {
    return z[digit];
}   
```

- 위와 같은 Array Access는 하나의 `movl` 명령어로 처리할 수 있다.  

```s
    # %rdi = z
    # %rsi = digit
movl    (%rdi, %rsi, 4), %eax  # z[digit]
```

- `z[digit]`는 `z + 4*digit`을 의미한다.

  - 따라서, `%rdi + 4*%rsi`를 memory reference `(%rdi, %rsi, 4)`로 표현했다.  

  <br>

#### [2] Array Loop Example

```c
void zincr(zip_dig z) {
    size_t i;
    for(i = 0 ; i < ZLEN ; i++) {
        z[i]++;
    }
}
```

- 위와 같은 Array Loop는 아래와 같이 컴파일 된다.  
![array_loop][def4]  

<br>

### 2. Array Example - Multidimensional(Nested) 
- 선언  
`T A[R][C]`
  - data type `T`에 대한 2D 배열
  - `R` : 행의 수, `C` : 열의 수  

- 배열 크기  
`R * C * sizeof(T)`  

- Arrangement  
  - Row-Major Ordering  
  ![row_major][def5]  

  <br>

```c
#define PCOUNT 4
zip_dig pgh[pcount] =
    {% raw %}{{1, 5, 2, 0, 6},
     {1, 5, 2, 1, 3},
     {1, 5, 2, 1, 7},
     {1, 5, 2, 2, 1}}{% endraw %};
```

- 위 `pgh` 배열은 아래와 같이 메모리 상에 할당된다.  
![pgh_array][def6]  

- `zip_dig pgh[4]`는 `int pgh[4][5]`와 동일하다.  
  - `pgh` : 연속적으로 할당되는 4 elements 배열
  - 그리고 각 element는 5 `int`'s 배열

<br>

#### [1] Nested Array Row Access
- Row Vectors
  - `A[i]` : `C` elements 배열  
  - 각 `T` 타입 원소는 `K` bytes를 차지한다.
  - Starting Address : `A + i * (C * K)`  
  ![nested_array_row][def7]  

<br>

```c
int *get_pgh_zip(int index) {
    return pgh[index];
}
```

- 위와 같은 Row Access는 `leaq` 명령어로 처리할 수 있다.  

```s
    # %rdi = index
leaq    (%rdi, %rdi, 4), %rax  # 5 * index
leaq    pgh(,%rax, 4), %rax    # pgh + (20*index)
```

- `pgh[index]`는 5개의 `int` 배열이다.  
  - 따라서 Starting address는 `pgh + 20*index`이다.  

  - 이를 machine level 에서는 `pgh + 4*(index+4*index)`로 계산한 것이다.  

  <br>

#### [2] Nested Array Element Access
- Array Elements
  - `A[i][j]`가 `T` 타입의 원소이며 `K` bytes를 차지한다면,  
  - Address : `A + i * (C * K) + j * K` = `A + (i * C + j) * K`  
  ![nested_array_element][def8]

<br>

```c
int get_pgh_digit(int index, int dig) {
    return pgh[index][dig];
}
```

- 위와 같은 Element Access는 `leaq`, `addl`, `movl` 명령어로 처리할 수 있다.  

```s
leaq    (%rdi, %rdi, 4), %rax  # 5 * index
addl    %rax, %rsi              # 5 * index + dig
movl    pgh(,%rsi, 4), %eax     # M[pgh + 4*(5*index + dig)]
```

- `pgh[index][dig]`는 `int`.
- Address : `pgh + 20*index + 4*dig`  
= `pgh + 4*(5*index + dig)`  

  <br>

### 3. Array Example - Multi-Level

```c
zip_dig knu = {1, 5, 2, 1, 3};
zip_dig mit = {0, 2, 1, 3, 9};
zip_dig ucb = {9, 4, 7, 2, 0};
```

```c
#define UCOUNT 3
int *univ[Ucount] = {mit, knu, ucb};
```

- `univ` 변수는 `3` elements 배열.
- 각 element는 `int*` 타입의 포인터. (8 bytes)
- 각 포인터는 `int`'s 배열을 가리킨다.  

![multi_level_array][def9]

#### [1] Multi-Level Array Element Access

```c
int get_univ_digit(size_t index, size_t digit) {
    return univ[index][digit];
}
```

- 위와 같은 Element Access는 `salq`, `addq`, `movl` 명령어로 처리할 수 있다.  

```s
salq    $2, %rdi             # 4*digit
addq   univ(,%rdi, 8), %rsi # p = univ[index] + 4*digit
movl   (%rsi), %eax         # return *p
ret
```

- Element Access : `Mem[Mem[univ + 8*index] + 4*digit]`  
- 반드시 두 번의 메모리 참조가 필요하다.  
  - first : row array에 대한 포인터 get
  - second : 해당 row array의 element get

  <br>

#### [2] Array Element Access [Nested vs. Multi-Level]  
![nested_vs_multi][def10]  

- 두 가지 방법은 C에서는 비슷해 보이지만,  
address computation은 매우 다르다.  

  - Nested Array : `Mem[pgh + 20*index + 4*digit]`
  - Multi-Level Array : `Mem[Mem[univ + 8*index] + 4*digit]`

<br>

## Structures
### 1. Structure Representation  
- Structure는 메모리 블록으로 나타낸다.  
  - 각 필드를 모두 담을 만큼 충분히 크다.  
- 필드는 선언한 **순서대로** 메모리에 할당된다.  
  - 비록 다른 ordering이 더 컴팩트할 수 있더라도.  
- 전반적인 크기와 필드의 위치는 컴파일러가 결정한다.  

<br>

### 2. Generation Pointer to Structure Memeber
- 아래와 같은 구조체가 선언되었다.  

```c
struct rec {
  int a[4];
  size_t i;
  struct rec *next;
}
```

![struct](TODO)  

#### [1] Structure Member Access
- 첫 번째 array 필드의 특정 값을 읽는 함수가 있다고 생각해보자.  

```c
int *get_ap(struct rec *r, size_t idx) {
    return &r->a[idx];
}
```

- 위와 같은 함수는 아래와 같이 컴파일 된다.  

```s
    leaq    (%rdi, %rsi, 4), %rax  # r->a[idx]
    ret
```

- `%rdi` : `r`
- `%rsi` : `idx`
<br>
- 각 member의 offset은 컴파일 시간에 결정된다.  
- `r + 4*idx`로 계산되었다.  

<br>

#### [2] Following Linked List
- 다음 구조체의 `next` 필드를 따라가는 함수가 있다고 생각해보자.  

```c
void set_val(struct rec *r, int val) {
    while(r) {
      int i = r->i;
      r->a[i] = val;
      r = r->next;
    }
}
```

- 위와 같은 함수는 아래와 같이 컴파일 된다.  

```s
.L11:
    movslq  16(%rdi), %rax            # i = M[r + 16]
    movl    %esi, (%rdi, %rax, 4)   # M[r + 4*i] = val
    movq    20(%rdi), %rdi              # r = M[r + 20]
    testq   %rdi, %rdi                        # Test r
    jne     .L11
```

- `%rdi` : `r`
- `%rsi` : `val`  

<br>

### 3. Structures & Alignment

```c
struct S1 {
    char c;
    int i[2];
    double v;
} *p;
```

- Unaligned Data  
![unaligned_data](TODO)
  - 이는 다소 비효율적이다.  
  - 성능의 하락을 초래할 수 있다.  

- Aligned Data  
![aligned_data](TODO)
  - Primitive data type이 `K` bytes를 요구하는 경우,  
  - 주소는 반드시 `K`의 배수여야 한다.  
  - 특정 Architecture에서는 Alignment를 강제한다. (must do)  

<br>

- x86-64는 Alignment를 권고한다.  
- Aligning Data의 장점
  - 4 or 8 Bytes 단위로 메모리 접근  
    - TODO
- Compiler
  - 필드들의 correct alignment를 보장하기 위하여 gap을 삽입한다.  

<br>

- Special Cases of Alignment (x86-64)  
  - TODO  

<br>

- Satisfying Alignment with Structures
  - Structure 내 필드의 순서에 따라 alignment가 다르게 적용된다.  
  - 되도록이면 크기가 큰 필드를 앞에 두는 것이 좋다.  

```c
struct S1 {
  char c;
  int i[2];
  double v;
} *p;
```

![s1_alignment](TODO)  

```c
struct S2 {
  double v;
  int i[2];
  char c;
} *p;
```  

![s2_alignment](TODO)  

<br>

#### Saving Space
- 실제로 필드의 순서에 따라 alignment가 다르게 적용되며,  
구조체가 차지하는 크기가 달라질 수도 있다.  

```c
struct S4 {
  char c;
  int i;
  char d;
} *p;
```

```c
struct S5 {
  int i;
  char c;
  char d;
} *p;
```  

![s4_s5_alignment](TODO)  

<br>

### 4. Arrays of Structures  

```c
struct S2 {
  double v;
  int i[2];
  char c;
} a[10];
```

- Structure 전체의 길이는 `K`의 배수.
- 모든 element에 대하여 alignment가 보장된다.  
![array_of_struct](TODO)  

#### Accessing Array Elements

```c
struct S3 {
  short i;
  float v;
  short j;
} a[10];
```

![array_of_struct2](TODO)  

- 각 array offset은 `12`*`idx`로 계산된다.  
  - `sizeof(S3) = 12`, including alignment spacers
- Element `j`는 구조체 내에서 `8` bytes offset에 위치한다.  
- 어셈블러는 `a + 12*idx + 8`로 계산한다.  
  - linking 과정에서 resolve된다.  

```c
short get_j(int idx) {
  return a[idx].j;
}
```

- 위와 같은 함수는 아래와 같이 컴파일 된다.  

```s
    leaq    (%rdi, %rdi, 2), %rax  # 3*idx
    movzwl  a+8(, %rax, 4), %eax  # a[idx].j
```

<br>

## Floating Point
### 1. Programming with SSE3  
- XMM Registers
  - 16 total, each 16 bytes
  ![xmm_registers](TODO)  

<br>

- Scalar SIMD Operations  
  - Scalar Operations : Single Precision  
  `addss %xmm0, %xmm1`  
  ![scalar_single](TODO)  

  - SIMD Operations : Single Precision  
  `addps %xmm0, %xmm1`  
  ![simd](TODO)  

  - Scalar Operations : Double Precision  
  `addsd %xmm0, %xmm1`  
  ![scalar_double](TODO)  

  <br>

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/gRSR5R8.png
[def2]: https://i.imgur.com/GTOn5Rd.png
[def3]: https://i.imgur.com/dNfqoOx.png
[def4]: https://i.imgur.com/eyGTc6d.png
[def5]: https://i.imgur.com/jVpPpbs.png
[def6]: https://i.imgur.com/U2fypf8.png
[def7]: https://i.imgur.com/zCFtWyA.png
[def8]: https://i.imgur.com/WG1i8By.png
[def9]: https://i.imgur.com/lZRWNjq.png
[def10]: https://i.imgur.com/URscIab.png