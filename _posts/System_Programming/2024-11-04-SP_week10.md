---
layout: post
title: "[시스템 프로그래밍] 10주차 - Machine Level Programming (4)"
excerpt: ""

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-11-04
last_modified_at: 2024-11-04
---
## Arrays
### 1. Array Allocation  
- Basic Principle  
`T A[L]`
  - `T` : 배열의 원소 타입
  - `L` : 배열의 길이
  - 메모리에서 `L * sizeof(T)` 만큼의 연속된 공간을 할당한다.  
![array_allocation](TODO)  

  - 식별자 `A`는 배열의 `0`번째 원소를 가리키는 포인터로서 사용될 수 있다.  
  (Type `T*`)  

  ![array_val](TODO)

  |Reference|Type|Value|
  |:---:|:---:|:---:|
  |`val[4]`|`int`|`3`|
  |`val`|`int*`|`x`|
  |`val+1`|`int*`|`x + 4`|
  |`&val[2]`|`int*`|`x + 8`|
  |`val[5]`|`int`|??|
  |`*(val+1)`|`int`|`5`|
  |`val + i`|`int*`|`x + 4*i`|  

<br>

### 2. Array Example

```c
#define ZLEN 5
typedef int zip_dig[ZLEN];

zip_dig knu = {1, 5, 2, 1, 3};
zip_dig mit = {0, 2, 1, 3, 9};
zip_dig ucb = {9, 4, 7, 2, 0};
```

![array_example](TODO)  

- `zip_dig knu`라는 선언은 `int knu[5]`와 동일하다.  
- Example array가 연속적인 `20`byte blocks에 할당되었다.  

<br>

#### [1] Array Accessing Example

```c
int get_digit(zip_dig z, int digit) {
    return z[digit];
}   
```

- 위와 같은 Array Access는 하나의 `movl` 명령어로 처리할 수 있다.  

```s
    # %rdi = z
    # %rsi = digit
movl    (%rdi, %rsi, 4), %eax  # z[digit]
```

- `z[digit]`는 `z + 4*digit`을 의미한다.

  - 따라서, `%rdi + 4*%rsi`를 memory reference `(%rdi, %rsi, 4)`로 표현했다.  

  <br>

#### [2] Array Loop Example

```c
void zincr(zip_dig z) {
    size_t i;
    for(i = 0 ; i < ZLEN ; i++) {
        z[i]++;
    }
}
```

- 위와 같은 Array Loop는 아래와 같이 컴파일 된다.  
![array_loop](TODO)  

<br>

### 2. Array Example - Multidimensional  
- 선언  
`T A[R][C]`
  - data type `T`에 대한 2D 배열
  - `R` : 행의 수, `C` : 열의 수  

- 배열 크기  
`R * C * sizeof(T)`  

- Arrangement  
  - Row-Major Ordering  
  ![row_major](TODO)  

  <br>

```c
#define PCOUNT 4
zip_dig pgh[pcount] =
    {{1, 5, 2, 0, 6},
     {1, 5, 2, 1, 3},
     {1, 5, 2, 1, 7},
     {1, 5, 2, 2, 1}};
```

- 위 `pgh` 배열은 아래와 같이 메모리 상에 할당된다.  
![pgh_array](TODO)  

- `zip_dig pgh[4]`는 `int pgh[4][5]`와 동일하다.  
  - TODO

<br>

#### [1] Nested Array Row Access
- Row Vectors
  - `A[i]` : `C` elements의 배열  
  - 각 `T` 타입 원소는 `K` bytes를 차지한다.
  - Starting Address : `A + i * (C * K)`  
  ![nested_array_row](TODO)  

<br>

```c
int *get_pgh_zip(int index) {
    return pgh[index];
}
```

- 위와 같은 Row Access는 `leaq` 명령어로 처리할 수 있다.  

```s
    # %rdi = index
leaq    (%rdi, %rdi, 4), %rax  # 5 * index
leaq    pgh(,%rax, 4), %rax    # pgh + (20*index)
```

- `pgh[index]`는 5개의 `int` 배열이다.  
  - 따라서 Starting address는 `pgh + 20*index`이다.  

  - 이는 `pgh + 4*(index+4*index)`로 계산된다.  

  <br>

#### [2] Nested Array Element Access

TODO

<br>

### 3. Array Example - Multi-Level
TODO  

#### [1] Multi-Level Array Element Access

#### [2] Array Element Access [Nested vs. Multi-Level]  

<br>

## Structures
### 1. Structure Representation  
TODO  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>