---
layout: post
title: "[시스템 프로그래밍] 11주차 - Machine Level Programming (5)"
excerpt: ""

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-11-11
last_modified_at: 2024-11-11
---
## Memory Layout
- x86-64 Linux Memory Layout  
![x86_64_Linux_Memory_Layout](TODO)  
  - Stack
    - Runtime stack (8MB limit)
    - e.g., 지역 변수
  - Heap
    - 필요 시 동적으로 할당
    - when call `malloc()`, `calloc()`, `new()`  
  - Data
    - 정적으로 할당된 데이터
    - e.g., 전역 변수, `static` 변수, string 상수  
  - Text / Shared Libraries
    - 실행 가능한 machine instructions
    - read-only  

```c
// TODO
```

<br>

## Buffer Overflow
### 1.  Recall : Memory Referencing Bug Example

```c
typedef struct {
    int a[2];
    double d;
} struct_t;

double fun(int i) {
    volatile struct_t s;
    s.d = 3.14;
    s.a[i] = 1073741824; /* Possibly out of bounds */
    return s.d;
}
```

![memory_referencing_bug](TODO)  
<sub>Result is system specific.</sub>  

- Explanation  
![memory_referencing_bug_explanation](TODO)  
  - TODO

### 2. Buffer Overflow
- 이러한 문제들을 "Buffer Overflow"라고 한다.  
  - 배열을 위해 할당된 메모리 크기를 넘어설 때 발생한다.  

- 왜 큰 문제가 되는가?
  - Buffer Overflow는 보안 취약점에 있어 #1 technical cause이다.  
    - #1 overall cause는 social engineering / user ignorance  

- 가장 흔한 형태
  - Unchecked lengths on string inputs
  - 특히 스택에서 bounded character arrays에서 발생
    - 종종 "stack smashing"이라고도 함  

    <br>

#### String Library Code
TODO

<br>

#### Vulnerable Buffer Code

```c
/* Echo Line */
void  echo() {
    char buf[4];  /* Way too small! */
    gets(buf);
    puts(buf);
}
```

```c
void call_echo() {
    echo();
}
```

![buffer_overflow_input](TODO)  

<br>

- 위 두 함수를 Disassemble 해보자.  
![buffer_overflow_disassemble](TODO)  
  - 위와 같이 우리가 `buf` 배열의 크기는 비록 `4`로 선언했지만,  
  스택 프레임의 크기는 alingment를 위해 `0x18`, 즉 `24` 만큼 할당되었다.  
  - 따라서 현재 스택은 아래와 같은 구조로 되어있다.  
  ![buffer_overflow_stack](TODO)  

- 따라서 입력으로 길이가 `24`인 문자열 까지는 어떻게든 문제가 없었지만,  
길이가 `25`인 문자열 입력부터 `Segmentation Fault`가 발생한 것이다.  
  - 그런데.. TODO  

<br>

#### Code Injection Attacks
TODO

<br>

### 3. Defenses Against Buffer Overflow
#### [1] Avoid Overflow Vulnerabilities in Code

```c
/* Echo Line */
void echo() {
    char buf[4];  /* Way too small! */
    fgets(buf, 4, stdin);
    puts(buf);
}
```

- 예를들어, string lengths 제한을 갖는 라이브러리를 쓰는 것이다.  
  - `gets()` 대신에 `fgets()`를 사용  
  - `strcpy()` 대신에 `strncpy()`를 사용  
  - `%s` conversion specification 없이 `scanf()` 사용하지 않기
    - string을 읽을 때는 `fgets()` 사용
    - 또는 `n`이 적합한 integer일 때 `%ns` 사용  

    <br>

#### [2] System-Level Protections can Help
- Randomized stack offsets
TODO  

- Nonexecutable code segments  
TODO

<br>

#### [3] Stack Canaries can Help
TO BE CONTINUED  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>