---
layout: post
title: "[시스템 프로그래밍] 4주차 - Floating Point"
excerpt: "Floating Point, Fractional binary numbers, IEEE Floating Point, Normalized numbers, Denormalized numbers"

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-09-23
last_modified_at: 2024-09-23
---
## Floating Point
### 1. Fractional binary numbers
- `1011.101`<sub>`2`</sub> -> ???

- 소수점(binary point)이 있을 때 각 bit 별 weight는 아래와 같다.  
![fractional_binary_numbers_weight][def]  

- "binary point" 오른쪽의 비트들은 2의 **fractional powers**를 나타낸다.  
- **rational number를 표현**한다.  
![rational_number][def2]  

<br>

- Examples  
  - `5 3/4`  ->  `101.11`<sub>`2`</sub>
  - `2 7/8`  ->  `10.111`<sub>`2`</sub>
  - `1 7/16`  ->  `1.0111`<sub>`2`</sub>  

- 위 숫자들을 자세히 보면, 아래로 가면서 `/2`를 한 것이다. 그런데 비트 표현을 보니 정확히 오른쪽 shift를 한 것과 같다.  

  - `2`로 나누는 것은 shifting right (unsigned)
  - `2`로 곱하는 것은 shifting left

- `0.1111111...`<sub>`2`</sub>은 `1`에 가깝지만 더 작은 수이다.  
-> 이러한 수를 `1.0 - ε` 라고 표기하기로 약속하자.  

<br>

- 하지만 이러한 표현의 한계가 존지한다.  
  - ***Limitation #1***
    - `x/2`<sup>`k`</sup>` 형태의 수만 정확히 표현할 수 있다.  
      - 그렇지 않은 수들은 반복되는(순환) 비트 표현을 가지게 되어버린다.  
    - e.g.,  
      - `1/3` -> `0.0101010101[01]...`<sub>`2`</sub>
      - `1/5`  ->   `0.001100110011[0011]...`<sub>`2`</sub>
      - `1/10`  ->  `0.0001100110011[0011]...`<sub>`2`</sub>

  - ***Limitation #2***
    - `w`비트 내에서만 binary point를 설정할 수 있는 위치가 하나뿐이다. (positional notation, 위치 표기법)  
      - 따라서 표현할 수 있는 수의 범위가 제한적이다.  
      (매우 작거나 매우 큰 값은 불가능)

    <br>

### 2. IEEE Floating Point  
- Driven by numerical concerns
  - rounding, overflow, underflow에 대하여 굉장히 nice하고 우아한 스탠다드이다.

<br>

- **Floating Point Representation**
  - Numerical Form  
  `(-1)`<sup>`s`</sup>`M` `2`<sup>`E`</sup>
    - `s` - ***Sign bit*** : 수가 음수인지 양수인지를 결정한다.  
    - `M` - ***Significand*** : 일반적으로 `[1.0, 2.0)` 범위 내의 **fractional value**.
    - `E` - ***Exponent*** : 2의 제곱수에 해당하는 **weights**.  

  - Encoding
    - MSB s 는 sign bit `s`
    - exp field encodes `E` (but is not equal to E)
    - frac field encodes `M` (but is not equal to M)  
    ![encoding][def3]  

- **Precisions**(정밀도)
  - ***Single Precision*** : 32bits  
  ![single_precision][def4]

  - ***Double Precision*** : 64bits  
  ![double_precision][def5]  

  - ***Extended precision*** : 80bits (Intel only)  
  ![extended_precision][def6]  

  <br>

### 3. Normalized Values
- 더 큰 범위의 수를 표현하기 위한 인코딩 방식이다.  

- 다음과 같이 인코딩 된다.  
`v = (-1)`<sup>`s`</sup>`M 2`<sup>`E`</sup>

  - Sign Bit `s` : `0`이면 양수 / `1`이면 음수를 나타낸다.  

  - Exponent `E` = `Exp - Bias`
    - 지수 필드가 인코딩한다.
    - `Exp` : 지수 필드의 unsigned 값
    - `Bias` = `2`<sup>`k-1`</sup>`- 1`, `k`는 지수 비트의 크기  
      - Single precision : 127
      - Double precision : 1023
  
  - Significand `M` = `1.xxx...x`<sub>`2`</sub>  
    - 유효숫자 필드가 인코딩한다.
    - `xxx...x` : 유효숫자 필드의 비트들
    - Mininum when frac = `000.0` (`M = 1.0`)
    - Maximum when frac = `111.1` (`M = 2.0 - ε`)
    - Normalized value 인코딩 방식에서는 항상 `1.xxx...x` 형식으로 표현되므로, 소수점 이하의 부분만 저장한다.  
    (따라서 유효숫자 필드에서 1비트를 절약할 수 있다.)

<br>

### 4. Denormalized Values
- 더 정밀하게 수를 표현하기 위한 인코딩 방식이다.  

```
TO BE CONTINUED
```  

<br>

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/SrYisM4.png
[def2]: https://i.imgur.com/FvSRmB1.png
[def3]: https://i.imgur.com/mMyeoJE.png
[def4]: https://i.imgur.com/BuoWKbD.png
[def5]: https://i.imgur.com/PkAE7WN.png
[def6]: https://i.imgur.com/9izMLIM.png