---
layout: post
title: "[시스템 프로그래밍] 15주차 - Program Optimization"
excerpt: ""

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-12-05
last_modified_at: 2024-12-05
---
## Program Optimization
### 1. Overview
- *단순히 asymptotic complexity를 줄이는 것 만이 성능을 향상시키는 유일한 요인은 아니다.*  

- 상수 요소들 또한 중요하다 !
  - 반드시 여러가지 단계에서 optimize를 해야한다.
    - algorithm, data representation, procedures, and loops  

- 성능을 최적화 시키려면, 반드시 시스템을 이해해야 한다.  
  - 어떻게 프로그램이 컴파일되고 실행되는 지
  - 어떻게 현대 프로세서와 메모리 시스템이 동작하는 지
  - 프로그램 성능을 어떻게 측정하고 병목을 찾는 지
  - 코드 modularity와 generality를 유지하면서 어떻게 성능을 개선할 지  

  <br>

### 2. Optimization
#### [1] Optimizing Compilers  
- 프로그램을 기계어로 효율적으로 매핑시켜야 한다.
  - register allocation
  - code selection and ordering (scheduling)
  - dead code elimination
  - eliminating minor inefficiencies

- (일반적으로) asymtotic efficiency를 향상시키는 것은 아니다.  
  - 전반적으로 가장 괜찮은 알고리즘을 선택하는 것은 프로그래머에게 달렸다.  
  - big-O는 보통 상수 요소들보다 중요하다.
    - 하지만 상수 요소들 또한 중요하다.  

- TODO

<br>

- Limitations of Optimizing Compilers

<br>

#### [2] Code Motion
- 프로세서나 컴파일러에 관계없이, 프로그래머나 컴파일러가 할 수 있는 최적화 방법이다.  

- Code Motion  
  - TODO  

  <br>

#### [3] Reduction in Strength
- costly한 연산을 간단한 하나의 연산으로 대체하는 것이다.  
- 대표적으로 곱셈이나 나눗셈연산 대신, 시프트나 덧셈 연산을 이용하는 것이다.  
`16 * x` -> `x << 4`  
  - 사용하는 machine에 의존적이다.  
  - 곱셈이나 나눗셈 명령어의 cost에 의존한다.  
    - Intel Nehalem에서는 integer multiply가 3 CPU cycles를 소모한다.  

- TODO

<br>

#### [4] Share Common Subexpressions
- expression의 일부를 재사용하는 것이다.  
- GCC는 `-O1` flag로 이를 수행할 수 있다.  

![share_common_subexpressions](TODO)  

<br>

### 3. Optimization Blocker
#### [1] Procedure Calls
- String을 lower case로 바꾸는 함수가 있다.  

```c
void lower(char *s) {
    size_t i;
    for(i = 0 ; i < strlen(s) ; i++) {
        if(s[i] >= 'A' && s[i] <= 'Z') {
            s[i] -= ('A' - 'a');
        }
    }
}
```
- 이 함수의 performance는 Quadratic이다.  
![lower_case](TODO)  

- 위 함수를 Goto 형태로 바꾸어보면,  

```c
void lower(char *s) {
    size_t i = 0;
    if(i >= strlen(s)) goto done;
loop :
    if(s[i] >= 'A' && s[i] <= 'Z') {
        s[i] -= ('A' - 'a');
    }
    i++;
    if(i < strlen(s)) goto loop;
done :
    return;
}
```

- TODO

<br>

#### [2] Memory Aliasing
- 메모리는 중요하다. 아래와 같은 코드가 있을 때,  

```c
/* Sum rows is of n X n matrix */
/* and store in vector b */
void sum_rows1(double *a, double *b, int n) {
    long i, j;
    for(i = 0 ; i < n ; i++) {
        b[i] = 0;
        for(j = 0 ; j < n ; j++) {
            b[i] += a[i * n + j];
        }
    }
}
```

- TODO

<br>

- **Aliasing**
  - 두 개의 서로 다른 메모리 참조가 하나의 메모리 위치를 특정하는 문제이다.  
  - TODO  

<br>

### 4. Exploiting Instruction-Level Parallelism  
- 하드웨어 또한 optimization에 도움을 줄 수 있다.

- 우선 현대의 프로세서 디자인에 대한 전반적인 이해가 필요하다.  
  - 하드웨어는 여러 instruction을 동시에 실행할 수 있다.  
- 성능은 data dependencies에 의해 제한된다.  
- 간단한 변화로 드라마틱한 성능 향상을 산출할 수 있다.  
  - 컴파일러는 종종 이런 변화를 만들어내지 못한다.
  - floating-point 산술 연산에서의 associativity와 distributivity의 부족  

  <br>

- TODO  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>