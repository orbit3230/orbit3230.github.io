---
layout: post
title: "[시스템 프로그래밍] 14주차 - Linking"
excerpt: ""

tags:
  - [시스템 프로그래밍]

toc: true

date: 2024-12-02
last_modified_at: 2024-12-02
---
## Linking
- Example C Program

```c
/* main.c */
#include <stdio.h>
int sum(int *a, int n);

int array[2] = {1, 2};

int main() {
    int val = sum(array, 2);
    return val;
}
```

```c
/* sum.c */
int sum(int *a, int n) {
    int i, s = 0;
    for(i = 0 ; i < n ; i++) {
        s += a[i];
    }
    return s;
}
```

- Static Linking  
  - 프로그램은 compiler driver를 사용하여 translated 되고 linked 된다.  

```bash
$ gcc -Og -o prog main.c sum.c
$ ./prog
```

![linking][def]

<br>

### 1. Why Linkers?
- 왜 Linking을 하는가?
  - Reason 1 : Modularity
    - 프로그램은 하나의 monolithic 덩어리가 아니라 작은 소스파일들의 집합으로 작성될 수 있다.  
    - common functions는 library로 제공되어, 다른 프로그램에서도 사용될 수 있다.  

  - Reason 2 : Efficiency
    - 시간적 : compilation의 분할
      - 하나의 소스파일만 수정되었을 때, 그 파일만 다시 compile하고 relink하면 된다.  
      - 다른 소스파일들은 recompile할 필요가 없다.  

    - 공간적 : Libraries
      - common functions들을 하나의 파일에 모아둘 수 있다.  
      - 실행 파일과 실행중인 메모리 이미지는 오직 실제로 사용하는 함수들에 대한 코드만 포함한다.  

      <br>

### 2. What Do Linkers Do?  
- Step 1 : Symbol resolution  
  - 프로그램은 symbols들을 정의하고 참조한다. (전역변수, 함수)  
    - `void swap() {...}`
    - `swap();`
    - `int *xp = &x;`

  - Symbol 정의는 object file 내 symbol table에 저장된다.  
    - 각 entry는 이름, 크기, 그리고 위치를 포함한다.  
    - 각 symbol은 함수, 전역 변수, 또는 static 변수에 각각 대응한다.  

  - Symbol resolution 단계에서, Linker는 각 symbol 참조를 정확히 하나의 symbol 정의로 연관짓는다.  

  <br>

- Step 2 : Relocation
  - 분리된 code와 data sections를 하나의 section으로 합친다.  
  - object 파일 내 상대적인 위치로부터 symbols들을 실행파일에서의 절대적인 위치로 relocation한다.  
  - 모든 symbol 참조들이 새로운 위치를 반영하도록 업데이트.  

<br>

### 3. File Formats
TODO  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 시스템 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/ySsMvXw.png