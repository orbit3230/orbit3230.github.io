---
layout: post
title: "[C 프로그래밍] theme 4 - 변수와 자료형"
excerpt: "자료형 심화, 형식지정자 심화, overflow / underflow"

tags:
  - [C 프로그래밍, C]

toc: true

date: 2024-03-02
last_modified_at: 2024-03-02
---
## C의 구성요소 - 심화
[이전 주차에서 이어지는 내용이다.][def]  
### 1. unsigned / signed 자료형
- 우리가 지금까지 배운 정수 자료형은 `signed` 자료형이다.  
따로 지정하지 않으면, 컴파일러는 알아서 `int`를 `signed int` 로, `long`을 `signed long`으로 지정한다.   
<br>
- 반면 `unsigned` 자료형은 **양수** 만 다루는 자료형으로서,  
부호가 없지만(un+signed) 다룰 수 있는 값의 범위 크기는 그대로이기 때문에,  
`signed` 자료형보다 두 배 더 큰 절댓값의 양수 정수를 다룰 수 있다.  
  <sub> - `unsigned` 자료형 변수에 음수를 넣으면 양수로 취급한다.  

<br>

### 2. Overflow / Underflow
- 그렇다면 `signed int`와 `unsigned int`가 각각 다룰 수 있는 최댓값과 최솟값은 얼마일까?  

  - 2진수의 첫 번째 비트는 부호를 결정한다. `0`이면 양수, `1`이면 음수과 같은 형식이다.  
  따라서 `int` 타입은 `4 Byte`이므로 `32 bit` 中 `1 bit`를 부호에 사용하므로 최대 절댓값 `2^31` 크기의 정수를 다룰 수 있다.  
  <br>
  그런데 컴퓨터는 음수를 표현할 때 2의 보수 체계를 사용하므로,  
  음수는 `-1`부터 있지만 양수는 `0`부터 숫자를 세야하기 때문에  
  양수는 최대 `2^31 - 1` 크기의 정수를 다룰 수 있다.  
  <br>
  최종적으로 `signed int`는 `-2^31 ~ 2^31-1`의 정수 값을 다룰 수 있다.  
  <br>

- 반면 `unsigned int`는 음수를 다루지 않지만 다룰 수 있는 정수의 크기는 같기 때문에,  
최대 `2^31 + 2^31 - 1`, 즉 `0 ~ 2^32 -1`의 정수 값을 다룰 수 있다.  

<br>

- 이렇게 자료형은 크기에 따라 담을 수 있는 값의 한계가 존재한다.  

  - 따라서, 자료형이 담을 수 있는 값 범위의  
  **최댓값을 넘어버리는 것**을 **Overflow**,  
  **최솟값을 넘어버리는 것**을 **Underflow** 라고 한다.  
  <br>
  연산 도중 Overflow나 Underflow가 생기게 되면, 프로그램 작성자가 의도하지 않은 엉뚱한 값이 나오게 될 수 있다.  

- `<limit.h>` 헤더파일을 포함시켜, 해당 클래스 내 정의된 상수들을 이용해  
각 자료형들의 최댓값/최솟값을 알아볼 수도 있다.  

![limit_h][def2]  

<sub> + 마찬가지로 `<float.h>` 헤더파일을 포함시켜, 소수타입 자료형의 최댓값/최솟값을 알 수 있다.  

<br>

### 3. 형식지정자 심화
- 더 많은 자료형에 대해 알아보았기 때문에,  
지난주의 내용에 덧붙여 더 많은 종류의 형식지정자들을 알아보겠다.  

|자료형|형식지정자|
|:---:|:---:|
|`short`|`%hd`|
|`int`(10진수)|`%d`|
|`int`(8진수)|`%o`|
|`int`(16진수)|`%x`|
|`unsigned int`|`u`|
|`long`|`%ld`|
|`unsigned long`|`%lu`|
|`float` - 소수점 표현|`%f`|
|`float` - 지수 표지법|`%e` or `%E`|
|`float` - 소수점 vs 지수 중 짧은 것|`%g` or `%G`|
|`double`|`%lf` or `%le` or `%lE` or `%lg` or `%lG`|
|`long double`|`%Lf` or `%Le` or `%LE` or `%Lg` or `%LG`|
|`char`|`%c`|
|`char*` or `char[]`|`%s`|  

<sub> `double` 타입 값을 <u>출력</u> 할 땐 `%f` 형식지정자를 사용할 수 있다.  
(`%lf`과 같은 표현은 `C99` 에서 나온 새로운 표현이다. 이전에는 없었음                   )

<br>

### 4. 접두사 / 접미사
- 접두사
  - (10진수)8의 8진수 표현 -> `010`
  - (10진수)8의 16진수 표현 -> `0x8`  
  <sup> `%#x` 형식지정자는 16진수 앞에 `0x` 접두사를 붙여준다. 다른 진수표현도 똑같이 `#`를 넣어 가능
  - (10진수)8의 2진수 표현 -> `0b1000`

- 접미사
  - `unsigned int` -> `123u` or `123U`
  - `long` -> `123l` or `123L`
  - `unsigned long` -> `123ul` or `123UL`

### 5. 상수
- 상수를 선언하는 방법에는 세 가지가 있다.

  - (1) 숫자만 사용 - 비권장
  
  ```c
  printf(3.141592);
  ```

  - (2) `const`(상수) 변수 선언 - 효율적이다.

  ```c
  const float PI = 3.141592;
  printf("%f", PI);
  ```

  - (3) `#define`으로 명시적 치환 - 비교적 덜 효율적이다.

  ```c
  #define PI 3.141592

  printf("%f", PI);
  ```

  <br>

### 6. 부동소수점
- 컴퓨터는 `float`, `double`과 같은 실수를 다룰 때 **부동소수점(floating point) 방식**을 택한다.  
이는 실수를 표현할 때 소수점의 위치를 나타내는 수를 따로 적는 것으로,  
1bit의 부호비트와  유효숫자(fraction, 가수) 비트, 지수(exponent) 비트로 나누어 다룬다.  

![floating_point][def3]

  - 부동소수점은 더 적은 비트로 더 폭넓고 정밀한 값을 나타낼 수 있게 해준다.  

  - 단, 부동소수점 표현또한 유효숫자 부분에 저장할 수 있는 값에 한계가 있어,  
  연산 시 아주 작은 오차가 발생할 수도 있다.  
  이에 오차를 보정하기 위한 적절한 처리가 필요해질 수 있다.

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 최미정 교수님의 C 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://orbit3230.github.io/2024/02/29/C_theme2/#c%EC%9D%98-%EC%97%AC%EB%9F%AC-%EC%9A%94%EC%86%8C%EB%93%A4
[def2]: https://i.imgur.com/MU0Qmjz.png
[def3]: https://i.imgur.com/sKP3qNk.png