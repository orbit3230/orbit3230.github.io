---
layout: post
title: "[운영체제] 6주차 - Threads & CPU Scheduling"
excerpt: ""

tags:
  - [운영체제]

toc: true

date: 2025-04-10
last_modified_at: 2025-04-10
---
## Threads
### 1. Thread Libraries
- **Thread library**는 프로그래머에게 쓰레드 생성/관리를 위한 API를 제공한다.
- 구현에는 두 가지 주요 방법이 있다.
  - (1) Library entirely in user space
  - (2) Kernel-level library supported by the OS  

  <br>

- **Pthreads**
  - user-level 또는 kernel-level에서 제공될 것이다.
  - POSIX 표준 API에서 쓰레드 생성/synchronization을 위한 API를 제공한다.
  - **Specification** not **Implementation** : Pthreads는 구현이 아닌 API를 정의한다.  
  (확장성을 위하여)
  - API는 쓰레드 라이브러리의 동작을 정의하고, 구현은 개발자 dependent.
  - UNIX 운영체제에서 common. (Linux & Mac OS X)  

- Pthreads Example  

```c
#include <pthread.h>
#include <stdio.h>

#include <stdlib.h>

int sum;  /* this data is shared by the thread(s) */
void *runner(void *param); /* threads call this function */

int main(int argc, char *argv[]) {
    pthread_t tid; /* thread identifier */
    pthread_attr_t attr; /* set of thread attributes */
    
    /* set the default attributes of the thread */
    pthread_attr_init(&attr);
    /* create the thread */
    pthread_create(&tid, &attr, runner, argv[1]);
    /* wait for the thread to exit */
    pthread_join(tid, NULL);

    printf("sum = %d\n", sum);
}
```

```c
/* The thread will execute in this function */
void *runner(void *param) {
    int i, upper = atoi(param), sum = 0;
    /* compute the sum from 1 to upper */
    for (i = 1; i <= upper; i++) {
        sum += i;
    }
    /* exit the thread */
    pthread_exit(0);
}
```

- Pthreads Code for Joiningg 10 Threads

```c
#define NUM_THREADS 10

/* an array of threads to be joined upon */
pthread_t threads[NUM_THREADS];

for(int i = 0 ; i < NUM_THREADS ; i++)
    pthread_join(threads[i], NULL);
```

- Windows Multithreaded C Program

```c
int main(int argc, char *argv[]) {
    DWORD ThreadID;
    HANDLE ThreadHandle;
    int Param;

    Param = atoi(argv[1]);
    /* create the thread */
    ThreadHandle = CreateThread(
        NULL, /* default security attributes */
        0, /* use default stack size */
        Summation, /* thread function name */
        &Param, /* argument to thread function */
        0, /* use default creation flags */
        &ThreadID); /* returns the thread identifier */

    /* now wait for the thread to finish */
    WaitForSingleObject(ThreadHandle, INFINITE);

    /* close the thread handle */
    CloseHandle(ThreadHandle);

    printf("sum = %d\n", sum);
}
```

<br>

- **Explicit Threading** : TODO
- **Implicit Threading** : TODO

<br>

- **Thread Pools** : TODO  

<br>

- **OpenMP** : TODO

```c
#include <omp.h>
#include <stdio.h>

int main(int argc, char *argv[]) {
    /* sequential code */
    #pragma omp parallel {
        printf("I am a parallel region.");
    }
    /* sequential code */
    return 0;
}

#pragma omp parallel for
for(int i = 0 ; i < N ; i++) {
    c[i] = a[i] + b[i];
}
```

<br>

### 2. Thread Issues
- **`fort()`와 `exec()` system calls의 의미**
  - 만약 프로그램 내 하나의 쓰레드에서 `fork()`를 호출하면,  
  새로운 프로세스는 모든 쓰레드들을 duplicate 해야하나, 아니면 single-threaded인가?  
  -> 어떤 UNIX 시스템에서는 두 버전을 제공한다.

  - `exec()`는 주로 TODO

  - TODO

  - FYI - TODO

- **Signal handling**
  - **Signal**은 특정 이벤트가 발생했을 때 프로세스에게 notify하기 위해 UNIX에서 사용되는 메커니즘이다.
  
  - **signal handler**가 시그널을 처리하는 데 사용된다.
    - (1) 시그널이 특정 이벤트에 의해 생성된다.
    - (2) 시그널이 프로세스에 전달된다.
    - (3) 시그널은 둘 중 하나의 signal handler에 의해 처리된다.
      - (a) default
      - (b) user-defined

  - 모든 시그널은 커널이 실행하는 **default handler**를 가진다.
    - **User-defined signal handler**는 default를 override한다.
    - single-threaded에서는, 시그널이 프로세스에 전달된다.  

  - TODO

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>