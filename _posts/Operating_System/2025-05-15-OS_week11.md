---
layout: post
title: "[운영체제] 11주차 - Process Synchronization II"
excerpt: "Monitors, Liveness, Synchronization Examples"

tags:
  - [운영체제]

toc: true

date: 2025-05-15
last_modified_at: 2025-05-15
---
## Process Synchronization II
### 1. Monitors
- TODO

- Monitor의 pseudocode syntax
  - monitor의 인스턴스는 multi-processes에 의해 공유된다.
  - 한번에 오직 하나의 프로세스만 monitor 내에서 활성화될 수 있다.
  - 공유 데이터는 ADT 내에서 연산이나 함수에 의해 조작된다.
  - 프로세스들이 monitor를 사용하기 위해 기다리는 Entry queue가 있다.

  <br>

- Monitor의 구조  
![monitor_structure](TODO)  

```c
monitor monitor_name {
    // shared variable delarations
    function F1 (...) { ... }
    function F2 (...) { ... }
    function F3 (...) { ... }
    initialization code (... ) { ... }
}
```

- 프로그래머는 명시적으로 synchronization constraint 코드를 짤 필요가 없다.  

<br>

- 언어 별 Monitor  
  - TODO

<br>

### 2. Liveness
- TODO

- **Deadlock** : 두 개 이상의 프로세스가 하나의 이벤트를 무한히 기다리고 있는 상태  
(이벤트는 이들 프로세스 중 하나에 의해 발생)

- `S`와 `Q`가 `1`로 초기화된 semaphore라고 하자.  
![Semaphore_1](TODO)  

- 만약 `P`<sub>`0`</sub>이 `wait(S)`를 호출하고 `P`<sub>`1`</sub>이 `wait(Q)`를 호출하면,  
`P`<sub>`1`</sub>이 `signal(S)`을 호출할 때까지 `P`<sub>`0`</sub>는 대기하게 된다.

- 그러나 `P`<sub>`1`</sub> 또한 `P`<sub>`0`</sub>가 `signal(Q)`을 호출할 때까지 대기하고 있다.

- 따라서 `signal()` 연산이 영원히 발생하지 않아, `P`<sub>`0`</sub>와 `P`<sub>`1`</sub>은  deadlock 상태에 빠지게 된다.  
![deadlock](TODO)  

<br>

- Deadlock의 또 다른 형태
  - **Starvation** : 무한한 blocking
    - 프로세스가 semaphore queue에서 대기한 채 영원히 remove되지 않을 수 있다.

- **Priority Inversion** : 낮은 우선순위의 프로세스가 높은 우선순위가 필요로 하는 lock을 가질 때 발생하는 Scheduling problem  
  - e.g., `L` < `M` < `H` 일 때 `L`이 semaphore를 가지면 `H`도 기다려야 한다.  
  - **priority-inheritance protocol**을 통해 해결될 수 있다.  
    - 일시적으로 priority를 높여주는 것이다.  

    <br>

### 3. Synchronization Examples
- 새롭게 제안되는 synchronization 기법들을 테스트하는데 사용되는 클래식한 문제들이다.  

#### [1] Bounded-Buffer Problem
- Bounded-Buffer problem을 Semaphore를 사용하여 해결할 수 있다.
- 각 producers는 item을 생성하고 buffer에 넣는다.
- 각 consumers는 buffer에서 item을 소비한다.
- producer와 consumer 프로세스들은 다음과 같은 데이터 구조를 공유한다.  

  - `n` buffers - 각각 하나의 item을 저장할 수 있다.

  - Semaphore `mutex` - `1`로 초기화
    - buffer 액세스에 대해 상호 배제(mutual exclusion)

  - Semaphore `full` - `0`으로 초기화
    - buffer에 있는 item의 수를 나타낸다.
    - Producer에 의해 증가되고, Consumer에 의해 감소된다.

  - Semaphore `empty` - `n`으로 초기화
    - buffer에 비어 있는 공간의 수를 나타낸다.
    - Consumer에 의해 증가되고, Producer에 의해 감소된다.

<br>

- Producer 프로세스의 구조

```c
while(true) {
    ...
    /* produce an item in next_produced */
    ...
    wait(empty); // test if the buffer is available(to save) or not
    wait(mutex); // enter the critical section (using the buffer)
    ...
    /* add next_produced to buffer */
    ...
    signal(mutex); // leaving the critical section
    signal(full); // update the semaphore
}
```

- Consumer 프로세스의 구조

```c
while(true) {
    wait(full); // test if an item exits or not int the buffer
    wait(mutex); // enter the critical section (using the buffer)
    ...
    /* remove an item from buffer to next_consumed */
    ...
    signal(mutex); // leaving the critical section (done)
    signal(empty); // update the semaphore
    ...
    /* consume the item in next_consumed */
    ...
}
```

#### [2] Readers and Writers Problem
- 데이터베이스에서, 데이터셋은 주로 여러 개의 concurrent process에 의해 공유된다. (동시에 여러 writers and readers)
  - **Readers** : 오직 데이터셋을 read, 어떠한 update도 수행하지 **않는다.**
  - **Writers** : 데이터셋을 read & write

- 문제점 : readers와 writers 간 올바른 Synchronization
  - 여러 readers가 동시에 read하도록 허용하되,
  - 오직 한번에 하나의 writer만 공유 데이터에 액세스 가능하다.
    - writer에 대한 exclusive access
    - readers/writers는 write가 공유 데이터를 update하는 동안 반드시 대기해야한다.  

- TODO

<br>

- Shared data
  - 데이터베이스

  - Semaphore `mutex` - `1`로 초기화 (binary semaphore)
    - `read_count`에 대한 상호 배게(mutual exclusion)

  - Semaphore `rw_mutex` - `1`로 초기화 (binary semaphore)
    - writers에 대한 상호 배제(mutual exclusion)
    - critical section에 진입하는 첫 번째 reader가 사용한다.
      - e.g., 만약 적어도 하나의 reader가 공유 데이터에 액세스하고 있다면, writer는 액세스할 수 없다. 

<br>

#### [3] Dining Philosophers Problem

<br>

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>