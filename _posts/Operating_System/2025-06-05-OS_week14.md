---
layout: post
title: "[운영체제] 14주차 - Virtual Memory"
excerpt: "Virtual Memory, Demand Paging, Page Fault, Aspects of Demand Paging, Performance of Demand Paging, Copy-on-Write, What Happens if There is No Free Frame?, Page Replacement Algorithms, Trashing, Working Set Model"

tags:
  - [운영체제]

toc: true

date: 2025-06-05
last_modified_at: 2025-06-12
---
## Virtual Memory
- 코드가 실행을 위해 메모리에 올라와야 하나, 전체 프로그램이 사용되는 경우는 드물다.  
  - Error code, unusual routines, large data structures  
- 전체 프로그램 코드를 한 번에 필요로 하지는 않는다.
- 따라서 partially-loaded program을 실행하는 것을 고려해볼 필요가 있다.
  - 프로그램이 더 이상 physical memory의 제한에 의해 제약을 받지 않는다.
  - 각 프로그램이 실행되는 동안 메모리를 덜 잡아먹는다. -> 동시에 더 많은 프로그램을 실행할 수 있다.
    - Response time이나 turnaround time의 향상 없이도 CPU utilization과 throughput을 향상시킬 수 있다.  
  - 프로그램을 메모리로 load하거나 swap하는데 I/O가 더 적게 필요하다. -> 각 유저 프로그램이 더 빠르게 실행될 수 있다.  

<br>

### 1. Virtual Memory  
- **Virtual Memory** - User logical memory를 Physical memory와 분리하는 기술  
  - 오직 프로그램의 일부만 실행을 위해 메모리에 올라올 필요가 있다.
    - 프로그램 코드 전체가 동시에 필요하진 않다.  
    - 따라서, 전체 프로그램이 physical memory에 올라올 필요는 없다.  
  - 그러므로,  Logical address space가 Physical address space보다 훨씬 더 커도 된다.  
  - Address spaces로 하여금 여러 프로세스에 의해 공유될 수 있도록 한다.  
  - 더 효율적인 프로세스 생성을 가능하게끔 한다.
  - 더 많은 프로그램들이 동시에 실행될 수 있다.
  - 프로세스들을 load/swap하는 데 I/O가 더 적게 필요하다.  

  <br>

- **Virtual address space** - 어떻게 프로세스가 메모리에 저장되는지에 대한 logical view  
![Virtual Address Space][def]
  - 일반적으로 주소 `0`에서 시작하고, 연속적인 주소를 갖는다.  
  - 한편, physical memory는 page frames로 구조화된다.  
  - MMU는 반드시 logical->physical로 매핑해야 한다.  

![Virtual Address Space 2][def2]  
  - 일반적으로 logical address는 stack이 Max logical address에서 시작하고 아래로 grow하도록 설계된다.  
    - Address space의 사용량을 극대화한다.  
    - Stack과 heap 사이의 사용되지 않은 address space를 **hole**이라고 한다.  
    - Heap이나 stack이 grow하여 새로운 주어진 page에 도달하기 전까지는, 주어진 page에 대한 **추가적인 physical memory는 필요하지 않다**.

![Virtual Address Space 3][def3]  
  - Hole로 인해 **sparse**한 address space는 추가적인 growth나 dynamically linked libraries 등을 위해 남겨진다.  
  - System libraries는 virtual address space로의 매핑을 통해 공유된다.  
  - Read-write 가능한 pages를 virtual address space로 매핑함으로써 Shared memory를 구현할 수 있다.  
  - Pages는 `fork()` 호출을 통해 공유될 수 있고, 프로세스 생성을 더 효율적으로 만든다.  

<br>

### 2. Demand Paging  
- Virtual Memory는 **Demand Paging** 기법을 사용하여 구현된다.
- OS는 전체 프로세스를 load time에 메모리에 가져올 수 있다.
- 또는, 필요할 때만 메모리에 page를 가져올 수 있다.  
![Demand Paging][def4]  
  - 더 적은 I/O가 필요하고, 불필요한 I/O가 없다.
  - 더 적은 메모리가 필요하다.
  - 더 빠른 response
  - 더 많은 사용자
- Swapping을 포함한 paging system과 유사하다.  
- Invalid reference -> abord
  - Not-in-memory -> bring to memory
- **Lazy swapper** : 페이지가 필요하지 않다면, 절대 메모리로 swap하지 않는다.  
  - pages를 다루는 Swapper를 **pager**라고 한다.

- Demand paging 기법으로, 프로세스가 실행되는 동안 어떤 page는 메모리에, 어떤 page는 secondary storage에 위치할 수 있다.  
- 이 둘을 어떻게 구별할 수 있을까?
- Demand paging을 구현하기 위해서는 새로운 MMU 기능이 필요하다.  
- 이미 필요한 page가 **메모리에 있다**면,  
  - Non demand paging과 다를 게 없다.
- 그러나 필요한 page가 **메모리에 없다**면,  
  - 이를 탐지하고, storage에서 메모리로 page를 가져와야 한다.
    - 프로그램 동작에는 변화 없이
    - 프로그래머의 코드 변화 필요 없이
- 이를 위해서 **valid-invalid bit**를 포함한 Page table을 사용한다.    

- 각 Page table entry와 함께, valid-invalid 비트가 짝지어진다.  
  - `v` -> in-memory
  - `i` -> not-in-memory
- 초기에는 모든 entries에 대해 valid-invalid 비트가 `i`로 설정된다.  
- Example of a page table snapshot  
![Page Table Snapshot][def5]  

- 몇몇 pages가 메모리에 있지 않은 Page table Example  
![Page Table Example][def6]  

<br>

### 3. Page Fault  
- 프로세스가 메모리에 존재하지 않는 page에 접근할 때, page fault trap이 발생한다.  
  - Paging hardware는 Page table을 사용하여 주소를 변환하는 동안, invalid bits를 감지하여 OS에 trap을 발생시킨다.  

- Page fault를 다루는 단계  
  - (1) 만약 page에 대한 reference가 존재한다면, 해당 page에 대한 첫 번째 reference가 OS에 trap을 발생시킨다.
    - page fault
  - (2) OS는 다른 table을 살펴본다.
    - Invalid reference -> abort
    - 메모리에 없음 -> (go to step 3)
  - (3) Free frame을 찾는다. (만약 없다면?)
  - (4) 예약된 disk operation을 통해 page를 frame으로 swap한다.
  - (5) 이제 메모리에 온 page를 보이기 위해, table을 reset한다.  
    - validation bit를 `v`로 설정
  - (6) Page fault를 유발한 instruction을 다시 실행한다.  

![Page Fault Steps][def7]  

<br>

### 4. Aspects of Demand Paging
- **Pure demand paging** : 프로세스가 시작할 때는 어떤 page도 메모리에 올라오지 않는다.  
  - OS는 instruction pointer를 프로세스의 첫 번째 instruction으로 설정하고, 이는 non-memory-resident -> **page fault**를 발생시킨다.  
  - 그리고 모든 다른 프로세스 pages의 첫 번째 access는 page fault를 발생시킨다.  

- 실제로, 주어진 instruction은 여러 pages를 액세스할 수 있다. -> multiple page faults  
  - 두 개의 숫자를 메모리에서 얻어와 더하고, 다시 메모리에 저장하는 instruction을 생각해보자.  

- Demand paging은 hardward support를 필요로 한다.
  - Valid-invalid bits를 포함한 Page table
  - **swap space**를 포함한 Secondary storage
  - Instruction restart  

<br>

- Stages in Demand Paging - Worse Case  
  - (1) Operation에 Trap 발생
  - (2) 유저 레지스터와 프로세스 상태 저장 (e.g., PCB)  
  - (3) Interrupt가 page fault였음을 Determine
  - (4) Page reference가 legal 했는지 확인, 그리고 disk에서 page의 위치를 Determine
  - (5) Disk를 읽어 Free frame을 탐색
    - (a) Read request가 서비스되기 전까지 queue에 대기
    - (b) Device seek and/or latency time동안 대기
    - (c) Page를 free frame으로 보내기 시작
  - (6) 기다리는 동안, CPU를 다른 유저에게 할당
  - (7) Disk I/O subsystem으로부터 I/O 완료 interrupt를 수신
  - (8) 다른 유저에 대한 레지스터와 프로세스 상태를 저장
  - (9) Interrupt가 Disk에서 왔음을 Determine
  - (10) Page가 이제 메모리에 있음을 보이기 위해 Page table을 업데이트
  - (11) CPU가 할당되기를 기다림
  - (12) 유저 레지스터와 프로세스 상태, 새로운 page table을 복원하고, interrupted instruction을 다시 실행  

<br>

### 5. Performance of Demand Paging
- 세 가지 주요 activities
  - Service the interrupt : careful coding은 몇백개의 instruction이 필요함을 의미한다.  
  - Input the page from disk : lots of time
  - Restart the process : 또 다시 적은 양의 시간이 필요하다.  

- **Page Fault Rate** `0 <= p <= 1`  
  - 만약 `p = 0`이면, no page fault
  - 만약 `p = 1`이면, 모든 reference가 page fault

- Effective Access Time (EAT)  
`EAT = (1 - p) * memory access + p (page fault overhead + swap page out + swap page in)`  

<br>

- Example
  - Memory access time = `200` ns
  - Average page-fault service time = `8` ms
  - EAT = `(1 - p) * 200 + p * (8,000,000)`  
  = `200 + p * 7,999,800` ns

  - 만약 `1000`번 중 `1`번의 page fault가 발생한다면,  
  EAT = `8.2` ms  
    - 약 `40`개의 요소 만큼의 slowdown !!
  
  - 만약 performance degradation < `10`%를 원한다면,  
    - `220` > `200 + p * 7,999,800`  
    - `p < 0.0000025`  
      - 즉, `400,000`번 중 `1`번의 page fault가 발생해야 한다.  

<br>

- **Demand Paging Optimizations**  
  - 심지어는 같은 디바이스 내에서도, Swap space I/O를 file system I/O보다 더 빠르게 하는 것이다.
    - Swap이 더 큰 chunks에 할당되고, file system보다 더 적은 management가 필요하다.  
  - 프로세스 로드 시간에 전체 프로세스 이미지를 swap space로 copy
    - 그리고 나서 swap space에서 page in/out을 수행한다.
    - 구 BSD Unix에서 사용되었다.
  - TODO
    - TODO
  - Mobile systems  
    - TODO  

    <br>

### 6. Copy-on-Write
- **Copy-on-Write**(COW)는 부모 프로세스와 자식 프로세스들이 모두 초기에 메모리의 같은 pages를 **공유**하도록 한다.  
  - Remind
    - `fork()` -> 부모 프로세스에 속하는 pages를 복제
    - `exec()` -> 자식 프로세스의 binary를 pages에 overwrite  
  - 만약 프로세스가 shared page를 수정하려고 하면, page가 복사된다.  

- COW는 오직 수정된 pages가 copied 되도록 하여 더 효율적인 프로세스 생성을 가능하게 한다.  
![COW](TODO)  

<br>

- 일반적으로, free pages는 **zero-fill-on-demand** pages의 **pool**로부터 할당된다.  
  - Pool은 반드시 빠른 demand page execution을 위해 항상 free frames를 가지고 있어야 한다.
    - TODO
  - 왜 할당하기 전에 page를 zero-out 해야하는가?
    - TODO  

<br>

### 7. What Happens if There is No Free Frame?  
- TODO  

<br>

- **Basic page replacement**  
  - TODO  

<br>

- **Page replacement**  
  - TODO  

<br>

### 8. Page Replacement Algorithms  
- **Frame-allocation algorithm**은,  
  - 각 프로세스에 주어질 frame의 수를 결정한다.
  - 어떤 frame이 replace될 지를 결정한다.  

- **Page replacement algorithm**은,  
  - first access와 re-access 모두에서 가장 낮은 page-fault rate를 원한다.  

- TODO

- 일반적으로, page faults와 # of frames의 관계는 다음과 같다.  
![Page Faults vs # of Frames](TODO)  

<br>

#### [1] First-In-First-Out (FIFO) Algorithm
- Reference string : `7`,`0`,`1`,`2`,`0`,`3`,`0`,`4`,`2`,`3`,`0`,`3`,`0`,`3`,`2`,`1`,`2`,`0`,`1`,`7`,`0`,`1`

  - `3` frames (각 프로세스 당 한 번에 `3`개의 pages가 메모리에 올라올 수 있다.)  
  ![Page Replacement FIFO](TODO)  
  -> `15` page faults  

<br>

#### Belady's Anomaly  
- 우리는 프로세스에 더 많은 메모리를 부여하는 것이 성능을 향상시킬 것이라 생각한다.  
그러나, 이는 항상 true는 아니다.  

- 다음과 같은 string을 고려해보자 : `1`,`2`,`3`,`4`,`1`,`2`,`5`,`1`,`2`,`3`,`4`,`5`  
  - TODO

- TODO  

<br>

#### [2] Optimal Algorithm
- 앞으로 가장 오랜 기간동안 사용되지 않을 page를 replace한다.  
![Optimal Algorithm](TODO)  
  - `9` page faults  

- 이는 구현하기 어렵다. 우리는 미래를 읽을 수 없기 때문이다.  

- 가장 최적화된 알고리즘이기에, 얼마나 알고리즘이 최적화되었는지에 대한 기준이 된다.  

<br>

#### [3] Least Recently Used (LRU) Algorithm
- Optimal algorithm의 approximation이다. 미래 대신, 과거에 대한 정보를 사용한다.  

- 가장 오랫동안 사용되지 않은 page를 replace한다.  
![LRU Algorithm](TODO)  
  - `12` page faults - FIFO보다는 낫지만, Optimal보다는 worse이다.  

- 일반적으로 훌륭한 알고리즘이고, 자주 사용된다.  

- LRU는 **stack algorithm**의 예시 중 하나이다. 따라서, Belady's Anomaly의 영향을 받지 않는다.  
  - **stack algorithm** : **locality**를 고려하는 알고리즘  

<br>

- LRU Algorithm Implementation  
  - (1) Time-counter implementation
    - TODO

  - (2) Stack implementation  
  ![LRU Stack Implementation](TODO)  
    - TODO  

<br>

### 9. Trashing
- 만약 프로세스가 "충분한" frames를 받지 못한다면, page-fault rate가 매우 높아질 수 밖에 없다.  
  - page를 얻기 위해 page fault
  - 기존 frame을 replace
  - 그러나 가까운 미래에 또 replace back

- 이는 다음으로 이어진다.  
  - 낮은 CPU utilization
  - 운영체제는 multiprogramming의 degree를 늘려야 할 필요가 있다고 생각한다.  
  - 다른 프로세스가 시스템에 추가된다.  

- **Trashing** : 프로세스가 제대로 실행되지 못하고, 계속해서 바쁘게 swapping pages in and out.  
![Trashing](TODO)  

<br>

- Demand paging은 왜 작동하는가?
  - Locality model
    - 얼마나 많은 frames를 프로세스가 실제로 사용하는 지
    - 프로세스가 실행될 때, 프로세스는 locality에 기반에 다른 곳으로 migrate  
  - Memory footprint  
  ![memory footprint](TODO)  

<br>

- 왜 Thrashing이 일어나는가?
  - `프로세스 locality size의 Summation` > `전체 memory size`  

- 만약 현재 locality size를 수용할 만큼 충분한 frames를 할당하지 않으면, 프로세스는 thrash될 것이다.  

- Thrashing을 피하기 위해서는,
  - 프로세스 locality size의 합을 계산한다.
  - Policy
    - 만약 `프로세스 locality size의 합` > `전체 memory size`라면,  
    -> 프로세스 중 하나를 suspend 하거나 swap out한다.  

- Issue : 어떻게 "프로세스 locality size의 합"을 계산하는가.  

<br>

### 10. Working Set Model  
- `Δ`(delta) ≡ TODO

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/cmHA2aj.png
[def2]: https://i.imgur.com/hs47XRb.png
[def3]: https://i.imgur.com/MxgsvPn.png
[def4]: https://i.imgur.com/j67RFrI.png
[def5]: https://i.imgur.com/hHraXgP.png
[def6]: https://i.imgur.com/S5pmhlu.png
[def7]: https://i.imgur.com/tUlPNF1.png