---
layout: post
title: "[운영체제] 6주차 - Threads & Concurrency"
excerpt: "Multi-threaded Process, Benefits, Multicore Programming, User Threads vs. Kernel Threads"

tags:
  - [운영체제]

toc: true

date: 2025-04-07
last_modified_at: 2025-04-07
---
## Threads
- 프로세스 내 컨트롤의 흐름

- 쓰레드는 애플리케이션 내에서 실행된다.

- 각 쓰레드는 레지스터, 스택, 프로그램 카운터를 사용하여 자신의 context를 유지한다.  

- 하나의 프로세스 내에서 쓰레드들은 리소스(코드, 데이터, 파일, 시그널 등)을 공유한다.  
![threads][def]  
  - 프로세스 생성은 heavy-weight인 반면 쓰레드 생성은 light-weight이다.  

  <br>

### 1. Multi-Threaded Process
- 만약 하나의 프로세스가 여러 개의 쓰레드를 가지고 있다면, 여러 task를 동시에 수행할 수 있다.

- 여러 task를 수행하는 애플리케이션은 분리된 쓰레드로 구현된다.

  - Example on 워드 프로세서
    - 디스플레이 업데이트
    - 문법 체크
    - 유저 키 입력 처리  

  - Example on 웹 브라우저
    - 이미지, 스크립트, 텍스트 렌더링
    - 네트워크 request에 대한 응답
    - **Single-Threaded web server** : 서버가 한 클라이언트 request를 완료할 때까지 다른 클라이언트는 서비스를 기다려야 한다.
    - **Multi-Process web server** : 다른 클라이언트 request를 처리하기 위해 새로운 프로세스를 fork한다.
    - **Multi-Threaded web server** : 각 클라이언트 request를 처리하기 위해 새로운 쓰레드를 fork한다. 프로세스 생성보다 상대적으로 overhead가 적다.  

  - 커널은 대부분의 운영체제에서 일반적으로 multi-threaded이다.  
    - 커널 스페이스 내 여러 쓰레드
    - 각 쓰레드는 장치 관리, 인터럽트 핸들링같은 특정 task를 수행한다.  

- **Multi-threaded Server Architecture**  
![multi-threaded_server][def2]  

<br>

### 2. Benefits
- **Responsiveness**(반응성) : 프로세스 일부가 blocking되어도 실행을 계속할 수 있다. (유저 인터페이스에서 특히 중요)

- **Resource Sharing**(자원 공유) : 쓰레드는 프로세스의 자원을 공유하며, shared memory나 message passing보다 쉽다.  
  
- **Economy**(경제성) : 프로세스 생성보다 cheaper. 쓰레드 스위칭은 context switching보다 overhead가 적다.  

- **Scalability**(확장성) : 프로세스는 multicore 아키텍처의 어드밴티지를 챙길 수 있다.  

<br>

### 3. Multicore Programming
- 멀티쓰레드 프로그래밍은 멀티코어 아키텍처를 더 효율적으로 사용할 수 있고, 병렬 처리 성능을 높일 수 있다.  

- **Multicore** or **Multiprocessor** 시스템은 프로그래머에게 압박감을 준다. 프로그래머가 직면하는 challenge는,  
  - **Dividing activities** : 여러 코어가 병렬적으로 잘 처리할 수 있도록 애플리케이션을 병렬 tasks로 나누는 것
  - **Balance** : 나누어진 tasks는 가능한 even하게 분배되어야 한다.
  - **Data splitting** : task가 액세스하고 변경하는 데이터는 독립적이어야 한다. (각 코어에서 수행될 수 있도록)  
  - **Data dependency** : tasks가 사용하는 데이터는 serialization을 피하기 위해 의존적이지 않아야 한다. (e.g., 한 job이 끝나면 다음 job이 시작)  
  - **Testing and debugging** : 병렬 실행은 여러 컨트롤 플로우또한 생성한다. -> 멀티쓰레드 프로그램을 testing/debugging 하는 환경이 필요하다.  

- **Parallelism** : 하나 이상의 task를 동시에 수행할 수 있는 시스템을 의미
- **Concurrency** : 하나 이상의 task가 진행되는 것을 지원
- **Concurrency vs. Parallelism**  
  - Single-core 시스템에서의 **Concurrent execution**  
  ![concurrency][def3]  
    - 두 개 이상의 tasks가 time period에 걸쳐서 실행될 수 있다.
    - tasks가 동시에 실행될 필요는 없다. (virtual parallelism)  
  - Multi-core 시스템에서의 **Parallel execution**  
  ![parallelism][def4]  
    - 말 그대로, 두 개 이상의 tasks가 동시에 실행된다.  

- **Parallelism**의 타입  
![parallelism][def5]  
  - **Data Parallelism** : 같은 데이터의 부분집합을 여러 코어에 분산, 각각은 같은 operation  
  - **Task Parallelism** : 코어들에 쓰레드를 분산, 각 쓰레드는 unique operation을 수행  

<br>

- **암달의 법칙 (Amdahl's Law)**  
  - 시스템 내 task 성능 향상에 대한 이론적인 speedup을 예측하는 공식
  - 병렬 컴퓨팅에서, 직렬/병렬 요소를 모두 갖는 애플리케이션에 코어를 추가함으로서 얻는 성능 향상에 대한 upper bound를 제공한다.  
  ![amdahls_law][def6]  
    - `S` : serial portion
    - `N` : processing cores  
    - 만약 `75%`의 parallel / `25%`의 serial portion을 가진 애플리케이션에서 `1`->`2`개의 코어로 변경한다면,  
      - `S = 0.25`  
      - `P = 1 - S = 0.75`  
      - `Speedup = 1 / (S + P/N) = 1 / (0.25 + 0.75/2) = 1.6`  
    - `N`이 무한대로 수렴하면, `Speedup`은 `1/S`로 수렴한다.  
      - 따라서 코어의 개수가 일정 이상 증가하면, 애플리케이션의 직렬 부분은 불균형적인 영향을 미친다.  
    ![amdahls_law_graph][def7]  
    - 하지만 현대의 멀티코어 시스템을 완전히 표현하기엔, 암달의 법칙은 너무 단순하다. 실제로는 영향을 미치는 요소가 더 많다.  

    <br>

### 4. User Threads vs. Kernel Threads  
![user_kernel_threads][def8]  
- **User Threads** : 유저-레벨 쓰레드 라이브러리에 의해 관리된다.  
- 세 가지 주요 쓰레드 라이브러리
  - POSIX **Pthreads**
  - Windows threads
  - Java threads

- **Kernel Threads** : 커널에 의해 관리된다.  

<br>

- **Multi-threading Models**
  - (1) **Many-to-One** : 여러 유저 쓰레드가 하나의 커널 쓰레드에 매핑된다.  
  ![Many-to-One][def9]  
    - 하나의 쓰레드 blocking이 모두 block 시킨다.  
    - 여러 쓰레드가 멀티코어 시스템에서 병렬적으로 실행되지 않을 수 있다.  
    (한 번에 하나만 커널에 존재하기 때문)
    - 거의 사용하지 않는 모델이다.  
    - e.g., Solaris Green Threads, GNU Portable Threads

  - (2) **One-to-One** : 하나의 유저 쓰레드가 하나의 커널 쓰레드에 매핑된다.  
  ![One-to-One][def10]  
    - 유저-레벨 쓰레드가 커널 쓰레드를 생성한다.    
    - many-to-one 보다 concurrency가 높다.
    - 프로세스 당 쓰레드의 수가 종종 overhead 때문에 제한된다.    
    - e.g., Linux, Windows, Solaris

  - (3) **Many-to-Many** : 여러 유저 쓰레드가 여러 커널 쓰레드에 매핑된다.  
  ![Many-to-Many][def11]  
    - 운영체제로 하여금 충분한 양의 커널 쓰레드를 생성할 수 있도록 한다.  
    - Windows with the *ThreadFiber* package
    - 그렇지만 그렇게 흔히 사용되지는 않는다.  

  - (4) **Two-level** : M:M과 유사하지만, 제한된 수의 유저 쓰레드가 커널 쓰레드에 매핑된다.  
  ![Two-level][def12] 

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/7pvNnL0.png
[def2]: https://i.imgur.com/PvNjIj9.png
[def3]: https://i.imgur.com/VAMXKPK.png
[def4]: https://i.imgur.com/DMpEVpu.png
[def5]: https://i.imgur.com/t6xvVPj.png
[def6]: https://i.imgur.com/0gIXNRz.png
[def7]: https://i.imgur.com/UUsLY94.png
[def8]: https://i.imgur.com/exQ6fLe.png
[def9]: https://i.imgur.com/WnowoWD.png
[def10]: https://i.imgur.com/QkCcDy1.png
[def11]: https://i.imgur.com/xu61vld.png
[def12]: https://i.imgur.com/9hUDGah.png