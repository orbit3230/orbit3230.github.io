---
layout: post
title: "[운영체제] 12주차 - Deadlock"
excerpt: ""

tags:
  - [운영체제]

toc: true

date: 2025-05-22
last_modified_at: 2025-05-22
---
## Deadlock
### 1. Deadlock System Model
- 프로세스 집합이, 집합 내 다른 프로세스에 의해 occupied된 자원을 얻기 위해 서로 기다리며 blocked된 상태

- Example
  - 프로세스 `P0`은 오직 리소스 `R0`와 `R1`을 가져야 진행 가능
  - 프로세스 `P1`은 오직 리소스 `R0`와 `R1`을 가져야 진행 가능
  - 프로세스 `P0`이 리소스 `R0`을 가지고 있고, `P1`이 리소스 `R1`을 놓아주길 기다리고 있는 상황
  - 프로세스 `P1`이 리소스 `R1`을 가지고 있고, `P0`이 리소스 `R0`을 놓아주길 기다리고 있는 상황  

<br> 

- 시스템은 리소스들로 구성
- 리소스 type `R1`, `R2`, ..., `Rm`  
  - CPU cycles, memory space, I/O devices, variables, etc.
- 각 리소스 type `Ri`는 `Wi` 인스턴스를 가짐
- 각 프로세스는 리소스를 다음과 같이 활용한다.  
  - Request
    - TODO
  - Use
    - TODO
  - Release
    - TODO

<br>

### 2. Deadlock Characterization
- Deadlock은 다음과 같은 네 가지 조건을 **동시에** 만족해야 발생할 수 있다.  
  - **Mutual Exclusion** : 오직 한 번에 하나의 프로세스만 **리소스**를 사용할 수 있다.
  - **Hold and Wait** : 적어도 하나의 리소스를 가진 **프로세스**가 다른 프로세스가 가진 추가적인 리소스를 얻기 위해 대기하고 있다.
  - **No Preemption** : 리소스는 프로세스가 자발적으로 놓아주지 않는 한 강제로 빼앗을 수 없다.
  - **Circular Wait** : TODO  

  <br>

### 3. Resource-Allocation Graph
- Deadlock은 **Resource-allocation graph**라는 방향 그래프로 깔끔하게 표현할 수 있다.  
  - Graph `G = (V, E)`  

- Vertices `V` 집합과 Edges `E` 집합으로 구성
  - `V`는 두 가지 타입으로 나뉜다.  
    - `P` = `{P1, P2, ..., Pn}` : 프로세스 집합
    - `R` = `{R1, R2, ..., Rm}` : 리소스 집합
  - **request edge** : directed edge `Pi -> Rj` -> 프로세스 `Pi`가 리소스 `Rj`를 요청하고 있는 상태
  - **assignment edge** : directed edge `Rj -> Pi` -> 프로세스 `Pi`가 리소스 `Rj`를 점유**했던** 상태

<br>

- Resource Allocation Graph Example  
![Resource-allocation graph_example](TODO)  
  - TODO  

- Resource Allocation Graph with a Deadlock
![Resource-allocation graph_deadlock_1](TODO)  
![Resource-allocation graph_deadlock_2](TODO)  

<br>

### 4. Deadlock Solution
- Deadlock and Solution
  - Basic Facts
    - 만약 그래프가 cycle이 없다면 -> No deadlock
    - 만약 그래프가 cycle이 있다면
      - 만약 각 리소스 타입 당 오직 하나의 인스턴스 -> Deadlock
      - 각 리소스 타입 당 여러 개의 인스턴스가 존재 -> Deadlock의 **가능성**
        - 항상 그런 것은 아니다.  

  - Deadlock Handling 방법
    - 시스템이 **절대** Deadlock에 빠지지 않도록 보장
      - **Deadlock prevention**
      - **Deadlock avoidance**
    - 시스템이 Deadlock에 빠지도록 허용하되, Recover 될 수 있도록 설계
      - **Detection and recovery**
    - 문제를 무시하고, Deadlock이 절대 발생하지 않는다고 pretend
      - **Ignoring the problem**

      <br>

#### [1] Deadlock Prevention
- 네 가지 Deadlock 필수 조건들 중에서 하나를 Invalidate
  - **Mutual Exclusion** : TODO
  - **Hold and Wait** : TODO
  - **No Preemption** : TODO
  - **Circular Wait** : TODO  

  <br>

#### [2] Deadlock Avoidance
- 시스템이 몇몇 추가적인 **Priority** 정보를 가지고 있어야 한다.
  - TODO  

<br>

### 5. Safe State  
- TODO  

<br>

### 6. Avoidance Algorithms
- TODO

<br>

#### [1] Modified Resource-Allocation Graph
- TODO  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>