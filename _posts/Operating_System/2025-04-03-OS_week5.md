---
layout: post
title: "[운영체제] 5주차 - Process II"
excerpt: "Interprocess Communication, Shared Memory, Message Passing, Synchronization, Producer-Consumer Problem, IPC in Client-Server Systems"

tags:
  - [운영체제]

toc: true

date: 2025-04-03
last_modified_at: 2025-04-03
---
## Process
### 1. Interprocess Communication (IPC)
- 시스템 내 프로세스들은 **독립적**일 수도 있고, **협력적**일 수도 있다.  

- 협력하는 프로세스들은 서로에게 영향을 주고 받으며, sharing data를 포함한다.  

- 프로세스들이 협력하는 이유
  - 정보 공유 (e.g., 여러 프로세스 or 유저에 의해 공유)
  - 계산 속도 향상 (e.g., 병렬 처리)
  - 모듈화 (e.g., 기능 단위로 유닛 분리)
  - 편리성

- 협력하는 프로세스들은 **Interprocess Communication** (IPC)를 필요로 한다.  

- IPC의 두 모델  
![ipc_model](TODO)  
  - **Shared Memory** (유저에 의해 컨트롤)
    - IPC가 공유 영역에서 데이터를 저장하고 읽는 방식으로 수행된다.
    - 커뮤니케이션 측면에서 빠르고 사용하기 쉽다.
    - TODO

  - **Message Passing** (OS에 의해 컨트롤)  
    - IPC가 데이터의 전송 or reception을 통해 수행된다.
    - TODO  

    <br>

### 2. IPC in Shared-Memory Systems
- **Shared Memory Solution**
  - 커뮤니케이션하고자 하는 프로세스 간 공유된 메모리 영역
  - 커뮤니케이션은 OS가 아닌 유저 프로세스의 통제 하에서 이루어진다.
  - 주요 이슈는 유저 프로세스들로 하여금 공유 메모리에 접근할 때 actions를 synchronize하도록 하는 메커니즘 제공이다.  
  - Synchronization은 chapter 6-7에서 다룬다.  

  <br>

- **Producer-Consumer Problem**
  - 협력하는 프로세스를 위한 패러다임
    - **Producer** 프로세스가 정보를 생산하면, **Consumer** 프로세스가 소비한다.  
  
  - 두 가지 Variations
    - **Unbounded-Buffer** : TODO
    - **Bounded-Buffer** : TODO  

<br>

- **Bounded-Buffer - Shared-Memory Solution**  
![bounded_buffer](TODO)  
  - TODO

<br>

- **Producer Process - Shared Memory**  

```c
item next_produced;

whlie(true) {
    /* produce an item in next_produced */
    while(((in + 1) % BUFFER_SIZE) == out) {
        /* do nothing - buffer is full */
    }
    /* the produced item is inserted into the buffer */
    buffer[in] = next_produced;

    in = (in + 1) % BUFFER_SIZE;
}
```

- **Consumer Process - Shared Memory**  

```c
item next_consumed;

while(true) {
    while(in == out) {
        /* do nothing - buffer is empty */
    }
    /* an item is removed from the buffer */
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;

    /* consume the item in next_consumed */
}
```

<br>

- **모든 버퍼를 가득 채우면?**
  - TODO  

- **Produer**  

```c
unsigned counter = 0;
// ,,,
while(true) {
    /* produce an item in next_produced */
    while(counter == BUFFER_SIZE) {
        /* do nothing - buffer is full */
    }
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
    counter++;
}
```

- **Consumer**  

```c
unsigned counter = 0;
// ,,,
whlie(true) {
    while(counter == 0) {
        /* do nothing - buffer is empty */
    }
    next_consumed = buffer[out];
    out = (out + 1) % BUFFER_SIZE;
    counter--;
    /* consume the item in next_consumed */
}
```

<br>

- **Race Condition**
  - `counter++`는 이렇게 구현될 수 있다.  
  `register1 = counter`  
  `register1 = register1 + 1`  
  `counter = register1`  

  - `counter--`는 이렇게 구현될 수 있다.  
  `register2 = counter`  
  `register2 = register2 - 1`  
  `counter = register2`  

  - `count = 5`으로 초기화 한 후의 이 execution을 생각해보자.  
  ![race_condition](TODO)  
    - race condition을 극복하는 방법에 대해서는 chapter 6에서 다룬다.  

<br>

### 3. IPC in Message-Passing Systems  
- **IPC - Message Passing**
  - 프로세스들이 shared variables에 의존하지 않고 서로 커뮤니케이션 한다.  
    - 프로세스들은 서로 다른 네트워크에 존재할 수 있다.  

  - IPC facility는 두 가지 operations를 제공한다.  
    - **send** 
    - **receive**  

  - 메시지 크기는 고정되어 있을 수도 있고, 가변적일 수도 있다.  
    
  - 일반적으로 둘 다 system call로 구현되어 있다.  

  - TODO  

  <br>

- **Implementation of Communication Link**
  - Physical
    - 공유 메모리
    - 하드웨어 버스
    - 네트워크

  - Logical
    - 직접 or 간접
    - 동기화 or 비동기화
    - 자동화 or 명시적 버퍼링  

    <br>

- **Direct Communication**
  - 한 쌍의 프로세스가 직접적으로 established-link를 통해 메시지를 송/수신

  - 프로세스들은 서로를 명시적으로 식별해야 한다.  
    - `send(P, message)` : P에게 메시지 전송
    - `receive(Q, message)` : Q로부터 메시지 수신

  - Communication link의 속성
    - 링크는 자동적으로 생성된다.
    - 하나의 링크는 정확히 한 쌍의 커뮤니케이션하는 프로세스와 연결된다.
    - 각 프로세스 쌍 간에는 정확히 하나의 링크만 존재한다.
    - 링크는 단방향일 수도 있지만, 일반적으로 양방향이다.  

    <br>

- **Indirect Communication**
  - 메시지들은 mailboxes와 연결되어 수신된다.  
    - 각 포트(or mailbox)는 고유한 id를 가진다.
    - 프로세스들은 오직 port(or mailbox)를 공유할 때만 커뮤니케이션 할 수 있다.

  - Communication link의 속성  
    - 링크는 포트를 공유할 때만 생성된다.
    - 링크는 여러 프로세스와 연결될 수 있다.
    - 각 프로세스 쌍 간에 여러 개의 링크가 존재할 수 있다.
    - 링크는 양방향일 수도 있고, 단방향일 수도 있다.

  - TODO  

  <br>

- **Synchronization**
  - 메시지는 blocking or non-blocking 방식으로 전해진다.  
    - **Blocking**은 **synchronous**이다.
      - **Blocking send** - sender는 메시지가 수신되기 전 까지 block된다.
      - **Blocking receive** - receiver는 메시지가 사용 가능하기 전 까지 block된다.  

    - **Non-blocking**은 **asynchronous**이다.
      - **Non-blocking send** - sender는 메시지fmf 송신하고 계속 진행한다.
      - **Non-blocking receive** - receiver는 다음을 수신한다.
        - A valid message
        - Null message

    - 다른 조합도 가능하다.
      - 만약 send와 receive가 모두 blocking이라면, **rendezvous**가 필요하다.  

    <br>

- **Producer-Consumer: Message Passing**  
  - Produer  

  ```c
  // TODO
  ```

  - Consumer  

  ```c
  // TODO
  ```

  <br>

### 4. Examples of IPC Systems
- POSIX Shared Memory  
  - TODO

- IPC POSIX Producer  
![ipc_posix_producer](TODO)  

- IPC POSIX Consumer  
![ipc_posix_consumer](TODO)  

<br>

- **Pipes**  
  - TODO  

  <br>

### 5. Communication in Client-Server Systems  
- **Sockets**  
TO BE CONTINUED  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>