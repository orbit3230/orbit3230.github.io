---
layout: post
title: "[운영체제] 7주차 - CPU Scheduling"
excerpt: "CPU Scheduler, Preemptive / Non-Preemptive, Scheduling Algorithms"

tags:
  - [운영체제]

toc: true

date: 2025-04-14
last_modified_at: 2025-04-14
---
## CPU Scheduling
- CPU 또한 OS에 의해 관리되어야 하는 컴퓨터 리소스들 중 하나이다.  
- **CPU utilization을 최대화**
- CPU가 항상 바쁘게 일하도록 유지해야 한다.
- CPU-I/O burst Cycle  
![CPU-I/O burst Cycle][def]  
  - 프로세스 실행은 CPU execution과 I/O wait **cycle**로 이루어져 있다.
  - CPU burst 분배가 주요 관심사가 된다.  
- Multiprogramming을 가능하게끔 한다.  
- 용어 (모두 같은 의미)
  - CPU scheduling
  - Process scheduling
  - Kernel thread scheduling

<br>

- CPU-burst 패턴을 분석해보면, 아래와 같은 그래프로 나타난다.  
![CPU-burst][def2]
  - 많은 수의 짧은 CPU burst
  - 적은 수의 긴 CPU burst
  - 이 분포는 CPU-schedular 알고리즘을 구현할 때 중요하다.  

  <br>

### 1. CPU Scheduler
- **CPU schedular**는 ready queue에 있는 프로세스 중에서 하나를 선택하여, CPU 코어에게 할당해주는 역할을 한다.  
  - Queue는 다양한 방식으로 정렬되어 있을 수 있다.  

- CPU scheduing decision은 크게 네 가지 순간에 이루어진다.  
  - (1) running -> waiting (I/O burst)
  - (2) running -> ready
  - (3) waiting -> ready
  - (4) Terminates

- (1)과 (4) 상황의 경우, 반드시 새로운 프로세스가 할당이 되어야 한다. (no choice)
- 그러나 (2)와 (3)의 경우, There is a choice.

<br>

### 2. Preemptive / Non-Preemptive
- 스케쥴링이 (1)번과 (4)번 상황에서 이루어질 때, Scheduling scheme은 **non-preemptive**이다.

- 그렇지 않으면, **preemptive**이다.  

- Non-preemptive scheduling 하에서, 일단 CPU가 프로세스에 할당되었다면 프로세스는 CPU가 terminating or waiting 상태가 되어 놓아줄 때까지 CPU를 점유한다.

- 그래서 거의 모든 현대 OS들은 preemptive scheduling을 사용한다.

<br>

- **Preemptive Scheduling과 Race Conditions**
  - Preemptive Scheduling은 Race Condition을 유발할 수 있다.
  - 두 프로세스가 같은 데이터를 공유하고 있는 경우를 고려해보자.  
  일단 한 프로세스가 데이터를 업데이트하면, preempted되므로 두 번째 프로세스가 동작할 수 있다.  
  두 번째 프로세스가 그 데이터를 읽으려고 하면, 그 데이터는 일관되지 않은(inconsistent) 상태가 된다.  
  - 이 Issue에 대해서는 Chapter 6에서 자세히 다룬다.  

<br>

### 3. Scheduling Algorithms
- **Dispatcher** 모듈은 CPU 스케쥴러에 의해 선택된 프로세스에게 CPU의 제어를 넘겨주는 역할을 한다; this involves  
  - switching context
  - switching to user mode
  - jumping to the proper location  

- **Dispatch latency** : Dispatcher가 한 프로세스를 중지하고 다른 프로세스를 시작하는 데 걸리는 시간.  
![Dispatch latency][def3]  

<br>

- **Scheduling Criteria**
  - **CPU utilization** : CPU가 가능한 바쁘게 일하도록 하는 것
  - **Throughput** : unit time에 execution을 완료한 프로세스의 수
  - **Turnaround time** : 특정 프로세스가 execute 하는데 걸린 총 시간 (CPU 사용, waiting in I/O, ready queue 모두 포함)
  - **Waiting time** : 프로세스가 ready queue에서 기다린 총 시간
  - **Response time** : request가 제출되고, 첫 response가 돌아오기까지 걸린 시간.   

<br>

#### [1] RR scheduler

<br>

#### [2] SIF

<br>

#### [3] Multi-level-queue

<br>

#### [4] Multi-level-feedback-queue

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 운영체제 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/0mW82jZ.png
[def2]: https://i.imgur.com/F4Jvquc.png
[def3]: https://i.imgur.com/1rddWL9.png