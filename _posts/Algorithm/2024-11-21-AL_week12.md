---
layout: post
title: "[알고리즘] 12주차 - Branch-and-Bound"
excerpt: ""
tags:
  - [알고리즘, CPP]

toc: true

date: 2024-11-21
last_modified_at: 2024-11-21
---
## Branch-and-Bound
### 1. 0-1 Knapsack Problem
#### [1] Dynamic programming approach
- Dynamic programming을 이용한 접근법은 [다음 포스팅][def]을 참조

#### [2] Backtracking & Branch-and-Bound approach  
- Branch-and-bound vs. Backtracking
  - Similarity
    - State space tree가 사용됨

  - Difference
    - tree 순회의 way가 제한되어 있지 않음
    - optimization problem에서 사용됨  

<br>

- ***Branch-and-bound***
  - **Bound** : 노드에서 최대한 뻗어나갔을 때 얻을 수 있는 최대값
  - 노드가 promising 한 지를 판별할 때 해당 노드의 bound를 계산
    - 만약 노드의 bound가 best solution found보다 낫지 않다면, 해당 노드는 **nonpromising**  

  - Best-first search with branch-and-bound pruning : promising nodes들의 bounds를 비교하여, 가장 best bound를 가진 노드의 children을 방문하는 방식  
    - BFS with branch-and-bound pruning과 유사하다.  
    - backtraking에서 종종 DPS보다 더 빠르게 optimal solution을 찾을 수 있다.  

    <br>

- **0-1 Knapsack problem** with Backtracking  
![0-1_knapsack_backtracking](TODO)  

  - 우선, `p`<sub>`i`</sub> / `w`<sub>`i`</sub>을 기준으로 내림차순 정렬한다.  

  - State space tree 생성  
  ![0-1_knapsack_backtracking_tree](TODO)  

  <br>

  - 두 가지 **promising** function을 생각해볼 수 있다.  
    - (1) `weight` >= `W` -> **nonpromising**  
      - `weight` : knapsack에 들어있는 items들의 무게 총 합  

    - (2) `bound` <= `maxprofit` -> **nonpromising**  
      - `bound` : 노드에서 최대로 얻을 수 있는 profit  
      - `maxprofit` : 현재까지 찾은 최대 profit  
      - `bound`는 아래와 같이 구할 수 있다.  
      ![0-1_knapsack_backtracking_totalweight](TODO)
      ![0-1_knapsack_backtracking_bound](TODO)  

      <br>

- 이러한 promising function을 적용하였을 때, 일반적으로 BFS는 DFS보다 비효율적이다.  
  - Traversing sequence - DFS  
  ![0-1_knapsack_backtracking_dfs](TODO)  

  - Traversing sequence - BFS  
  ![0-1_knapsack_backtracking_bfs](TODO)  

<br>

- 하지만, Breadth-first search를 개선한 Best-first-search를 적용해보자.  
  - 탐색 초기부터 높은 값의 maxprofit을 찾게 된다면, pruning이 더 빨리, 자주 일어날 것이다.  
  많은 pruning은 곧 탐색 성능의 향상을 의미한다.  

  - 따라서 Best-first search는 높은 bound를 가진 노드를 먼저 방문하는 technique이다.  

  - Traverse sequence - Best-first search  
  ![0-1_knapsack_backtracking_bestfirst](TODO)  

<br>

### 2. Traveling Salesperson Problem  
#### [1] Dynamic programming approach

#### [2] Branch-and-Bound approach  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown=   "1">

이 포스팅은 강원대학교 김도형 교수님의 알고리즘 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details> 

[def]: https://orbit3230.github.io/2024/10/21/AL_week8/#6-knapsack-problem