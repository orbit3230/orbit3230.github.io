---
layout: post
title: "[알고리즘] 2주차 (2) - Divide and Conquer"
excerpt: "Basic Approach, Binary Search Algorithm, Merge Sort Algorithm, Master Theorem, Quick Sort Algorithm"

tags:
  - [알고리즘, CPP]

toc: true

date: 2024-09-12
last_modified_at: 2024-09-19
---
## Divide and Conquer
### 1. Basic Approach
- **Divide**
  - 주어진 problem를 2개의 subproblems로 나눈다.  
  - 대략적으로 같은 크기로 나누는 것이 이상적이다.  

- **Conquer**
  - 각 subproblem을 해결한다.
  - 직접 or 재귀적  

- **Combine**
  - 두 subproblems의 해답을 Combine하여 global solution을 도출한다.  

  <br>

### 2. 대표적인 분할 정복 사용 예
#### [1] Binary Search Algorithm
- 이분 탐색 알고리즘.

- 방법
  - Divide - 배열을 중간 값으로 나누고 중간 값과 비교
  - Conquer - 중간 값 보다 크면 오른쪽 배열을, 작으면 왼쪽 배열에서 탐색 반복  
  ![binary_search][def2]

- Correctness Proof  
![binary_search_correctness][def13]

- Worst case time complexity  
  - `W(n)` : 입력이 `n`일 때 드는 연산의 수
  ![binary_search_time_complexity][def]  

  - Proof  
  ![binary_search_time_complexity_proof][def14]

<br>

#### [2] Merge Sort Algorithm
- 합병 정렬 알고리즘.  

- 방법
  - Divide - 배열을 절반으로 나눈다.  
  - Conquer - 각 서브배열을 정렬한다. 배열의 크기가 충분히 작아질 때 까지 분할정복한다.  
  - Combine - 각 서브배열을 순서 알맞게 하나의 배열로 합친다.  
  ![merge_sort][def3]  

- Correctness Proof  
![merge_sort_correctness][def15]  

- Worst case time complexity  
  - `W(n)` : `n`개의 원소를 정렬하는 데 드는 연산의 수  
  ![merge_sort_time_complexity1][def4]  
  ![merge_sort_time_complexity2][def5]  
  
  - Proof  
  ![merge_sort_time_complexity_proof][def16]

<br>  

### 3. Master Theorem
- 시간 복잡도를 분석하는 데에 쓰인다.  
![master_theorem][def6]  

  - Case 1 : ![case_1][def7]
  
  - Case 2 : ![case_2][def8]  
    - binary search와 merge sort는 이에 해당한다.  

  - Case 3 : ![case_3][def9]  

- Proof  
![master_theorem_proof][def17]

<br>

### 4. Quick Sort Algorithm
- 퀵 정렬 알고리즘.  

- Idea : 분할 정복을 통하여 정렬 문제를 해결하되,  
분할을 좀 더 효율적으로 기준(Pivot)을 잡고 수행하게 된다면  
합병의 과정을 없앨 수 있을 것이다.  

- 방법  
  - Divide - 배열을 피벗(pivot)을 사용하여 이를 기준으로 두 개로 나눈다.  
  - Conquer - 각 서브배열을 정렬한다. 모두 정렬될 때 까지 반복한다.  
  ![quick_sort_algorithm][def10]  

- Correctness Proof  
![quick_sort_correctness][def18]  

- Worst case time complexity  
  - `T(n)` : `n`개의 원소를 정렬하는 데 드는 연산의 수  
  ![quick_sort_time_complexity1][def11]
  ![quick_sort_time_complexity2][def12]  
  
  - Proof  
  ![quick_sort_time_complexity_proof][def19]  

- Average case time complexity  
  - `A(n)` : `n`개의 원소를 정렬하는 데 드는 평균적인 연산의 수  
  ![quick_sort_average_time_complexity](TODO)
  
  - Proof  
  ![quick_sort_average_time_complexity_proof](TODO)  

  <br>

### 5. Arithmetic with Large Integers  
- 정수에 산술 연산을 수행하려고 한다.  

- 그런데 만약 컴퓨터 하드웨어가 표기할 수 있는 최대치를 초과하는 엄청 큰 정수라면 어떻게 해야할까?  

- ***Divide-and-Conquer***가 이에 사용될 수 있다.  

- 메모리에 큰 숫자의 각 자리수를 조각조각 담아 저장하자.  
![big_integer_memory](TODO)  

  - 부호에 대한 정보를 담는 슬롯도 필요할 것이다. (`0` : positive, `1` : negative)  

  - **large_integer**라는 새로운 이름의 타입이 정의되었다.  

  - TODO


<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown=   "1">

이 포스팅은 강원대학교 김도형 교수님의 알고리즘 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details> 

[def]: https://i.imgur.com/6AhXGm2.png
[def2]: https://i.imgur.com/jaN1uB3.png
[def3]: https://i.imgur.com/srwB0DO.png
[def4]: https://i.imgur.com/0G4wJJE.png
[def5]: https://i.imgur.com/QzBytpB.png
[def6]: https://i.imgur.com/Cywj1r6.png
[def7]: https://i.imgur.com/A5vSu9N.png
[def8]: https://i.imgur.com/wfuGI7C.png
[def9]: https://i.imgur.com/MlPdrNl.png
[def10]: https://i.imgur.com/t8OryYv.png
[def11]: https://i.imgur.com/uyLRE6H.png
[def12]: https://i.imgur.com/5D8avKk.png
[def13]: https://i.imgur.com/61hrdne.png
[def14]: https://i.imgur.com/MTXoFHC.png
[def15]: https://i.imgur.com/DFUnnTH.png
[def16]: https://i.imgur.com/hfcjuJu.png
[def17]: https://i.imgur.com/kPV6Eb3.png
[def18]: https://i.imgur.com/MWvP6j3.png
[def19]: https://i.imgur.com/FRtBwE3.png