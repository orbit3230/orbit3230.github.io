---
layout: post
title: "[알고리즘] 4주차 - Dynamic Programming"
excerpt: "Dynamic Programming Intuition, Binomial Coefficient"

tags:
  - [알고리즘, CPP]

toc: true

date: 2024-09-23
last_modified_at: 2024-09-23
---
## Dynamic Programming
### 1. Intuition
- 다이나믹 프로그래밍은 **문제를 최적화**해 해결하는 방법 중 하나이다.  
한 번 이미 계산한 적이 있는 **정보를 기억**해두었다가, 다시 만났을 때 **중복된 계산을 하지 않음**으로서 이득을 얻는 방식이다.  

- Approach
  - **sub-problems들을 한 번 계산**한다.
  - 해당 sub-problems들에 대한 결과를 **테이블에 저장**해둔다.  
  - 이 정보를 기억해 두었다가, **나중에 재사용**한다.  

- Remarks
  - ***공간과 시간 간의 Tradeoff***.  

  <br>

### 2. Binomial Coefficient
- Binomial coefficient  
![binomial_coefficient][def]  
  - factorial(`n!`) 연산을 계속해서 수행하는 것은 무리가 있다.  

- 우선 binomial coefficient의 계산식을 재귀적으로 표현 할 수 있다.  
![binomial_coefficient_recursive][def2]  

#### [1] Divide-and-Conquer
- 우선 위와 같은 재귀적인 표현을 분할 정복으로 해결하는 것을 고려해볼 수 있다.  

```c++
int bin(int n, int k) {
  if(k == 0 || k == n) {
    return 1;
  }
  else
    return bin(n-1, k-1) + bin(n-1, k);
}
```

- 하지만 이는 비효율적이다.  
  - 각 recursive call에서 **중복으로 계산되는 값들이 많이 존재**하기 때문이다.  
  - 한 번 이미 계산한적이 있는 경우, 이를 **기억**해 두었다가 **값만 불러오는 것**이 훨씬 효율적일 것이다.  

#### [2] Dynamic Programming  
- 이러한 **개선 방식이 Dynamic Programming** 이다.  

- 똑같이 재귀 성질을 이용하되, 이번에는 테이블에 이를 **저장**하고 다음 번 계산에서 **재사용**할 것이다.  
따라서 재귀 수식 또한 2차원 배열의 인덱스로 표현할 수 있겠다.  
![binomial_dp_recursive][def4]  

- 이를 dp table로 표현하자면 이렇다.  
![binomial_dp_table][def3]
 
<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown=   "1">

이 포스팅은 강원대학교 김도형 교수님의 알고리즘 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details> 

[def]: https://i.imgur.com/T722PXS.png
[def2]: https://i.imgur.com/QMLBUBp.png
[def3]: https://i.imgur.com/PRAGXij.png
[def4]: https://i.imgur.com/kdsDV3W.png