---
layout: post
title: "[알고리즘] 11주차 - Backtracking"
excerpt: "n-Queens Problem, Monte Carlo Algorithm, Sum of subsets Problem, Graph Coloring Problem"
tags:
  - [알고리즘, CPP]

toc: true

date: 2024-11-14
last_modified_at: 2024-11-18
---
## Backtracking  
- DFS(depth-first search) : a preorder tree traversal 
- BFS(breadth-first search) : a level-order tree traversal  

<br>

### 1. n-Queens Problem  
- `n x n`의 체스판에 `n`개의 Queens를 서로 공격하지 못하게 배치하는 경우의 수를 구하는 문제  

- Backtracking approach
  - 각 rows 순서대로
    - 각 columns에 Queen을 놓을 수 있는 지 확인
      - promising 하다면 : 배치 후 다음 row로 이동  
      - non-promising 하다면 : **pruning** 후 다음 column으로 이동  
      <br>

![n_queen_n_is_4][def]  

<br>

### 2. Monte Carlo Algorithm
- Backtracking Algorithm은 pruning으로 인해 시간 복잡도를 측정하기가 어렵다.  
  - pruning이 얼마나 일어날 지, 그래서 얼마나 자주 실행되는 코드가 줄어드는 지를 알기 어렵기 때문이다.  

  <br>

- **Monte Carlo Algorithm**
  - 특정 instance에 대하여 Backtraking algorithm의 efficiency를 측정하는 방법.  
  - Probabilistic Algorithm.  
  -> 실행되는 다음 instruction이 어떠한 확률 분포에 따라 랜덤하게 결정된다.  
  -> sample space에 기반하여 평균값으로 random variable의 추정치를 계산한다.   
  
  <br>

- 어떻게 측정하는가?  
  - 주어진 instance에서 방문할 노드들로 구성된 트리 내 typical path를 생성한다.  
  - path로부터 노드의 개수를 측정한다.  
  -> 즉, pruned된 상태의 tree 내 노드의 개수를 측정한다.  

- 조건
  - 같은 level의 모든 노드들에 대해서는 같은 promising function이 사용되어야 한다.  
  - 같은 level의 노드들은 같은 수의 children을 가지고 있어야 한다.  

  <br>

- Monte Carlo technique
  - `m`<sub>`0`</sub>을 root의 promising children 개수라고 하자.  
  - level 1 의 promising node를 랜덤하게 생성한다. `m`<sub>`1`</sub>을 이 노드의 promising children 개수라고 하자.  
  - 이 과정을 반복하여 `m`<sub>`i`</sub>를 구한다.  
  -> `m`<sub>`i`</sub> =  level `i`의 **promising children 개수의 평균 측정치**이다.  
  -> `t`<sub>`i`</sub> = level `i`의 총 children 개수  

- Time Complexity Estimation  
`1` + `( t`<sub>`0`</sub>`)` + `( m`<sub>`0`</sub>`t`<sub>`1`</sub>`)` + `( m`<sub>`0`</sub>`m`<sub>`1`</sub>`t`<sub>`2`</sub>`)` + ... + `( m`<sub>`0`</sub>`m`<sub>`1`</sub>`... m`<sub>`i-1`</sub>`)` + `...`  

TODO

<br>

### 3. Sum of subsets Problem
- `n`개의 양의 정수로 이루어진 집합 `S` = `{w`<sub>`1`</sub>`, w`<sub>`2`</sub>`, ... , w`<sub>`n`</sub>`}`와 양수 `W`가 주어졌을 때,  
`S`의 부분집합 중 원소들의 합이 `W`가 되는 경우의 수를 구하는 문제  

- 각각의 경우의 수에 대하여 **넣는다**/**넣지 않는다**의 선택을 할 수 있기 때문에,  
가능한 경우의 수는 `2`<sup>`n`</sup>개이다.  

- 집합 `{4, 2, 5}`와 `W`=`6`이 주어졌다고 해보자.  
  - 집합을 오름차순으로 정렬하면 `{2, 4, 5}`가 된다.  
  - 이에 대하여 search space tree를 생성해보면,  
  ![sum_of_subsets](TODO)  

  <br>

- 이 때, 방문하지 않아도 되는 경우를 pruning 할 수 있다.  
  - promising function  
    - (1) 현재까지의 합 `S`와 `i+1`번째의 weight을 더했을 때 `W`보다 큰 경우  
    `S` + `w`<sub>`i+1`</sub> > `W` -> non-promising  

    - (2) `W`<sub>`t`</sub> = 남은 weights의 총 합일때,  
    `S` + `W`<sub>`t`</sub> < `W` -> non-promising  

- 이렇게 pruning 해보면,  
![sum_of_subsets_pruning](TODO)  

TODO

<br>

### 4. Graph Coloring Problem  
- 방향이 없는 그래프를 `m`개의 색으로 색칠하되,  
인접한 노드들은 같은 색으로 칠하지 않도록 색칠하는 문제.  

- Example  
![graph_coloring](TODO)  
  - 2-coloring -> no solution
  - 3-coloring  
  ![graph_coloring_3](TODO)  
    - 순서에 따라 6가지의 solution이 존재한다.  

    <br>

- Coloring map의 경우도 그래프로 변환 가능하다.  
  - Planar : 두 개 이상의 edge가 서로 교차하지 않도록 그려진 그래프  
  - 모든 map은 planar로 표현될 수 있다.  
  ![coloring_map_to_graph](TODO)  
  
  <br>

- 좀 전에 주어진 그래프에 대하여 state space tree를 그려보자.  
![graph_coloring](TODO)  
![coloring_state_space_tree](TODO)  

<br>

- 이렇게 `m`개의 색상으로 인접한 vertices들이 같은 값을 가지지 않도록  
그래프를 색필하는 모든 방법을 Backtracking으로 구할 수 있다.  
  - Inputs  
    - Positive nunmber `n`, `m`  
    - Adjacency matrix `W`  
    ![adjacency_matrix](TODO)  

  - Outputs  
    - `m`개의 색으로 인접한 두 vertices가 같은 색을 가지지 않도록 하는 모든 경우의 수  
    - case는 배열 `vcolor`에 저장. `vcolor[i]`는 `i`번째 vertex의 색상을 나타낸다.  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown=   "1">

이 포스팅은 강원대학교 김도형 교수님의 알고리즘 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details> 

[def]: https://i.imgur.com/KVdIJWS.png