---
layout: post
title: "[컴퓨터시스템보안] 3주차 - 사용자 인증"
excerpt: "IETF RFC 4949, 사용자 인증, 사용자 인증을 위한 위험 평가, 비밀번호, 카드/토큰, 생체 정보 기반 인증"

tags:
  - [컴퓨터시스템보안]

toc: true

date: 2025-03-24
last_modified_at: 2025-03-27
---
## 사용자 인증(User Authentication)  
- 컴퓨터 보안의 범위  
![range_of_computer_security][def]  

<br>

### 1. IETF RFC 4949  
- **RFC 4949**에서 **사용자 인증**을 다음과 같이 정의한다.  
> "시스템 엔터티에 의해 제기된, 혹은 시스템 엔터티를 위한 **신원 식별 검증 절차**"  

- 인증은 정보 보호의 **기본적인 구성 요소** 이며 주된 방어선

- **접근 제어** 및 **사용자 책임**(user accountability)을 위한 기반  

<br>

- RFC 4949 인증 절차
  - (1) 식별(identification) 단계 : 보안 시스템에 신원을 확인할 수 있는 **식별자(id)**를 제시
  - (2) 검증(verification) 단계 : 각 시스템 개체(entity)와 식별자 간의 관계를 입증하는 **인증 정보**를 제시하거나 생성  

  <br>

### 2. 사용자 인증
- **전자 사용자 인증 구조적 모델**  
![structural_model_of_electronic_user_authentication][def2]  

<br>

- 사용자 id를 인증하는 4가지 수단
  - (1) 개인이 알고 있는 사실을 통한 인증
    - 비밀번호, PIN, 질문에 대한 답변 등  

  - (2) 개인의 소유물을 통한 인증(토큰)  
    - 스마트 카드, 전자 키 카드, 물리적 키 등  

  - (3) 개인의 정적 생체 정보를 통한 인증  
    - 지문, 홍채, 안면 인식 등  

  - (4) 개인의 행동, 즉 동적 생체 정보를 통한 인증  
    - 음성 패턴, 필적, 타이핑 리듬 등  

    <br>

### 3. 사용자 인증을 위한 위험 평가  
- 세 가지 개념
  - (1) **보증 레벨**(Assurance Level) : 인증하려는 사용자의 신원에 대한, 그리고 당사자인지에 대한 신뢰성 정도.
    - 단계
      - 레벨 1 : 확인된 사용자 ID의 유효성이 거의 없음  
      - 레벨 2 : 확인된 사용자 ID의 유효성이 조금 있음
      - 레벨 3 : 높게 확인된 사용자 ID의 유효성  
      - 레벨 4 : 매우 높게 확인된 사용자 ID의 유효성

  - (2) **잠재적 영향** : 개인이나 기관의 보안 침해에 대한 잠재적 영향  
    - 단계
      - 낮음(low) : 제한된 역효과, 사소한 손실
      - 보통(moderate) : 심각한 역효과, 중대한 손실
      - 높음(high) : 치명적인 역효과, 치명적인 손실. 운영 불가능  

  - (3) **위험 영역**

      <br>

- 잠재적 영향과 적절한 보증 레벨의 대응  
![correspondence_between_potential_impact_and_assurance_level][def3]  

<br>

### 4. 비밀번호
- **비밀번호(password) 기반 인증**
  - 가장 널리 사용되는 침입자 방어 수단
    - 사용자는 **이름 또는 로그인 id**와 **비밀번호**를 제시
    - 제시된 로그인 id에 대한 비밀번호와 시스템에 저장된 비밀번호를 비교

  - 사용자 ID
    - 사용자가 시스템에 접근이 허가되었는 지를 확인
    - 사용자의 권한 결정
    - 자유재량 접근 제어(discretionary access control)에 사용  

    <br>

- **비밀번호의 취약성**
  - 오프라인 사전(dictionary) 공격
  - 특정 계정 공격
  - 사용자들이 사용하는 잘 알려진 비밀번호 공격
  - 단일 사용자에 대한 비밀번호 추측
  - 워크스테이션 하이재킹(hijacking)  
  - 사용자의 실수 이용
  - 다수의 장치에서 단일 비밀번호를 사용
  - 네트워크 모니터링을 통한 비밀번호 도청  

<br>

- **비밀번호 취약성 대응책**
  - 비밀번호 파일에 인가되지 않은 접근 통제
  - 노출된 비밀번호에 대한 빠른 재발급 조치
  - 계정 폐쇄 - 일정 시도 횟수 실패 시
  - 단순한 비밀번호 사용 금지 정책
  - 비밀번호 정책 강화
  - 워크스테이션 자동 로그아웃
  - 사용자 교육, 침입 탐지, 다른 인증 메커니즘과 결합
  - 네트워크 장치들에서 유사한 단일 비밀번호의 사용을 제한  

  <br>

- **Unix Password Scheme**  
![unix_password_scheme][def4]  
  - 초기 비밀번호 구현
    - 8개 이내의 문자들로 구현 -> 총 56비트를 구성하여 암호 알고리즘의 키로 사용  
    - 12비트 솔트(salt)를 사용하고, DES 알고리즘에 기반한 단 방향 해시 함수 사용  
    - 의도적으로 속도를 느리게 한 Slow hash function  
    - 최종 출력을 11자리 문자열로 변환  
    -> 그러나 이 방식은 현재는 적절하지 못한 방법이다.  

  - Unix 비밀번호 구현 기법의 개선  
    - (1) 훨씬 강력한 Unix용 해시/솔트 기법  
    - (2) MD5에 기반한 해시 함수 권장  
      - 48비트 솔트 / 128비트 해시 값 / 패스워드 길이 제한 X / 더 느린 해시 함수  
    - (3) OpenBSD는 Bcrypt(Blowfish 알고리즘)를 사용
      - 128비트 솔트 / 192비트 해시 -> 가장 안전한 버전  

      <br>

- **비밀번호 크랙킹 (Cracking)** 
  - **사전 공격** (dictionary attck)
    - 가능한 비밀번호 dictionary를 제작하고, 적용해보며 해독하는 방법  
    - 각 단어에 대해 솔트를 적용하여 해시 값을 구하고 비교  

  - **레인보우 테이블 공격**  
    - `{모든 가능한 비밀번호, 비밀번호 파일의 모든 솔트}` 쌍에 대한 **해시 값 테이블** 생성  
    - 이는 충분히 큰 솔트 값 / 충분히 긴 해시를 사용해 대처 가능하다.  

  - **쉽게 기억할 수 있는 비밀번호**를 선택하는 점을 이용  

<br>

- **비밀번호 파일 접근 제어** : 암호화된 비밀번호 파일에 대한 접근을 거부함으로써 guessing attacks를 막을 수 있음  
  - 취약점
    - 파일 접근을 허가하는 OS의 취약점  
    - 접근 권한을 변경하는 우연한 보안 사고  
    - 다른 시스템에서 같은 비밀번호를 사용하는 사용자
    - 비밀번호 백업 미디어 접근
    - 네트워크 트래픽에서 비밀번호 sniffing

  - 접근 제어 방법
    - 권한을 지닌 사용자 만이 이용 가능  
    - Shadow 비밀번호 파일 : 분리된 별도의 파일에 해시된 비밀번호 보관  

    <br>

- **비밀번호 선택 전략**
  - 사용자 교육 -> 유추하기 어려운 비밀번호 사용의 중요성 교육
  - 컴퓨터 생성 비밀번호 -> 단, 사용자는 기억하기 어려움.
  - 반응적 비밀번호 확인 전략 : 사후 비밀번호 검사 -> 주기적으로 자체 비밀번호 크래커 실행  
  - 복잡한 비밀번호 정착 : 사전 예방적인 비밀번호 검사 -> 처음부터 유추하기 쉬운 비밀번호는 허가 X  

  <br>

- **사전 비밀번호 검사**
  - 비밀번호 크래커 : 사용하지 말아야 하는 비밀번호를 수집, Dictionary 생성
  - 규칙 집행 : 비밀번호 생성 시 지켜야 하는 특정한 규칙 정의
  - 블룸 필터 (Bloom Filter)
    - `k`개의 해시 함수를 사용하여 비밀번호 거절 테이블 생성
    - 비밀번호가 거절 테이블에 있는지 확인  
    - Bloom Filter의 성능  
    ![bloom_filter_performance][def5]  

    <br>

### 5. 카드/토큰
- **메모리 카드**
  - 데이터 저장은 가능하지만, 처리는 불가능
  - 가장 일반적인 방식은 전자기 띠 카드
  - 내부에 **전자 메모리**를 내장
  - 단독으로 사용될 수 있지만(호텔 방 키, ATM), 비밀번호나 PIN과 결합하면 더 높은 보안성  
  - 단점
    - 특정한 Reader를 요구
    - 카드 분실 가능성
    - 사용자의 불편

- **스마트 토큰**
  - 물리적 특징
    - **마이크로 프로세서**를 내장
    - 은행 카드와 비슷한 스마트 토큰
    - 외형은 여러 종류 (계산기, 열쇠, portable...)
  - 인터페이스
    - UI는 사용자 상호작용을 위한 키 패드와 디스플레이로 구성
    - 호환 가능한 reader/writer와의 통신을 위해 전자적 인터페이스를 요구 (접촉형, 비접촉형)
  - 인증 프로토콜 - 사용자 인증 시
    - 정적 비밀번호 생성기 : 사용자->토큰으로 자신을 인증, 토큰->컴퓨터로 사용자를 인증
    - 동적 비밀번호 생성기 : **주기적**으로 비밀번호 생성 (like OTP), 해당 비밀번호는 수동/전자적으로 컴퓨터에 입력, 토큰과 컴퓨터 시스템은 **동기화**가 유지되어 비밀번호를 알고 있음
    - 시도-응답(challenge-response) : 컴퓨터 시스템이 **시도**(무작위 수)를 생성하고, 토큰이 **응답**을 생성, 컴퓨터 시스템이 응답을 검증   

    <br>

- **생체 정보 기반 인증**
  - 신체 고유의 특징을 바탕으로 개개인을 인증하려는 시도
  - **패턴 인식** 기술에 기반
  - 다른 방식에 비해 기술적으로 복잡하고, 비용이 높음  
  - 이용 가능한 방식 : 얼굴(facial), 지문(fingerprints), 손 모양(hand geometry), 망막 패턴(retinal pattern), 홍채(iris), 서명(signature), 음성(voice)  
  ![biometric_authentication][def6]  
  - 동작 방식 (등록/검증/인증)  
  ![biometric_authentication_process][def7]  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 이헌길 교수님의 컴퓨터시스템보안 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/kXNvJ94.png
[def2]: https://i.imgur.com/OQIdKvA.png
[def3]: https://i.imgur.com/UxvuHzG.png
[def4]: https://i.imgur.com/zzNteM1.png
[def5]: https://i.imgur.com/vl2fPcz.png
[def6]: https://i.imgur.com/NhdgoXn.png
[def7]: https://i.imgur.com/AlOytYS.png