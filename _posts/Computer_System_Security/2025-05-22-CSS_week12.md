---
layout: post
title: "[컴퓨터시스템보안] 12주차 - 소프트웨어 보안"
excerpt: "소프트웨어 보안 이슈, 프로그램 입력 다루기, 안전한 프로그램 코드 작성하기, 운영체제와 다른 프로그램 간의 상호작용, 프로그램 출력 다루기"

tags:
  - [컴퓨터시스템보안]

toc: true

date: 2025-05-22
last_modified_at: 2025-05-26
---
## 소프트웨어 보안
### 1. 소프트웨어 보안 이슈
- SW의 많은 취약점들이 **허술한 프로그래밍 습관**으로부터 초래된다.
- 취약점은 데이터와 오류 코드에 대한 **불충분한 검사/검증 작업**에 대한 outcome

- 소프트웨어 오류 범주
  - 구성 요소들 간의 안전하지 않은 상호작용
  - 위험한 자원 관리
  - 허점이 많은 방어

<br>

- [CWE/SANS Top 25][def]  

<br>

- **소프트웨어 보안(Security) vs. 품질(Quality)&신뢰성(Reliablity)**
  - 소프트웨어 보안
    - 공격자는 실패를 유발하는 **특정 버그를 목표**
    - 버그는 **테스트로 찾기 어려운 입력에 의해 발생**
    - 안전한 코드의 작성은 **가능한 모든 오류의 검사**

  - 소프트웨어 품질 & 신뢰성
    - **프로그램의 우연한 실패**에 Focus
    - 품질 향상을 위해 **구조적 설계**를 사용하고 오류 제거를 위해 **테스트를 수행**
    - 버그의 최소화는 단순 버그의 수가 아니라, **프로그램의 Failure를 야기하는 버그의 수**에 초점  

    <br>

- **방어적 프로그래밍**(Defensive programming)
  - 공격을 받는 상황에도 지속적으로 동작하도록 설계하고 구현하는 절차
  - 실행 방법, 실행 환경, 처리하는 데이터 타입 등의 **모든 관점**에서 주의를 요구
  - 공격으로 인한 오류 상황을 탐지하여 **안전하게 실행을 이어나가거나**, **안전하게 멈추도록** 하는 것
  - also called as "Secure programming"(안전한 프로그래밍)
  - **아무 것도 가정하지 않고, 모든 가정(상황)을 체크하며, 발생 가능한 모든 에러를 처리**

  - Abstract View of Program  
  ![Abstract View of Program][def2]  

  - 보통 프로그래머는 프로그램이 받을 **입력 타입**과 **환경**에 대해 가정을 함
    - 이 **가정**은 **검증**되어야 하고, **모든 가능한 실패를** 적절하고 안전하게 처리해야 함.
  - **실행 성공**에 집중하는 전통적 프로그래밍 관습에 대해 **사고 방식의 변화**를 요구
    - 프로그래머는 **어떻게** 실패가 발생하는 지와, **실패 가능성**을 줄이는 데 필요한 단계를 **이해**해야 함
  - 방어적 프로그래밍은 이익 극대화와 개발 시간을  줄이려는 **비즈니스 목표와 Conflict**
    - 보안을 설계 목표로 하는 것이 접차 중요

<br>

### 2. 프로그램 입력 다루기
- 프로그래머는 **입력의 최대 크기를 가정**
  - 버퍼 오버플로우를 초래

- 테스트가 버퍼 오버플로우 취약점을 식별하지 못할 수 있음
  - 오버플로우를 유발할 만큼의 큰 입력을 테스트하지 않을 수 있음

- 안전한 프로그래밍은 **모든 입력을 위험하다고 간주**하고, 모든 입력을 검사해야 함

- 프로그램 입력은 **바이너리**나 **텍스트**가 될 수 있음
  - 바이너리 값의 해석은 프로그램에 따라 다름

- 사용되는 **문자 집합**이 점차 다양해지고 있음
  - 어떤 문자 집합이 사용되고, 어떤 문자를 읽은 것인 지 주의 깊게 확인 필요

- **입력의 의미**를 확인해야 함
  - 입력이 정수, 실수, 파일이름, URL, 이메일 주소 등일 수 있음
  - 이 입력이 실제로 기대한 데이터를 의미하는 지 확인해야 함
  - 이 작업이 실패할 경우, 취약점과 심각한 결과를 초래할 수 있음

<br>

- **삽입(주입) 공격**(Injection attack)
  - **입력 데이터**가 **프로그램 실행 흐름에 영향**을 미치는 공격
  - 입력 데이터의 잘못된 처리와 관련된 다양한 취약점과 관련
  - 흔한 원인 중 하나는 **입력 데이터가 시스템의 다른 프로그램 인자로 전달됙고, 출력이 원래 프로그램에서 사용되는 경우**
  - 스크립팅 언어(Perl, PHP, Python, sh)에서 많이 발생  
  - e,g., 안전하지 않은 Perl finger CGI script  
  ![unsafe_perl_script][def3]  
  - Finger form  
  ![finger_form][def4]  
  - 정상적인 finger CGI Response와 공격 당한 finger CGI Response  
  ![finger_response][def5]  
  - Perl finger CGI script의 안전한 extension  
  ![safe_perl_script][def6]  

<br>

- **SQL 삽입 공격**(SQL injection attack)
  - 사용자가 제공한 입력이 **SQL request**의 일부로 사용되는 경우
  - **SQL 메타 문자**를 사용  
    - e.g., `"Ronaldo'; drop table suppliers"`
  - 반드시 **사용자가 제공한 입력**을 **검증**
  - SQL Injection Vulnarable PHP Code Example  
  ![sql_injection_php_code_example][def7]  

  <br>

- **코드 삽입 공격**(Code injection attack)
  - 입력 데이터에 공격 대상 시스템이 실행할 코드를 삽입
  - e.g., 버퍼 오버플로우 -> 기계어 코드인 쉘 코드 삽입
  - 스크립트 언어 코드 삽입 Example - PHP **원격 코드 삽입** or **PHP 파일 포함** 취약점  
  ![php_remote_code_injection][def8]  
  - 방어
    - **form field**의 값을 **전역 변수**에 할당하는 것을 차단
    - `include`/`require` 명령어에 **상수 값**만을 사용  

    <br>

- **교차 사이트 스크립팅(XSS) 공격**(Cross-site scripting attack)
  - 한 사용자가 제공한 입력을 다른 사용자에게 출력하는 공격
  - 주로 스크립트로 작성된 웹 애플리케이션에서 발견
    - HTML 문서에 **스크립트 코드(e.g, JavaScript)**를 포함하여 생긴 취약점
    - 스크립트 코드는 **현재 페이지와 관련된 데이터(e.g., 쿠키)**에 접근할 수 있음 -> 보안 문제
    - 브라우저는 보안 점사를 시행하고, 데이터의 접근을 동일 사이트에만 제한해야 함
  - 사이트 내 컨텐츠들은 서로 신뢰하여 상호작용 -> 이를 이용하여 다른 사이트 접근 권한을 획득하기 위해 브라우저의 보안 감사를 회피
  - XSS 반사(reflection) 공격
    - 사이트에서 제공하는 **데이터**에 **악성 스크립트 코드**를 삽입  

  - Example of XSS attack  
  ![example_of_xss_attack][def9]  
    - **사용자의 쿠키**가 **공격자**에게 제공, 원래 사이트 사용자처럼 Assume
    - 이러한 공격 방어를 위해서는 입력 검사 & 위험한 코드 실행 방지

  - 동작 원리  
  ![xss_attack_working_principle][def10]  

<br>

- **입력 문법 검증하기** (Validating Input Syntax)
  - 프로그래머가 제어할 수 없는 입력 데이터에 대해 **가정과 부합하는 지** 확인 필요 (Regex 사용)
  - 원칙 1 : 오직 **유효한 입력**만을 허용 (안전한 데이터)
  - 원칙 2 : 입력 데이터로 **위험하다고 알려진 값**과 비교
  - 알려진 **안전한 데이터**만을 수용함으로써 안전하게 유지 가능  

<br>

- **숫자 입력 검사** (Validating Numeric Input)  
  - 입력 데이터가 **숫자**인 경우, 추가적인 검사 필요
  - 숫자는 내부적으로 **고정된 크기**의 값으로 저장됨
  - 텍스트 형태를 정확하게 해석하고 일관성 있게 처리해야 함
    - Signed vs. Unsigned
    - 버퍼 오버플로우 검사를 무력화 하는 지 확인 (버퍼 크기 비교 시 오버플로우로 통과)  

    <br>

- **입력 퍼징**(Input Fuzzing)
  - **무작위로생성한 데이터**를 프로그램의 입력으로 사용하는 **소프트웨어 테스트 기법**
    - 매우 큰 입력 범위
    - **비정상적인 입력**을 올바르게 처리하는 지, 아닌 지를 확인
    - 장점 : 저렴하고 자유로운 테스트, 보안 결점 발견 가능성
    - 단점 : 간단한 결함에는 유용하지만, 매우 특정한 몇몇 입력 값에 대한 버그는 발견하지 못할 수 있음
  - 무작위 입력이 아닌, **템플릿**에 따라 생성할 수도 있음
    - **버그를 유발한다고 알려진 입력 값**들을 생성
    - 단점 : 다른 형태의 입력에 대한 버그를 놓칠 수 있음
    - 따라서 다른 방법과 결합하여 사용하는 것이 좋음

<br>

### 3. 안전한 프로그램 코드 작성하기
- 주요 SW 보안 이슈들
  - **올바른 알고리즘**의 구현
  - **기계어 코드와 알고리즘의 일치** 여부
  - **데이터 값의 조작**이 유효한 지 여부

  <br>

#### [1] 알고리즘의 올바른 구현
- 좋은 프로그램 개발 기법의 이슈
  - 알고리즘이 **문제의 모든 경우**를 올바르게 구현하지 못할 수 있음
  - 알고리즘의 결점은 **프로그램의 결함**으로 이어질 수 있음

- 많은 TCP/IP 구현에서 사용되는 **초기 시퀀스 번호**(sequence number)의 예측이 매우 쉬움
  - 세션 키 생성에 사용된 **난수 발생기의 잘못된 구현** -> 키 예측 가능
  - **TCP 세션 하이재킹** : 패킷의 **식별자와 인증 정보**로 시퀀스 번호를 사용

- 프로그래머가 **테스트 및 디버르를 돕는 추가 코드**를 삽입할 때 문제 발생
  - 테스트/디버깅용 코드를 부주의하게 제거하지 않음
  - 보안을 우회할 수 있도록 하고, 허용되지 않은 작업을 수행할 수 있음
  - **sendmail**에서 DEBUG 명령 코드를 남겨 **모리스 웜**에서 악용한 사례

<br>

#### [2] 기계어 코드와 알고리즘의 일치 여부
- 프로그래밍 언어로 표현된 **알고리즘**과 이를 구현하는 **기계어 코드**가 일치하는 지 확인해야 함.
  - 컴파일러 또는 인터프리터가 동작을 **가정**하기 때문에 발생하는 문제

- 악의적인 **컴파일러 프로그래머**가 특정 입력 문장을 해석할 때 **악성 코드를 삽입**하도록 할 수 있음
  - 변경 내용을 찾으려면 기계어 코드와 원본 소스를 비교해야 함. (slow and difficult)

<br>

#### [3] 데이터 값의 조작이 유효한 지 여부
- **데이터 값의 올바른 해석**
  - 컴퓨터에 **비트/바이트**로 저장된 데이터
    - **메모리**에서 직접 접근하거나, **프로세서의 레지스터**로 복사
    - **해석**은 기계어 코드에 따라 달라짐

  - 변수에 저장된 데이터 해석에 대해서는 언어 별로 다른 기능을 제공
    - `C++`나 `Java`는 **강한 타입**을 지원하여 사용이 제한, 안전
    - `C`는 데이터의 해석에 더 자유롭고, 프로그램 코드가 해석을 명시적으로 변경할 수 있게 허용 (형변환)  
    
    <br>

- **메모리의 올바른 사용**
  - 프로세스 힙을 사용하는 **동적 메모리 할당**에서 발생하는 문제
    - 동적 메모리는 **필요 시 할당**되고, **끝나면 반납** 되어야 합
  
  - **메모리 누수**
    - 메모리를 제때 반납하지 않아 힙의 가용 영역이 소진 -> **Denial of Service**(DoS) 공격 가능

  - `C`는 명시적인 동적 메모리 지원 X
    - **표준 라이브러리 루틴** 사용

  - `Java`는 **가비지 컬렉션**을 사용하여 동적 메모리를 명시적으로 반납하지 않아도 됨

  <br>

#### [4] 공유 메모리의 경합 조건 방지 (Race Condition)
- **공유 메모리**에 대한 적절한 **동기화**가 필요
  - 그렇지 않다면 값이 손상되거나 변경 내용이 손실될 수 있음

- 공유 자원에 통제되지 않은 접근을 위해 서로 경쟁 -> **Race Condition** 발생
  - 적절한 **동기화 함수**를 올바르게 사용하여 해결

- **교착상태**(Deadlock)
  - 프로세스나 스레드가 서로가 가진 자원을 계속 기다리는 상태
  - **서비스 거부 공격**(DoS)에 악용될 수 있음

<br>
  
### 4. 운영체제와 다른 프로그램 간의 상호작용
- 프로그램은 **운영체제의 제어**를 받으며 실행
  - 운영체제는 리소스에 대한 **접근을 중재**, 프로그램들 사이에 **리소스를 공유**하도록 함
  - 프로세스를 위한 **실행환경**을 구축
  
- 일반적으로 시스템은 **다중 사용자** 개념을 지원
  - 리소스에는 **접근 권한**이 존재
  - 적절한 접근 권한 수준을 부여하는 것이 중요

<br>

- **환경 변수**(Environment variable)
  - 각 프로세스가 부모로 부터 상속 받은 String 값의 집합
  - 프로그램은 자신의 프로세스의 환경 변수를 수정할 수 있음
  - 다양한 운영체제에서 사용
    - `PAYH`, `IFS`, `LD_LIBRARY_PATH` 등
  - 환경 변수는 **신뢰할 수 없는 데이터를 입력하는 또 다른 경로**를 제공할 수 있음
  - **root escalation** 공격에 사용될 수 있음
  - Vulnerable Shell Scripts  
  ![vulnerable_shell_scripts][def11]
    - 사용자의 입력을 입력받아 매핑된 IP 주소를 찾음
    - `sed`, `grep` 명령어 실행을 위해 `PATH` 참조
    - `PATH` 변수를 변경하여 공격자의 `grep` 프로그램을 ㄹ호출하도록 조작  
      -> Solution : **절대 경로**를 사용하거나 `PATH` 변수를 잘 알려진 기본 값으로 리셋

      <br>

- **취약성을 가진 컴파일된 프로그램**
  - 쉘 스크립츠 응용이 필요하다면, **컴파일된 Wrapper 프로그램** 사용이 좋음
  - 그러나, 이 또한 높은 권한으로 실행된다면 `PATH` 변수 조작에 취약할 수 있음
    - 모든 **중요한 환경 변수**는 반드시 안전한 값으로 리셋해야 함.
  - 동적으로 링크되었을 경우 `LD_LIBRARY_PATH` 변수 조작에도 취약할 수 있음
    - 동적 라이브러리를 위치하는데 사용되는 변수
    - 정적으로 링크하거나, 이 환경 변수의 사용을 차단

    <br>

- **적절한 최소의 권한 사용하기**
  - **권한 상승** (privilege escalation) : 프로그램 결함을 악용하여 공격자에게 **더 높은 권한 부여**
  - **최소 권한 원칙** (principle of least privilege) : 프로그램이 작업을 완수하는 데 **필요한 최소한의 권한**으로 실행
  - 특권을 가진 프로그램이 실행될 때 마다 **적절한 사용자/그룹 권한**을 주의해서 결정
  - 특권을 가진 프로그램은 오직 **필요한 파일과 디렉토리만 변경**

  <br>

- **루트/관리자 권한 획득 공격**
  - **루트/관리자 권한을 지닌 프로그램**들은 주요 공격 목표
  - Solution
    - 작은 **모듈로 분할**하여 설계 (독립성 제공)
    - 권한을 필요한 동안만 허용

<br>

- **시스템 호출(System call)과 표준 라이브러리 함수**
  - 일반적으로 프로그램은 리소스 접근을 위해 **System call** 또는 **표준 라이브러리 함수**를 사용
  - 프로그래머들은 보통 System call의 동작을 올바르다고 가정
    - 프로그램의 오류는 **공유 자원에 대한 접근 최적화에서 발생**했을 수 있음

<br>

- **안전한 파일 삭제**
  - 표준 파일 삭제 유틸리티 or System call : 파일 이름과 내용 간 연결만 끊음
    - 파일 내용은 디스크 블록에 남아있음 -> **undelete** 가능
  - 원래 데이터의 복구가 불가능하도록 안전한 파일 삭제 필요
  - 표준 권고안의 결함
    - 쓰기 모드로 파일 오픈 시 : 새로운 디스크 블록을 할당하여 쓰기 -> **Update 모드로 파일 오픈**
    - 버퍼링에 의한 실제 쓰기 지연 문제
  - 안전한 파일 삭제 프로그램  
  ![safe_file_delete_program][def12]  

<br>

### 5. 프로그램 출력 다루기

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 이헌길 교수님의 컴퓨터시스템보안 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://cwe.mitre.org/top25/archive/2024/2024_cwe_top25.html
[def2]: https://i.imgur.com/fSGr9g9.png
[def3]: https://i.imgur.com/7oMzOKV.png
[def4]: https://i.imgur.com/BBYRUJ2.png
[def5]: https://i.imgur.com/z7pRMp3.png
[def6]: https://i.imgur.com/30Xy0hj.png
[def7]: https://i.imgur.com/tIeFiNT.png
[def8]: https://i.imgur.com/rv3LLPI.png
[def9]: https://i.imgur.com/daxVGWp.png
[def10]: https://i.imgur.com/4TCiBgO.png
[def11]: https://i.imgur.com/nwtTxd1.png
[def12]: https://i.imgur.com/AnFV08T.png