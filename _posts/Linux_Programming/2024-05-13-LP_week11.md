---
layout: post
title: "[리눅스 프로그래밍] 11주차 - Makefile"
excerpt: ""

tags:
  - [리눅스 프로그래밍]

toc: true

date: 2024-05-13
last_modified_at: 2024-05-13
---
## Makefile
- 소스파일로부터 executable 파일을 만드는 도구  
(a.k.a. build automation tool)

- 장점
  - 소스파일이 변경되어 업데이트 되었을 때,  
  모든 프로그램을 재 컴파일할 필요가 없다.  
  업데이트된 파일만 자동적으로 파악하여, 그것만 재 컴파일한다.  

  - 매우 많은 파일들로 구성된 Large-scale 프로그램이 `Make` utility로 쉽게 관리된다.  

- Usage
  - `$ make [-f makefile_name]`
    - 이름을 생략하면 기본적으로 `Makefile` 라는 이름으로 취급한다.   

  <br>

### 1. 구성요소  
- targetList : a list of object file(or excutable)  

- dependencyList : a list of files that have interdependencies on targetList  

- commandList
  - a list of commands to generate object files
  - 각 line 들은 tab으로 시작해야한다.  

<br>

### 2. 작성방법
- 첫 번째 target은 tree의 root 여야 한다.  
- 다음 target은 그것의 sub-children 에 대한 것이다.  

```makefile
CC = gcc
PROGRAM = operation

all: $(PROGRAM) # conventail (unnecessary)

operation: operation_main.o operation_plus.o operation_minus.o
    $(CC) -o $@ operation_main.o operation_plus.o operation_minus.o

operation_main.o: operation_main.c operation_main.h
    $(CC) -c operation_main.c

operation_plus.o: operation_plus.c operation_plus.h
    $(CC) -c operation_plus.c

operation_minus.o: operation_minus.c operation_minus.h
    $(CC) -c operation_minus.c

clean:
    rm ./$(PROGRAM) ./*.o
```

- Makefile 에서도 변수의 개념이 존재한다.  
  - 선언 : `변수명 = 값`
  - 참조 : `$(변수명)`

- 아래에서부터 읽어나간다. (실행 순서)  

<br>

## Linux Programming
### 1. Linux Structure  
![linux_structure](https://i.imgur.com/EvkA2WO.png)
- Hardware
  - CPU, Memory, Disk, Peripherals  

- Kernel
  - kernel
  - Process management
  - File management
  - Memory management
  - Device management

- System call
  - The programmer's functional interface to the Linux kernel

- Commands, Utilities, Application programs
  - Kernel services using library routines or system call
    - System calls
      - TODO
      - e.g., `read()`, `write()`
    
    - Library calls
      - TODO
      - e.g., `fread()`, `fwrite()`

### 3. User Mode vs Kernel
- System call interface vs System call handler
TODO

- tracer
  - `strace` -> syscall tracer
  - `ltrace` -> a call tracer  

### 4. I/O
- C I/O Library Functions
  - Input function -> `read()` system call
    - Standard input function
        - `scanf()`, `getchar()`
    - Standard file input function
        - `fscanf()`, `fgets()`, `fgetc()`
  <br>
  - Output function -> `write()` system call
    - Standard output function  
        - `printf()`, `putchar()`
    - Standard file output function
        - `fprintf()`, `fputs()`, `fputc()`

<br>

- File I/O
  - TODO

<br>

### 5. File
- What is a file?
  - contiguous sequence of bytes.
  - Not format imposed by the operating system, but by applications.
  - Each byte is individually addressable in a disk file.  

  <br>

- File Descripter
  - `open()` returns an **fd** (integer value, 3 ~ )
    - `0` : Standard input
    - `1` : Standard output
    - `2` : Standard error output
    - `3` ~ `1024` : **fd**s for users
  - `close(fd)` closes that file described by **fd**
    - 모든 프로세스에서 열린 파일들은,  
    프로세스가 끝날 때 자동적으로 모두 close 된다.  

- File-related System calls
  - `open()`
  - `close()`
  - `read()`
  - `write()`
  - `lseek()` -- move within file

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 리눅스 프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>