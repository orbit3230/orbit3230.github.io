---
layout: post
title: "[프로그래밍 언어] 2주차 (1) - Rust 프로그래밍 컨셉 & 소유권 이해"
excerpt: "변수와 가변성, 데이터 타입, 함수 동작 원리, 주석, 제어문, 참조, 대여, 슬라이스 타입"

tags:
  - [프로그래밍 언어, Rust]

toc: true

date: 2025-03-12
last_modified_at: 2025-03-12
---
## 기본 프로그래밍 컨셉 이해
### 1. 변수와 가변성
- Rust에서 변수는 `let` 키워드로 선언한다.
  - By default, 선언된 변수는 ***Immutable***
  - 이는 의도치 않은 변수 값 변경을 방지한다.  

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {x}");
  x = 6; // Error!
  println!("The value of x is: {x}");
}
```

- `mut` 키워드를 추가하여 가변 변수로 선언할 수 있다.  

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {x}");
  x = 6; // OK!
  println!("The value of x is: {x}");
}
```
<br>

- 상수(Constant)  
  - `const` 키워드를 사용  
  `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`  

  - 변경이 허용되지 않는 값  
  
  - 타입을 반드시 명시해야 함  
  `const CONSTANT_VALUE_1: i32 = 1;`  

  - `mut` 키워드 사용 불가  
  `const mut CONSTANT_MUT_VALUE: i32 = 2;` -> *ERROR*  

  - 런타임에서 결정되는 값 사용 불가  
  `const CONSTANT_VALUE_2: i32 = x;` -> *ERROR*  

  <br>

- Shadowing : 같은 이름의 새 변수 선언  

```rust
fn main() {
  let x = 5;
  let x = x + 1;
  {
    let x = x * 2;
    println!("The value of x in the inner scope is: {x}");
  }
  println!("The value of x is: {x}");
}
```

- Shadowing의 경우 `mut`과는 달리 변수의 타입을 변경할 수 있다.  

```rust
fn main() {
  let mut spaces = "   ";
  spaces = spaces.len(); // Error!
}
```

```rust
fn main() {
  let spaces = "   ";
  let spaces = spaces.len(); // OK!
}
```

<br>

### 2. 데이터 타입
- Rust는 타입이 고정된 언어  
  - 컴파일 시 변수의 타입을 반드시 알 수 있어야 함.  
  - 다양한 타입이 선택될 수 있는 경우 타입을 명시해야 함.  

  <br>

#### [1] 정수형 타입
- arch는 32bit/64bit에 따라 달라짐  
- 가독성을 위해 `_` 사용 가능  

|Length|Signed|Unsigned|
|:---:|:---:|:---:|
|8-bit|`i8`|`u8`|
|16-bit|`i16`|`u16`|
|32-bit|`i32`|`u32`|
|64-bit|`i64`|`u64`|
|128-bit|`i128`|`u128`|
|arch|`isize`|`usize`|

|Number literals|Example|
|Decimal|`98_222`|
|Hex|`0xff`|
|Octal|`0o77`|
|Binary|`0b1111_0000`|
|Byte(u8 only)|`b'A'`|

<br>

#### [2] 부동소수점 타입
- `f32`, `f64`(by default)  

```rust
fn main() {
  let x = 2.0; // f64
  let y: f32 = 3.0; // f32
}
```

<br>

- 변수 선언 시 계산된 값을 기준으로 타입이 정해짐.  
TODO  

<br>

#### [3] Boolean 타입  
TODO  

<br>

#### [4] 문자열 타입  
TODO  

<br>

#### [5] Tuple 타입  
- 다양한 타입을 하나의 복합 타입으로 만드는 방법  

```rust
fn main() {
  let tup: (i32, f64, u8) = {500, 6.4, 1};

  let (x, y, z) = tup;  

  println!("The value of y is: {}", y);
}
```  

<br>

- 튜플 내부 값은 `.index`로 접근 가능  

```rust
fn main() {
  let tup = (500, 6.4, 1);

  let five_hundred = tup.0;

  let six_point_four = tup.1;

  let one = tup.2;
}
```

<br>

#### [6] 배열 타입  
TODO  

  <br>

<br>

### 3. 함수 동작 원리
- 함수는 `fn` 키워드로 선언  

```rust
fn main() {
  println!("Hello, world!");

  another_function();
}
fn another_function() {
  println!("Another function.");
}
```

<br>

- 모든 Parameter는 타입 정의 필요  

```rust
fn main() {
  another_function(5);
}
fn another_function(x: i32) {
  println!("The value of x is: {}", x);
}
```

- 여러 개의 Parameter는 쉼표로 구분  

```rust
fn main() {
  another_function(5, 6);
}
fn another_function(x: i32, y: i32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

- 함수의 Return
  - `->`를 사용하여 Return 값의 타입을 명시
  - 세미콜론(`;`)이 없는 마지막 expression을 Return  

```rust
fn main() {
  let x = add(5, 6);
  println!("The value of x is: {x}");
}
fn add(x: i32, y: i32) -> i32 {
  x + y
}
```

- 단, 값을 미리 반환하려면 `return` 문으로 명시  

```rust
fn demo_fn(x: i32) -> i32 {
  if x == 0 {
    return -1;
  }
  x
}
```

<br>

- 블록 표현식 : 블록에서 값을 반환  

```rust
fn main() {
  let x = 5;
  
  let y = {
    let x = 3;
    x + 1
  };

  println!("The value of y is: {}",  y);
}
```

<br>

### 4. 주석
- `//` : 한 줄 주석  

```rust
// Isn't it boring, right?
```

- `/* */` : 여러 줄 주석  

```rust
/*
  Isn't it boring,
  right?
*/
```

<br>

### 5. 제어문
#### [1] `if` 표현식  
TODO  

<br>

#### [2]  `loop`문  
- 무조건 반복  

```rust
fn main() {
  loop {
    println!("again!");
  }
}
```

<br>

#### [3] `while`문
- 조건부 반복  

```rust
fn main() {
  let mut number = 3;
  while number != 0 {
    println!("{}!", number);
    number = number - 1;
  }
  println!("LIFTOFF!!!");
}
```  

<br>

#### [4] `for`문  
- 방법 1 : `for` .. `in` (`for each`)  
  - 단, Tuple은 Element type이 다를 수 있어 불가능하다.  

```rust
fn main() {
  let a = [10, 20, 30, 40, 50];
  for element in a {
    println!("The value is: {element}");
  }
}
```  

<br>

- 방법 2 : `range` 사용  

```rust
fn main() [
  for number in (1..4).rev() {
    println!("{number}!");
  }
  println!("LIFTOFF!!!");
]
```

## 소유권
- 소유권 : Rust 프로그램이 메모리를 관리하는 규칙  

- 소유권 규칙
  - (1) 모든 Rust의 값에는 소유자가 있다.
  - (2) 단 하나의 소유자만이 존재할 수 있다.  
  - (3) 소유자가 scope를 벗어나면 값은 삭제된다.  

<br>

- Rust는 다른 특정 언어들과 달리 Garbage Collector가 없다.  
  - 대신, 소유권 규칙을 통해 더 이상 사용되지 않는 경우 메모리를 해제한다.
  - 컴파일 단계에서 소유권에 대한 확인이 이루어진다.  

<br>

- `String` 타입
  - heap 메모리에 저장된다.
  - 일반 문자열과 달리 수정 가능하다.  

  ```rust
  fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!");  // string concatenation
    println!("{s}");
  }
  ```

  - Scope에서 벗어날 시 자동으로 메모리 할당 해제  

  ```rust
  {
    let s = String::from("hello");
    // do something with s
  }
  // scope over, s is no longer valid
  ```

  <br>

- 변수와 데이터 간 상호작용 - 이동  
  - 정수형 등 단순한 데이터 타입은 단순 복사  

  ```rust
  let x = 5;
  let y = x;
  ```

  - Heap에 저장된 데이터는 복사되지 않음
    - 문자열을 가리키는 Pointer, Length, Capacity를 포함한 Stack 데이터만 복사됨  

  ```rust
  let s1 = String::from("hello");
  let s2 = s1;
  ```

  ![heap_copy_1](TODO)  
  ![heap_copy_2](TODO)  

  <br>

  - 동일한 두 개의 변수 모두 scope를 벗어나는 경우  
    - 각각 메모리를 해제하게 되는 경우 *double free* error 발생  

  TODO

  <br>

  TODO
  TODO

  <br>

- 변수와 데이터 간 상호작용 방식 - 클론  
  - TODO  

  <br>

- 스택에만 저장되는 데이터 - 복사  
  - 아래와 같은 데이터 타입들은 copy trait을 구현하며, 항상 값을 복사한다.  
  > 숫자(정수, 부동 소수점), Boolean, char, Tuple(모든 요소가 copy trait을 구현한 경우)  

  TODO  

  <br>

- 소유권과 함수
  - 함수에 변수를 전달하는 경우도 마찬가지로 이동/복사 과정이 진행된다.  

  TODO  

  <br>

- Return 값과 scope
TODO  


### 1. 참조와 대여
- 소유권을 넘기는 대신 개체의 Reference를 넘기는 방법이 있다. -> **대여**  

```rust
fn main() {
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  println!("The length of '{}' is {}", s1, len);
}
fn calculate_length(s: &String) -> usize {
  s.len()
}
```

- 참조된 값은 수정 불가능하다.  
TODO 

- 가변 참조자를 사용하면 참조된 값을 수정할 수 있다.  
  - 단, 하나의 가변 참조자만 존재할 수 있다.  
TODO  

  - 가변 참조자의 개수가 하나로 제한된 이유 -> Data Race 방지  
  (A와 B가 같은 데이터에 동시에 접근하는 경우, 문제 발생)  
  ![mutable_ref](TODO)  

  TODO  

  <br>

  - 이미 생성 된 가변 참조자가 사라진 경우에는, 생성이 허용된다.  
  TODO  

  <br>

- Dangling References : 포인터가 남아있는 상태에서 메모리가 해제되는 문제  
TODO  

<br>

### 2. 슬라이스 타입
- 슬라이스 타입 : 컬렉션의 일부 Element만 Reference하는 타입  
  - `&`를 사용하여 슬라이스를 생성  

```rust
fn main() {
  let s = String::from("hello world");

  let hello = &s[0..5];
  let world = &s[6..11];

  println!("{hello}, {world}");  // hello world
}
```

- 슬라이스 Syntax  

|Syntax|Type|Range|
|:---:|:---:|:---:|
|`start .. end`|`std::ops::Range`|start <= x < end|
|`start ..`|`std::ops::RangeFrom`|start <= x|
|`.. end`|`std::ops::RangeTo`|x < end|
|`..`|`std::ops::RangeFull`|.|
|`start ..= end`|`std::ops::RangeInclusive`|start <= x <= end|
|`..= end`|`std::ops::RangeToInclusive`|x <= end|  

TODO  

<br>

TODOTODOTODO

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 임현승 교수님의 프로그래밍 언어 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>