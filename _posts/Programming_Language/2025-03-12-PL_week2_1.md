---
layout: post
title: "[í”„ë¡œê·¸ë˜ë° ì–¸ì–´] 2ì£¼ì°¨ (1) - Rust í”„ë¡œê·¸ë˜ë° ì»¨ì…‰ & ì†Œìœ ê¶Œ ì´í•´"
excerpt: "ë³€ìˆ˜ì™€ ê°€ë³€ì„±, ë°ì´í„° íƒ€ì…, í•¨ìˆ˜ ë™ì‘ ì›ë¦¬, ì£¼ì„, ì œì–´ë¬¸, ì°¸ì¡°, ëŒ€ì—¬, ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…"

tags:
  - [í”„ë¡œê·¸ë˜ë° ì–¸ì–´, Rust]

toc: true

date: 2025-03-12
last_modified_at: 2025-03-12
---
## ê¸°ë³¸ í”„ë¡œê·¸ë˜ë° ì»¨ì…‰ ì´í•´
### 1. ë³€ìˆ˜ì™€ ê°€ë³€ì„±
- Rustì—ì„œ ë³€ìˆ˜ëŠ” `let` í‚¤ì›Œë“œë¡œ ì„ ì–¸í•œë‹¤.
  - By default, ì„ ì–¸ëœ ë³€ìˆ˜ëŠ” ***Immutable***
  - ì´ëŠ” ì˜ë„ì¹˜ ì•Šì€ ë³€ìˆ˜ ê°’ ë³€ê²½ì„ ë°©ì§€í•œë‹¤.  

```rust
fn main() {
  let x = 5;
  println!("The value of x is: {x}");
  x = 6; // Error!
  println!("The value of x is: {x}");
}
```

- `mut` í‚¤ì›Œë“œë¥¼ ì¶”ê°€í•˜ì—¬ ê°€ë³€ ë³€ìˆ˜ë¡œ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤.  

```rust
fn main() {
  let mut x = 5;
  println!("The value of x is: {x}");
  x = 6; // OK!
  println!("The value of x is: {x}");
}
```
<br>

- ìƒìˆ˜(Constant)  
  - `const` í‚¤ì›Œë“œë¥¼ ì‚¬ìš©  
  `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`  

  - ë³€ê²½ì´ í—ˆìš©ë˜ì§€ ì•ŠëŠ” ê°’  
  
  - íƒ€ì…ì„ ë°˜ë“œì‹œ ëª…ì‹œí•´ì•¼ í•¨  
  `const CONSTANT_VALUE_1: i32 = 1;`  

  - `mut` í‚¤ì›Œë“œ ì‚¬ìš© ë¶ˆê°€  
  `const mut CONSTANT_MUT_VALUE: i32 = 2;` -> *ERROR*  

  - ëŸ°íƒ€ì„ì—ì„œ ê²°ì •ë˜ëŠ” ê°’ ì‚¬ìš© ë¶ˆê°€  
  `const CONSTANT_VALUE_2: i32 = x;` -> *ERROR*  

  <br>

- Shadowing : ê°™ì€ ì´ë¦„ì˜ ìƒˆ ë³€ìˆ˜ ì„ ì–¸  

```rust
fn main() {
  let x = 5;
  let x = x + 1;
  {
    let x = x * 2;
    println!("The value of x in the inner scope is: {x}");
  }
  println!("The value of x is: {x}");
}
```

- Shadowingì˜ ê²½ìš° `mut`ê³¼ëŠ” ë‹¬ë¦¬ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ë³€ê²½í•  ìˆ˜ ìˆë‹¤.  

```rust
fn main() {
  let mut spaces = "   ";
  spaces = spaces.len(); // Error!
}
```

```rust
fn main() {
  let spaces = "   ";
  let spaces = spaces.len(); // OK!
}
```

<br>

### 2. ë°ì´í„° íƒ€ì…
- RustëŠ” íƒ€ì…ì´ ê³ ì •ëœ ì–¸ì–´  
  - ì»´íŒŒì¼ ì‹œ ë³€ìˆ˜ì˜ íƒ€ì…ì„ ë°˜ë“œì‹œ ì•Œ ìˆ˜ ìˆì–´ì•¼ í•¨.  
  - ë‹¤ì–‘í•œ íƒ€ì…ì´ ì„ íƒë  ìˆ˜ ìˆëŠ” ê²½ìš° íƒ€ì…ì„ ëª…ì‹œí•´ì•¼ í•¨.  

  <br>

#### [1] ì •ìˆ˜í˜• íƒ€ì…
- archëŠ” 32bit/64bitì— ë”°ë¼ ë‹¬ë¼ì§  
- ê°€ë…ì„±ì„ ìœ„í•´ `_` ì‚¬ìš© ê°€ëŠ¥  

|Length|Signed|Unsigned|
|:---:|:---:|:---:|
|8-bit|`i8`|`u8`|
|16-bit|`i16`|`u16`|
|32-bit|`i32`|`u32`|
|64-bit|`i64`|`u64`|
|128-bit|`i128`|`u128`|
|arch|`isize`|`usize`|  

|Number literals|Example|
|:---:|:---:|  
|Decimal|`98_222`|
|Hex|`0xff`|
|Octal|`0o77`|
|Binary|`0b1111_0000`|
|Byte(u8 only)|`b'A'`|

<br>

#### [2] ë¶€ë™ì†Œìˆ˜ì  íƒ€ì…
- `f32`, `f64`(by default)  

```rust
fn main() {
  let x = 2.0; // f64
  let y: f32 = 3.0; // f32
}
```

<br>

- ë³€ìˆ˜ ì„ ì–¸ ì‹œ ê³„ì‚°ëœ ê°’ì„ ê¸°ì¤€ìœ¼ë¡œ íƒ€ì…ì´ ì •í•´ì§.  

```rust
fn main() {
  // addition
  let sum: i32 = 5 + 10;

  // subtraction
  let difference: f64 = 95.5 - 4.3;

  // multiplication
  let product: i32 = 4 * 30;

  // division
  let quotient: f64 = 56.7 / 32.2;

  // remainder
  let remainder: i32 = 43 % 5;
}
```

<br>

#### [3] Boolean íƒ€ì…  

```rust
fn main() {
  let t = true;
  let f: bool = false;
}
```

<br>

#### [4] ë¬¸ìì—´ íƒ€ì…  

```rust
fn main() {
  let c = 'z';
  let z = 'â„¤';
  let heart_eyed_cat = 'ğŸ˜»';
  let abc = "abc";
}
```

<br>

#### [5] Tuple íƒ€ì…  
- ë‹¤ì–‘í•œ íƒ€ì…ì„ í•˜ë‚˜ì˜ ë³µí•© íƒ€ì…ìœ¼ë¡œ ë§Œë“œëŠ” ë°©ë²•  

```rust
fn main() {
  let tup: (i32, f64, u8) = {500, 6.4, 1};

  let (x, y, z) = tup;  

  println!("The value of y is: {}", y);
}
```  

<br>

- íŠœí”Œ ë‚´ë¶€ ê°’ì€ `.index`ë¡œ ì ‘ê·¼ ê°€ëŠ¥  

```rust
fn main() {
  let tup = (500, 6.4, 1);

  let five_hundred = tup.0;

  let six_point_four = tup.1;

  let one = tup.2;
}
```

<br>

#### [6] ë°°ì—´ íƒ€ì…  

```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
  println!("{}", a[0]);
}
```

<br>

```rust
fn main() {
  let tup = ('a', 2, 'c');
  let arr = ['a', 'b', 'c'];

  let tup_ele = tup.0;
  let arr_ele = arr[0];

  assert!(tup_ele == arr_ele);

  println!("Success!");
}
```

- `assert!(condition)` : conditionì´ `false`ì¸ ê²½ìš° panic ë°œìƒ
- `assert_eq!(left, right)` : leftì™€ rightê°€ ê°™ì§€ ì•Šì€ ê²½ìš° panic ë°œìƒ

  <br>

<br>

### 3. í•¨ìˆ˜ ë™ì‘ ì›ë¦¬
- í•¨ìˆ˜ëŠ” `fn` í‚¤ì›Œë“œë¡œ ì„ ì–¸  

```rust
fn main() {
  println!("Hello, world!");

  another_function();
}
fn another_function() {
  println!("Another function.");
}
```

<br>

- ëª¨ë“  ParameterëŠ” íƒ€ì… ì •ì˜ í•„ìš”  

```rust
fn main() {
  another_function(5);
}
fn another_function(x: i32) {
  println!("The value of x is: {}", x);
}
```

- ì—¬ëŸ¬ ê°œì˜ ParameterëŠ” ì‰¼í‘œë¡œ êµ¬ë¶„  

```rust
fn main() {
  another_function(5, 6);
}
fn another_function(x: i32, y: i32) {
  println!("The value of x is: {}", x);
  println!("The value of y is: {}", y);
}
```

- í•¨ìˆ˜ì˜ Return
  - `->`ë¥¼ ì‚¬ìš©í•˜ì—¬ Return ê°’ì˜ íƒ€ì…ì„ ëª…ì‹œ
  - ì„¸ë¯¸ì½œë¡ (`;`)ì´ ì—†ëŠ” ë§ˆì§€ë§‰ expressionì„ Return  

```rust
fn main() {
  let x = add(5, 6);
  println!("The value of x is: {x}");
}
fn add(x: i32, y: i32) -> i32 {
  x + y
}
```

- ë‹¨, ê°’ì„ ë¯¸ë¦¬ ë°˜í™˜í•˜ë ¤ë©´ `return` ë¬¸ìœ¼ë¡œ ëª…ì‹œ  

```rust
fn demo_fn(x: i32) -> i32 {
  if x == 0 {
    return -1;
  }
  x
}
```

<br>

- ë¸”ë¡ í‘œí˜„ì‹ : ë¸”ë¡ì—ì„œ ê°’ì„ ë°˜í™˜  

```rust
fn main() {
  let x = 5;
  
  let y = {
    let x = 3;
    x + 1
  };

  println!("The value of y is: {}",  y);
}
```

<br>

### 4. ì£¼ì„
- `//` : í•œ ì¤„ ì£¼ì„  

```rust
// Isn't it boring, right?
```

- `/* */` : ì—¬ëŸ¬ ì¤„ ì£¼ì„  

```rust
/*
  Isn't it boring,
  right?
*/
```

<br>

### 5. ì œì–´ë¬¸
#### [1] `if` í‘œí˜„ì‹  

```rust
fn main() {
  let number = 6;

  if unmber % 4 == 0 {
    println!("number is divisible by 4");
  } else if number % 3 == 0 {
    println!("number is divisible by 3");
  } else if number % 2 == 0 {
    println!("number is divisible by 2");
  } else {
    println!("number is not divisible by 4, 3, or 2");
  }
}
```  

<br>

```rust
let condition = true;
// it looks like a ternary operator
// if the types are different, it will cause an error
// e.g., if contidion { 5 } else { "six" }
let number = if condition { 5 } else { 6 };
println!("The value of number is: {number}");
```

<br>

#### [2]  `loop`ë¬¸  
- ë¬´ì¡°ê±´ ë°˜ë³µ  

```rust
fn main() {
  loop {
    println!("again!");
  }
}
```

<br>

#### [3] `while`ë¬¸
- ì¡°ê±´ë¶€ ë°˜ë³µ  

```rust
fn main() {
  let mut number = 3;
  while number != 0 {
    println!("{}!", number);
    number = number - 1;
  }
  println!("LIFTOFF!!!");
}
```  

<br>

#### [4] `for`ë¬¸  
- ë°©ë²• 1 : `for` .. `in` (`for each`)  
  - ë‹¨, Tupleì€ Element typeì´ ë‹¤ë¥¼ ìˆ˜ ìˆì–´ ë¶ˆê°€ëŠ¥í•˜ë‹¤.  

```rust
fn main() {
  let a = [10, 20, 30, 40, 50];
  for element in a {
    println!("The value is: {element}");
  }
}
```  

<br>

- ë°©ë²• 2 : `range` ì‚¬ìš©  

```rust
fn main() [
  for number in (1..4).rev() {
    println!("{number}!");
  }
  println!("LIFTOFF!!!");
]
```

<br>

```rust
let arr = [0, 1, 2, 3, 4];
assert_eq!(arr[ .. ], [0, 1, 2, 3, 4]);
assert_eq!(arr[ .. 3], [0, 1, 2         ]);
assert_eq!(arr[ ..=3], [0, 1, 2, 3      ]);
assert_eq!(arr[1.. ], [      1, 2, 3, 4]);
assert_eq!(arr[1..3], [      1, 2         ]);
assert_eq!(arr[1..=3], [      1, 2, 3      ]);
```

<br>

- `sum_all` í•¨ìˆ˜ ì‘ì„±

```rust
fn main() {
  let list = [1, 2, 3, 4];
  let result_1 = sum_all_1(list);
  let result_2 = sum_all_2(list);
}
fn sum_all_1(arr: [i32; 4]) -> i32 {
  let mut result = 0;
  for i in list {
    result += i;
  }
  result
}
fn sum_all_2(list: [i32; 4]) -> i32 {
  list.iter().sum()
}
```

<br>

## ì†Œìœ ê¶Œ
- ì†Œìœ ê¶Œ : Rust í”„ë¡œê·¸ë¨ì´ ë©”ëª¨ë¦¬ë¥¼ ê´€ë¦¬í•˜ëŠ” ê·œì¹™  

- ì†Œìœ ê¶Œ ê·œì¹™
  - (1) ëª¨ë“  Rustì˜ ê°’ì—ëŠ” ì†Œìœ ìê°€ ìˆë‹¤.
  - (2) ë‹¨ í•˜ë‚˜ì˜ ì†Œìœ ìë§Œì´ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.  
  - (3) ì†Œìœ ìê°€ scopeë¥¼ ë²—ì–´ë‚˜ë©´ ê°’ì€ ì‚­ì œëœë‹¤.  

<br>

- RustëŠ” ë‹¤ë¥¸ íŠ¹ì • ì–¸ì–´ë“¤ê³¼ ë‹¬ë¦¬ Garbage Collectorê°€ ì—†ë‹¤.  
  - ëŒ€ì‹ , ì†Œìœ ê¶Œ ê·œì¹™ì„ í†µí•´ ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê²½ìš° ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•œë‹¤.
  - ì»´íŒŒì¼ ë‹¨ê³„ì—ì„œ ì†Œìœ ê¶Œì— ëŒ€í•œ í™•ì¸ì´ ì´ë£¨ì–´ì§„ë‹¤.  

<br>

- `String` íƒ€ì…
  - heap ë©”ëª¨ë¦¬ì— ì €ì¥ëœë‹¤.
  - ì¼ë°˜ ë¬¸ìì—´ê³¼ ë‹¬ë¦¬ ìˆ˜ì • ê°€ëŠ¥í•˜ë‹¤.  

  ```rust
  fn main() {
    let mut s = String::from("hello");
    s.push_str(", world!");  // string concatenation
    println!("{s}");
  }
  ```

  - Scopeì—ì„œ ë²—ì–´ë‚  ì‹œ ìë™ìœ¼ë¡œ ë©”ëª¨ë¦¬ í• ë‹¹ í•´ì œ  

  ```rust
  {
    let s = String::from("hello");
    // do something with s
  }
  // scope over, s is no longer valid
  ```

  <br>

- ë³€ìˆ˜ì™€ ë°ì´í„° ê°„ ìƒí˜¸ì‘ìš© - ì´ë™  
  - ì •ìˆ˜í˜• ë“± ë‹¨ìˆœí•œ ë°ì´í„° íƒ€ì…ì€ ë‹¨ìˆœ ë³µì‚¬  

  ```rust
  let x = 5;
  let y = x;
  ```

  - Heapì— ì €ì¥ëœ ë°ì´í„°ëŠ” ë³µì‚¬ë˜ì§€ ì•ŠìŒ
    - ë¬¸ìì—´ì„ ê°€ë¦¬í‚¤ëŠ” Pointer, Length, Capacityë¥¼ í¬í•¨í•œ Stack ë°ì´í„°ë§Œ ë³µì‚¬ë¨  

  ```rust
  let s1 = String::from("hello");
  let s2 = s1;
  ```

  ![heap_copy_1][def]  
  ![heap_copy_2][def2]  

  <br>

  - ë™ì¼í•œ ë‘ ê°œì˜ ë³€ìˆ˜ ëª¨ë‘ scopeë¥¼ ë²—ì–´ë‚˜ëŠ” ê²½ìš°  
    - ê°ê° ë©”ëª¨ë¦¬ë¥¼ í•´ì œí•˜ê²Œ ë˜ëŠ” ê²½ìš° *double free* error ë°œìƒ  

  - `let s2 = s1;` ì´í›„ `s1` ì‚¬ìš© ë¶ˆê°€ -> ë©”ëª¨ë¦¬ ì•ˆì „ ë³´ì¥  

  - Rustì—ì„œëŠ” ìë™ìœ¼ë¡œ deep copyë¥¼ ì‹¤ì‹œí•˜ì§€ ì•ŠìŒ  
  ![heap_copy_3][def]

  <br>

- ë³€ìˆ˜ì™€ ë°ì´í„° ê°„ ìƒí˜¸ì‘ìš© ë°©ì‹ - í´ë¡   
  - Heapì— ì €ì¥ëœ ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ë ¤ë©´ clone ì‚¬ìš©  

  ```rust
  let s1 = String::from("hello");
  let s2 = s1.clone();

  println!("s1 = {s1}, s2 = {s2}");
  ```  

  ![heap_copy_4][def3]

  <br>

- ìŠ¤íƒì—ë§Œ ì €ì¥ë˜ëŠ” ë°ì´í„° - ë³µì‚¬  
  - ì•„ë˜ì™€ ê°™ì€ ë°ì´í„° íƒ€ì…ë“¤ì€ copy traitì„ êµ¬í˜„í•˜ë©°, í•­ìƒ ê°’ì„ ë³µì‚¬í•œë‹¤.  
  > ìˆ«ì(ì •ìˆ˜, ë¶€ë™ ì†Œìˆ˜ì ), Boolean, char, Tuple(ëª¨ë“  ìš”ì†Œê°€ copy traitì„ êµ¬í˜„í•œ ê²½ìš°)  

  ```rust
  fn main() {
    let x = 5;
    let y = x;
    println!("x = {}, y = {}", x, y);
  }
  ```  

  <br>

- ì†Œìœ ê¶Œê³¼ í•¨ìˆ˜
  - í•¨ìˆ˜ì— ë³€ìˆ˜ë¥¼ ì „ë‹¬í•˜ëŠ” ê²½ìš°ë„ ë§ˆì°¬ê°€ì§€ë¡œ ì´ë™/ë³µì‚¬ ê³¼ì •ì´ ì§„í–‰ëœë‹¤.  

  ```rust
  fn main() {
    let s = String::from("hello");
    takes_ownership(s);
    // s is no longer valid . . .
    println!("{s}");  // Error!
  }
  fn takes_ownership(some_string: String) {  // ownership is here
    println!("{some_string}");
  }
  ```

  <br>

- Return ê°’ê³¼ scope

```rust
fn main() {
  let s1 = gives_ownership();
  let s2 = String::from("hello");
  let s3 = takes_and_gives_back(s2);
}
fn gives_ownership() -> String {
  let some_string = String::from("hello");
  some_string
}
fn takes_and_gives_back(a_string: String) -> String {
  a_string
}
```  

<br>

- íŠœí”Œ í˜•ì‹ìœ¼ë¡œ ì†Œìœ ê¶Œì„ ë‹¤ì‹œ ëŒë ¤ì¤„ ìˆ˜ë„ ìˆìŒ

```rust
fn main() {
  let s1 = String::from("hello");
  let (s2, len) = calculate_length(s1);
  println!(The length of "{} is {}", s2, len);
}
fn calculate_length(s: String) -> (String, usize) {
  len length = s.len();
  (s, length)
}
```


### 1. ì°¸ì¡°ì™€ ëŒ€ì—¬
- ì†Œìœ ê¶Œì„ ë„˜ê¸°ëŠ” ëŒ€ì‹  ê°œì²´ì˜ Referenceë¥¼ ë„˜ê¸°ëŠ” ë°©ë²•ì´ ìˆë‹¤. -> **ëŒ€ì—¬**  

```rust
fn main() {
  let s1 = String::from("hello");
  let len = calculate_length(&s1);
  println!("The length of '{}' is {}", s1, len);
}
fn calculate_length(s: &String) -> usize {
  s.len()
}
```

- ì°¸ì¡°ëœ ê°’ì€ ìˆ˜ì • ë¶ˆê°€ëŠ¥í•˜ë‹¤.  

```rust
fn main() {
  let s = String::from("hello");
  change(&s);
}
fn change(some_string: &String) {
  some_string.push_str(", world");  // Error!
}
```  

- ê°€ë³€ ì°¸ì¡°ìë¥¼ ì‚¬ìš©í•˜ë©´ ì°¸ì¡°ëœ ê°’ì„ ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.  
  - ë‹¨, í•˜ë‚˜ì˜ ê°€ë³€ ì°¸ì¡°ìë§Œ ì¡´ì¬í•  ìˆ˜ ìˆë‹¤.  

```rust
fn main() {
  let mut s = String::from("hello");
  change(&mut s);
}
fn change(some_string: &mut String) {
  some_string.push_str(", world");
}
```  

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;  // Error!
```

  - ê°€ë³€ ì°¸ì¡°ìì˜ ê°œìˆ˜ê°€ í•˜ë‚˜ë¡œ ì œí•œëœ ì´ìœ  -> Data Race ë°©ì§€  
  (Aì™€ Bê°€ ê°™ì€ ë°ì´í„°ì— ë™ì‹œì— ì ‘ê·¼í•˜ëŠ” ê²½ìš°, ë¬¸ì œ ë°œìƒ)  
  ![mutable_ref][def4]  

  <br>

  - ì°¸ì¡°ì + ê°€ë³€ ì°¸ì¡°ìì˜ ê²½ìš°ë„ ë¬¸ì œ ë°œìƒ  

  ```rust
  let mut s = String::from("hello");

  let r1 = &s;
  let r2 = &s;
  let r3 = &mut s;  // Error!

  println!("{}, {}, and {}", r1, r2, r3);  // used here
  ```  

  <br>

  - ì´ë¯¸ ìƒì„± ëœ ê°€ë³€ ì°¸ì¡°ìê°€ ì‚¬ë¼ì§„ ê²½ìš°ì—ëŠ”, ìƒì„±ì´ í—ˆìš©ëœë‹¤.  
  
  ```rust
  let mut s = String::from("hello");
  {
    let r1 = &mut s;
  }
  let r2 = &mut s;  // OK!
  ```

  - ë˜ëŠ” ê°€ë³€ ì°¸ì¡°ì ìƒì„± ì´í›„ ì°¸ì¡°ìê°€ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ê²½ìš°ì—ë„ í—ˆìš©ëœë‹¤.  

  ```rust
  let mut s = String::from("hello");

  let r1 = &s;
  let r2 = &s;
  println!("{}, {}", r1, r2);
  // r1 and r2 are no longer used

  let r3 = &mut s;  // OK!
  ```

  <br>

- Dangling References : í¬ì¸í„°ê°€ ë‚¨ì•„ìˆëŠ” ìƒíƒœì—ì„œ ë©”ëª¨ë¦¬ê°€ í•´ì œë˜ëŠ” ë¬¸ì œ  

```rust
fn main() {
  let reference_to_nothing = dangle();
}
fn dangle() -> &String {
  let s = String::from("hello");
  &s  
  // Ownership remains in this function
  // Memory will be deallocated when the function ends
  // It occurs Error!
}
```

<br>

### 2. ìŠ¬ë¼ì´ìŠ¤ íƒ€ì…
- ìŠ¬ë¼ì´ìŠ¤ íƒ€ì… : ì»¬ë ‰ì…˜ì˜ ì¼ë¶€ Elementë§Œ Referenceí•˜ëŠ” íƒ€ì…  
  - `&`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¬ë¼ì´ìŠ¤ë¥¼ ìƒì„±  

```rust
fn main() {
  let s = String::from("hello world");

  let hello = &s[0..5];
  let world = &s[6..11];

  println!("{hello}, {world}");  // hello world
}
```

- ìŠ¬ë¼ì´ìŠ¤ Syntax  

|Syntax|Type|Range|
|:---:|:---:|:---:|
|`start .. end`|`std::ops::Range`|start <= x < end|
|`start ..`|`std::ops::RangeFrom`|start <= x|
|`.. end`|`std::ops::RangeTo`|x < end|
|`..`|`std::ops::RangeFull`|.|
|`start ..= end`|`std::ops::RangeInclusive`|start <= x <= end|
|`..= end`|`std::ops::RangeToInclusive`|x <= end|  

<br>

- Example - ê³µë°±ìœ¼ë¡œ êµ¬ë¶„ë˜ëŠ” ì²« ë‹¨ì–´ ì°¾ê¸°  

```rust
fn first_word(s: &String) -> &str {
  let bytes = s.as_bytes();

  for (i, &item) in bytes.iter().enumerate() {
    if item == b' ' {
      return &s[0..i];
    }
  }
  &s[..]
}
```

<br>

- ìŠ¬ë¼ì´ìŠ¤ê°€ ìˆëŠ” ìƒíƒœì—ì„œ ë‚´ìš© ë³€ê²½ ë¶ˆê°€  

```rust
fn main() {
  let mut s = String::from("hello world");

  let word = first_word(&s);

  s.clear();  // Error!

  println!("The first word is: {word}");
}
```

<br>

- ë¬¸ìì—´ ë¿ë§Œ ì•ˆë¼ ìˆ«ì ë°°ì—´ ë“± í™œìš© ê°€ëŠ¥  

```rust
fn main() {
  let a = [1, 2, 3, 4, 5];
  let slice = &a[1..3];
  assert_eq!(slice, &[2, 3]);
}
```

<br>
<br>
<br>
<br>
<details>
<summary>ì£¼ì˜ì‚¬í•­</summary>
<div markdown="1">

ì´ í¬ìŠ¤íŒ…ì€ ê°•ì›ëŒ€í•™êµ ì„í˜„ìŠ¹ êµìˆ˜ë‹˜ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ ìˆ˜ì—…ì„ ë“¤ìœ¼ë©° ë‚´ìš©ì„ ì •ë¦¬ í•œ ê²ƒì…ë‹ˆë‹¤.  
ìˆ˜ì—… ë‚´ìš©ì— ëŒ€í•œ ì €ì‘ê¶Œì€ êµìˆ˜ë‹˜ê»˜ ìˆìœ¼ë‹ˆ,  
ë‹¤ë¥¸ ê³³ìœ¼ë¡œì˜ ë¬´ë¶„ë³„í•œ ë‚´ìš© ë³µì‚¬ë¥¼ ìì œí•´ ì£¼ì„¸ìš”.

</div>
</details>

[def]: https://i.imgur.com/3fiMuhU.png
[def2]: https://i.imgur.com/SImw8j7.png
[def3]: https://i.imgur.com/pAcT4TU.png
[def4]: https://i.imgur.com/MqrBKIi.png