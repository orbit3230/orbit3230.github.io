---
layout: post
title: "[프로그래밍 언어] 13주차 - Fearless Concurrency"
excerpt: ""

tags:
  - [프로그래밍 언어, Rust]

toc: true

date: 2025-05-28
last_modified_at: 2025-05-28
---
## Fearless Concurrency
- 동시성 프로그래밍을 안전하고 효율적으로 처리하는 것이 Rust의 주요 목표 중 하나
  - Ownership과  Type system이 메모리 안정성과 동시성 문제를 해결하는 데 도움을 줌
  - 많은 동시성 문제를 런타임 에러가 아닌 컴파일 시 찾을 수 있음
  - Rust의 이러한 특성 -> **Fearless Concurrency**

  <br>

### 1. Thread Execution
- 프로그램을 여러 스레드로 나눠서 실행하는 경우, 성능 향상을 기대할 수 있다.  
![thread_execution](TODO)  
  - 이미지 병렬 처리
  - UI 스레드 분리로 응답성 향상

<br>

- 그러나 프로그램이 복잡해지며, 코드가 실행되는 순서를 확실히 할 수 없어 문제가 발생할 수 있다.  
![thread_execution_problem](TODO)  
  - Race Conditions : 다수의 스레드가 동시에 리소스에 접근
  - Deadlocks : 다수의 스레드가 서로를 기다려 무한 대기 상태에 빠짐
  - Bugs : 특정 조건에서 발생하며, 재현이나 수정이 어려움  

<br>

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..=10 {
            println!("Thread 1: {}", i);
            thread::sleep(Duration::from_secs(1));
        }
    });

    for i in 1..=2 {
        println!("Main: {}", i);
        thread::sleep(Duration::from_secs(1));
    }
}
```

- 메인 스레드가 종료되면 생성된 스레드도 종료된다.  
![thread_execution_example_output_1](TODO)  

- `join`을 사용하여 스레드가 종료될 때까지 대기  

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..=10 {
            println!("Thread 1: {}", i);
            thread::sleep(Duration::from_secs(1));
        }
    });

    for i in 1..=2 {
        println!("Main: {}", i);
        thread::sleep(Duration::from_secs(1));
    }

    handle.join().unwrap();
    // handle.join() -> Result<T>
}
```

![thread_execution_example_output_2](TODO)  

<br>

### 2. Data Sharing
- 스레드에 데이터 전달하기  

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        // Error
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

- 메인 스레드가 종료되면 v에 접근할 수 없다.

- `move` 키워드를 사용하여 데이터의 소유권 전달

```rust
use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!("Here's a vector: {:?}", v);
    });

    handle.join().unwrap();
}
```

<br>

- **안전하게 동시성을 구현하는 방법**  
> Do not communicate by sharing memory; Instead, share memory by communicating.  

#### [1] Message Passing
- Rust에서는 message-sending 방식의 동시성을 구현하기 위해 `channel`을 제공한다.  
  - mpsc (multiple producer, single consumer)  

- mpsc를 사용한 코드 예시

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = "R7"
        tx.send(val).unwrap();
        println!("my GOAT, cristiano ronaldo, {}", val);  // Error
    })

    let received = rx.recv().unwrap();
    println!("Received: {}", received);
}
```

- 위 코드에서는 `send()`에서 `recv()`로 ownership이 이동했기 때문에, 에러가 발생한다.  

<br>

- 여러 개의 값 전송하기
  - `rx`의 iterator는 `tx`가 drop될 때까지 메시지 수신 대기  

```rust
use std::sync::mpsc;
use std::thread;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![1, 2, 3, 4];
        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!("Received: {}", received);
    }
}
```

![thread_execution_example_output_3](TODO)  

<br>

- 여러 스레드에서 데이터 공유하기
  - `mspc::Sender::clone`이나 `tx1.clone()` 사용  

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx1, rx) = mpsc::channel();
    let tx2 = mpsc::Sender::clone(&tx1);

    thread::spawn(move || {
        tx1.send("Message from thread 1").unwrap();
    });

    thread::spawn(move || {
        tx2.send("Message from thread 2").unwrap();
    });

    for received in rx {
        println!("Received: {}", received);
    }
}
```

<br>

#### [2] Share-State Concurrency
- Message passing은 동시성을 컨트롤하는 데 유용하지만, 유일한 방법은 아니다.  

- Shared Memory Concurrency는 Multiple ownership과 유사하다.  
  - 다수의 ownership을 다루어야 하므로 코드가 더 복잡해진다.  
  - Smart pointer - `Rc<T>`, `RefCell<T>`와 유사

  <br>

- **Mutex**를 사용하여 데이터에 대한 접근을 한 번에 하나의 스레드로 제한할 수 있다.  
  


<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 임현승 교수님의 프로그래밍 언어 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>