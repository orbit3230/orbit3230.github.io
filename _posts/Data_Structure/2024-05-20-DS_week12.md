---
layout: post
title: "[자료구조] 12주차 - 정렬 & 우선순위 큐"
excerpt: ""

tags:
  - [자료구조, C]

toc: true

date: 2024-05-20
last_modified_at: 2024-05-20
---
## 정렬
- 정렬(sort)  
  - 데이터를 오름차순이나 내림차순으로 나열하는 것.
  - 자료 탐색에 있어서 필수적이다.  
  <br>

![record_field](https://i.imgur.com/wQIlNf4.png)
- 레코드(record) : 정렬시켜야할 대상, 필드의 집합
- 필드(field) : 데이터
  - 키 필드(key field) : 레코드를 대표하는 필드. 주로 키 필드를 정렬의 기준으로 한다.  

<br>

## 정렬 알고리즘
- 모든 경우에 적합한 정렬 알고리즘은 없다.  
- 경우마다 적합한 정렬 방법을 사용해야 한다.  
  - TODO

- 정렬 알고리즘의 평가 기준
  - TODO

- 복잡성 vs 효율
  - TODO

- 정렬 알고리즘의 안정성(stability)  
  - 안정적인 알고리즘은,  
  동일한 키 값을 갖는 레코드들의 상대적인 위치가 정렬 후에도 바뀌지 않음.  

  - 아래는 안정되지 않은 정렬이다.  
  ![not_stable][def]

### 1. 선택 정렬
- 선택 정렬(selection sort)
  - 배열의 정렬되지 않은 부분을 모두 선형 탐색하면서,  
  탐색의 결과 가장 작은 데이터를 하나씩 가져오는 정렬.  

  ```c
  void selection_sort(int list[], int n) {
    for(int i = 0 ; i < n-1 ; i++) {
        int minIndex = i;
        for(int j = i+1 ; j < n ; j++)
            if(list[j] < list[minIndex])
                minIndex = j;

        int temp = list[i];
        list[i] = list[minIndex];
        list[minIndex] = temp;
    }
  }
  ```  

  - 선택정렬의 시간 복잡도 : `O(n`<sup>`2`</sup>`)`  

  - 안정되지 않은 정렬 알고리즘이다.  

  <br>

### 2. 삽입 정렬
- 삽입 정렬(insertion sort)
  - 다음 데이터를 이미 정렬된 배열의 올바른 위치에 삽입하는 정렬.  

  ```c
  void insertion_sort(int[] list, int n) {
    for(int i = 1 ; i < n ; i++) {
        int key = list[i];
        int j = i-1;
        while(j >= 0 && list[j] > key) {
            list[j+1] = list[j];
            j--;
        }
        list[j+1] = key;
    }
  }
  ```

  - 삽입 정렬의 시간 복잡도
    - 최선의 경우 : 이미 정렬되어 있는 경우  
    `O(n)`
      - 비교 : `O(n)`
      - 이동 : `O(0)`

    - 최악의 경우 : 역순으로 정렬되어 있는 경우  
    `O(n`<sup>`2`</sup>`)`
      - 비교 : `O(n`<sup>`2`</sup>`)`
      - 이동 : `O(n`<sup>`2`</sup>`)`  

    - 평균의 경우 : `O(n`<sup>`2`</sup>`)`

      <br>

    - 정렬이 되어있는 부분이 많을수록 매우 효율적이다.  

    - 안정된 정렬 알고리즘이다.  

    <br>

### 3. 버블 정렬
- 버블 정렬(bubble sort) 
  - 인접한 2개의 레코드를 비교하여,  
  순서대로 되어있지 않으면 서로 교환하는 정렬.
  
  ```c
  void bubble_sort(int list[], int n) {
    for(int i = n-1 ; i > 0 ; i--) {
        for(int j = 0 ; j < i ; j++) {
            if(list[j] > list[j + 1]) {
                int temp = list[j];
                list[j] = list[j+1];
                list[j+1] = temp;
            }
        }
    }
  }
  ```  

  - 버블 정렬의 시간 복잡도  
    - TODO  

    <br>

### 4. 합병 정렬
- 합병 정렬(merge sort)  
  - 배열을 두 개의 균등한 크기로 분할하고, 분할한 부분 배열을 정렬.
  - 정렬된 두 개의 부분 배열을 합하여 전체 배열을 정렬.  

#### 분할 정복?  
- (1) 분할(Divide) : 배열을 같은 크기의 2개의 부분 배열로 분할
- (2) 정복(Conquer) : 부분 배열을 정렬. 부분 배열의 크기가 충분히 작지 않으면, 재귀 호출로 다시 분할 정복.  
- (3) 결합(Combine) : 정렬된 부분 배열을 하나의 배열에 통합.  

  ```c
  int sorted[MAX_SIZE];

  void merge_sort(int list[], int left, int right) {
    if(left < right) {
        int mid = (left + right) / 2;
        merge_sort(list, left, mid);
        merge_sort(list, mid+1, right);
        merge(list, left, mid, right);
    }
  }

  void merge(int list[], int left, int mid, int right) {
    int i = left;
    int j = mid+1;
    int sorting = left;
    while(i <= mid && j <= right) {
        if(list[i] <= list[j])
            sorted[sorting++] = list[i++];
        else
            sorted[sorting++] = list[j++];
    }
    if(i > mid)
        for(int k = j ; k <= right ; k++)
            sorted[k++] = list[k];
    else
        for(int k = i ; k <= mid ; k++)
            sorted[k++] = list[k];

    for(int k = left ; k <= right ; k++)
        list[k] = sorted[k];
  }
  ```  

  - 분할 정복의 시간 복잡도
    - TODO

    <br>

### 5. 퀵 정렬
- 퀵 정렬(quick sort)
  - 배열을 2개의 부분 배열로 비균등 분할하고,  
  각각의 부분 배열을 다시 재귀호출하는 정렬.  

  ```c
  void quick_sort(int list[], int left, int right) {
    if(left < right) {
        int q = partition(list, left, right);
        quick_sort(list, left, q-1);
        quick_sort(list, q+1, right);
    }
  }

  int partition(int list[], int left, int right) {
    int pivot = list[left];
    int low = left;
    int high = right+1;
    do {
        do
            low++;
        while(low <= right && list[low] < pivot);
        do
            high--;
        while(high >= left && list[high] > pivot);
    } while(low < high);

    int temp = list[left];
    list[left] = list[right];
    list[right] = temp;

    return high;
  }
  ```  

  <br>
  <br>

## 우선순위 큐
- 우선순위 큐(priority queue) : 우선순위를 가진 항목들을 저장하는 큐
  - FIFO 순서가 아닌, 우선 순위가 높은 데이터가 먼저 나간다.  

### 1. 우선순위 큐 구현 방법
- 배열을 이용한 우선순위 큐
- 링크드 리스트를 이용한 우선순위 큐
- **힙(heap)을 이용한 우선순위 큐**
<br>

- 시간 복잡도

|표현 방법|삽입|삭제|
|:---:|:---:|:---:|
|비정렬 배열|`O(1)`|`O(n)`|
|비정렬 링크드 리스트|`O(1)`|`O(n)`|
|정렬 배열|O(n)|`O(1)`|
|정렬 링크드 리스트|`O(n)`|`O(1)`|
|힙|`O(log n)`|`O(log n)`|

- 따라서 우리는 힙(heap)으로 우선순위 큐를 구현할 것이다.  

<br>

- 힙(heap) : 노드의 키들이 다음 식을 만족하는 완전 이진 트리  
  - 최대 힙 : `key(부모 노드) >= key(자식 노드)`
  - 최소 힙 : `key(부모 노드) <= key(자식 노드)`  

- 힙은 배열을 이용하여 구현한다.  
  - 힙은 완전 이진 트리이므로, 각 노드에 인덱스를 붙일 수 있다.  
    - 왼쪽 자식의 인덱스 : `(부모 인덱스) * 2`
    - 오른쪽 자식의 인덱스 : `(부모 인덱스) * 2 + 1`
    - 부모의 인덱스 : `(자식 인덱스) / 2`  

    <br>

### 2, 힙에서의 삽입
- 힙에 새로운 요소가 들어오면,  
우선 힙의 마지막 노드에 이어서 삽입한다.  

- 삽입 후에,  
새로운 노드를 부모 노드와 비교/교환 하면서 힙의 성질을 만족시킨다.  

- upheap 연산이라고 부른다.  

```c
// TODO
```

### 3. 힙에서의 삭제
- 최대 힙에서의 삭제는 가장 큰 키값을 가진 루트 노드의 삭제를 의미한다.  
우선 힙의 루트 노드를 삭제하고 가장 마지막 노드를 루트 노드로 올린다.    

- 삭제 후에,  
루트 노드를 자식 노드와 비교/교환 하면서 힙의 성질을 만족시킨다.  




[def]: https://i.imgur.com/3PSHUG8.png