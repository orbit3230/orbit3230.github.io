---
layout: post
title: "[자료구조] 1주차 - 자료구조와 알고리즘"
excerpt: "수업 목표, 자료구조와 알고리즘, 추상 자료형, 시간목잡도, 빅오 표기법, 자료구조 표기법"

tags:
  - [자료구조, C]

toc: true

date: 2024-03-04
last_modified_at: 2024-03-07
---
## 수업 목표
- (1) 프로그래밍에 사용되는 자료 구조의 이해
  - 자료 구조는 컴퓨터 프로그래밍에서의 중요한 기본 지식임
- (2) 널리 활용되는 자료구조들의 기본 개념 및 알고리즘을 배움
  - 배열, 리스트, 스택, 큐, 트리, 우선순위 큐 등
  - 각 자료 구조를 응용하는 C언어 프로그램을 작성

  <br>

## 자료구조와 알고리즘
### 1. 일상생활 속 자료구조
- 일상생활에서의 사물들을 조직화해보면 자료구조로 표현할 수 있다.  

|일상생활 예|자료구조|
|:---:|:---:|
|그릇을 쌓아서 보관|스택|
|마트 계산대의 줄|큐|
|버킷 리스트|리스트|
|영어사전|사전(딕셔너리)|
|지도|그래프|
|컴퓨터의 디렉토리(폴더 경로) 구조|트리|

<br>

### 2. 자료구조와 알고리즘
- **프로그램 = 자료구조 + 알고리즘**

![ds_algorithm][def]

<br>

### 3. 알고리즘
- **알고리즘**이란, **컴퓨터로 문제를 풀기 위한 단계적인 절차**

<br>

- 알고리즘의 조건
  - (1) 입력 : 0개 이상의 입력이 존재해야 한다.  

  - (2) 출력 : 1개 이상의 출력이 존재해야 한다.  

  - (3) 명백성 : 각 명령어의 의미는 모호하지 않고 명확해야 한다.  

  - (4) 유한성 : 한정된 수의 단계 후에는 반드시 종료되어야 한다.  
  (Infinity Loop X)  

  - (5) 유효성 : 각 명령어들은 실행 가능한 연산이어야 한다.  

  <br>

- 알고리즘의 기술 방법
  
  - (1) 자연어 (ex. 영어, 한국어 등) 
    - 읽기가 쉬움
    - 다만, 의미 전달이 모호해질 수 있음

  - (2) 흐름도 (flow chart)  
    - 직관적이고 이해하기 쉬움
    - 다만, 복잡한 알고리즘의 경우, 상당히 복잡해짐

  - (3) 의사코드 (pseudo-code) 
    - 알고리즘 기술에 많이 사용
    - 여러가지 문제를 감추고, 알고리즘의 핵심적인 내용에만 집중할 수 있음

  - (4) 프로그래밍 언어
    - 알고리즘의 가장 정확한 기술이 가능
    - 다만, 실제 구현 시 많은 구체적인 사항들이 핵심적인 내용에 대한 이해를 방해할 수 있음.
      - 예를 들어 해당 언어에 대한 지식이 전무한 경우.  

<br>

## 추상 자료형  
### 1. 자료형
- 자료형이란, **데이터의 종류**.  

- 자료형은 결국 데이터의 집합과  
해당 데이터를 다룰 수 있는 연산의 집합으로 이루어진다.

#### [1] 기초 자료형
- 기초 자료형에는 대표젹으로 정수(`int`), 실수(`float`, `double`), 문자(열)(`char`) 등이 있다.  

#### [2] 파생 자료형
- 파생 자료형에는 대표적으로 배열(`int[]`), 포인터(`*int`) 등이 있다.

#### [3] 사용자 정의 자료형
- 사용자 정의 자료형에는 대표적으로 구조체(`struct`), 공용체(`union`), 열거형(`enum`) 등이 있다.  

<br>

### 2. 추상 데이터 타입(ADT, Abstract Data Type)
- 추상 데이터 타입이란, **데이터 타입을 추상적(수학적)으로 정의한 것**이다.  
<br>
데이터나 연산이 **무엇(what) 인지는 정의**되지만, 데이터나 연산을 **어떻게(how) 구현할 지는 정의되지 않는다.**  
<br>
객체지향 언어에서는 **`Class`** 개념으로 나타낸다.  
<br>
객체 (추상 데이터 타입에 속하는 객체)  
와  
연산 (추상 데이터 타입과 외부를 연결하는 인터페이스 역할)  
으로 이루어진다.  

<br>

- 추상 데이터 타입은 **추상화 -> 정보은닉기법**(information hiding)에서 유래되었다.  

  - **추상화**란, 사용자에게 <u>중요한 정보는 강조</u>하는 반면에,  
  <u>중요하지 않은 세부 구현 사항은 제거</u>하는 것을 말한다.  

  <br>

## 알고리즘의 성능 분석
### 1. 프로그램 효율성이 중요한 이유
- 요즘의 컴퓨터들은 예전에 비해 계산 속도가 빨라졌고, 메모리가 증가했다.  
<br>
하지만 그럼에도 불구하고, **효율성은 중요하다**.
  - 최근 상용 프로그램의 규모가 예전에 비해 더 커졌고,  
  - 사용자들은 여전히 빠른 프로그램을 선호하기 때문이다.  

  <br>

### 2. 성능 분석 기법
#### [1] 수행 시간 측정
- 두 개의 알고리즘의 실제 수행 시간을 측정하는 것.
- 실제로 구현해야함.
- 동일한 하드웨어를 사용해야 함.

<br>

  - 방법
    - 실제로 구현한 프로그램의 연산 시작과 끝에서 시간을 잰다.

#### [2] 알고리즘의 복잡도 분석
- 직접 구현하지 않고서도 수행 시간을 분석하는 것.
- 알고리즘이 수행하는 연산의 횟수를 측정하여 비교.
- 일반적으로 연산의 횟수는 `n`에 대한 함수  

<br>

  - 종류
    - 시간 복잡도(time complexity)  
      => 알고리즘의 수행시간 분석을 위함

      - 시간 복잡도는 알고리즘을 이루고 있는 연산들이 몇 번이나 수행되는 지를 숫자로 표시한다.  

        - 시행횟수 `n` 당 연산 횟수를 계산식으로 표현할 때, 아래의 ***빅오 표기법*** 을 사용한다.  

    - 공간 복잡도(space complexity)  
      => 수행할 때 필요한 메모리 양 분석을 위함

      <br>

#### [3] 빅오 표기법
- 빅오 표기법이란, 연산의 횟수를 대략적으로 표기한 것으로서, 시간 복잡도를 구할 때 사용한다.  

- 시간 복잡도는 시행횟수 `n`에 대한 함수로 나타낸다. (`f(n)`, `T(n)` 등)  

  - *이 때*, 함수의 **차수**가 값의 크기에 가장 영향을 크게 미치므로 다른 항들은 상대적으로 무시할 수 있다.  
  => 따라서 가장 영향이 큰, **차수가 가장 높은 항을 가지고** 연산 횟수를 **대략적**으로 표기한 표기법이 ***빅오 표기법*** 이다.  

- 빅오 표기법은 **함수의 상한**을 표시한다.  

![big_o_notation][def2]

- 이 말은, 두 개의 함수 `f(n)`과 `g(n)` 이 주어졌을 때,  
모든 `n > n`<sub>`0`</sub>에 대하여 `|f(n)| <= c|g(n)|`을 만족하는 상수 `n`<sub>`0`</sub>과 `c`가 존재하면  
`f(n) = O(g(n))` 이다.  
- 예를 들어,  
  - `f(n) = 2n + 1` 이면 `O(n)`이다. `n`<sub>`0`</sub>`= 2`, `c = 3`일 때, `n > 2`에 대하여 `2n + 1 <= 3n`이 성립하기 때문이다.
  - `f(n) = 3n`<sup>`2`</sup>`+ 100` 이면 `O(n)`<sup>`2`</sup>이다. `n`<sub>`0`</sub>`= 100`, `c = 5`일 때, `n > 100`에 대하여 `3n`<sup>`2`</sup>`+ 100 <= 5n`<sup>`2`</sup>이 성립하기 때문이다.  

- 증명은 이렇게 하면 되고,  
가볍게 차수가 가장 높은 항에 계수를 뗀 것을 `g(n)`으로 놓고  
`O(g(n))`으로 작성해 주는 것을 빅오 표기법이라고 보면 되겠다.  
<br>

- 빅오 표기법의 종류

|`O(f(n))`|종류|
|:---:|:---:|
|`O(1)`|상수형|
|`O(log n)`|로그형|
|`O(n)`|선형|
|`O(nlog n)`|선형로그형|
|`O(n`<sup>`2`</sup>`)`|2차형|
|`O(n`<sup>`3`</sup>`)`|3차형|
|`O(2`<sup>`n`</sup>`)`|지수형|
|`O(n!)`|팩토리얼형|

- 아래 두 종류는 시행횟수가 너무 크기 때문에 일반적으로 잘 다루지 않는다.  
(AI, 빅데이터 같은 특수한 분야에서나 쓰임)

![big_o_notation_series][def3]

<br>

#### [4] 빅오메가 표기법
- 빅오메가 표기법은 함수의 하한을 표시한다.

![big_omega_notation][def4]

<br>

### [5] 빅세타 표기법
- 빅세타 표기법은 함수의 하한인 동시에 상한을 표시한다.  
(중간값을 표시한다는 뜻. 상한과 하한의 사이값)

<br>

### [6] 최선, 평균, 최악의 경우
- 알고리즘의 수행시간은 입력 자료 집합에 따라 다를 수 있다.  

  - 최선의 경우(best case) : 수행 시간이 가장 빠른 경우
    - 의미가 없는 경우가 많다.

  - 평균의 경우(average case) : 수행 시간이 평균적인 경우
    - 계산하기가 상당히 어려움.

  - 최악의 경우(worst case) : 수행 시간이 가장 늦은 경우  
    - 가장 널리 사용된다. 계산하기 쉽고, 응용에 따라서 중요한 의미를 가질 수도 있다.  

    ![image][def5]

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 이다영 교수님의 자료구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/15ewCer.png
[def2]: https://i.imgur.com/tzm2Fny.png
[def3]: https://i.imgur.com/SXMUXOE.png
[def4]: https://i.imgur.com/N1Ge76A.png
[def5]: https://i.imgur.com/JXd0RpP.png