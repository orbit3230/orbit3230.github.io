---
layout: post
title: "[자료구조] 2주차 (1) - 순환"
excerpt: "재귀의 개념과 재귀 알고리즘, 재귀 호출의 유의점, 응용"

tags:
  - [자료구조, C]

toc: true

date: 2024-03-11
last_modified_at: 2024-03-11
---
## 재귀(Recursion)
- 재귀란, 알고리즘이나 함수가 수행 도중에 **다시 자기 자신을 호출**하는 것을 말한다.  

  - 문제 해결을 위한 정의 자체가 재귀적으로 되어있는 경우,  
  재귀를 사용하면 깔끔하게 해결할 수 있다.

  <br>

### 1. 팩토리얼
- 팩토리얼의 정의는 다음과 같다.  
  - `n=0`일 때, `n! = 1`
  - `n=1`일 때, `n! = n * (n-1)!`  

- 이를 재귀적으로 표현해보자.  

```c
int factorial(int n) {
    if(n <= 1) return 1;
    else return (n * factorial(n-1));
}
```

<br>

### 2. 재귀호출의 유의점
- 재귀 호출을 할 때는 다음과 같은 사항을 지켜야한다.  

  - (1) 재귀함수를 **멈추는 조건이 설정**되어 있어야 한다.  
  - (2) 재귀함수가 **점진적으로 종료조건에 가까워 져야 한다**.  

- 또한 재귀함수는 다음과 같은 문제가 생길 수도 있다.  

  - 모든 재귀는 반복문으로 작성할 수 있다.  
  따라서 반복문에 비해 **과도하게 복잡해지거나**, **효율성이 떨어질 수도 있다**.  

    - 위 팩토리얼 알고리즘의 시간 복잡도를 계산해보면,  
      - (1) 재귀 : **`O(n)`** - 함수 호출이 `n`번 일어나므로  
      - (2) 반복 : **`O(n)`** - for문이 `n`번 반복되므로  
    
    - 다만, 재귀 알고리즘은 메모리가 많이 필요하기 때문에  
    재귀 알고리즘이 반복 알고리즘보다 **더 느리다.**  

  <br>

### 3. 거듭제곱
- 이번엔 재귀적 방법이 반복문보다 더 빠른 알고리즘을 알아보자.  

  - 숫자 `x`의 `n`제곱인 `x`<sup>`n`</sup>을 구하는 알고리즘이다.  

- 재귀적으로 작성하면 이렇다.  

```c
int power(int x, int n) {
    if(n == 0) return 1;
    else if((n%2) == 0) return power(x*x, n/2);
    else return x * power(x*x, (n-1)/2);
}
```

- 반복문을 사용했을 때와 시간복잡도를 비교해보자.  

  - (1) 재귀 : 문제의 크기가 `1/x` 만큼씩 줄어들기 때문에,  
  `O(log`<sub>`x`</sub>`n)` 이다.  
  - (2) 반복 : 반면 반복문은 숫자가 `1`씩 늘어나므로  
  `O(n)` 이다.  
  <br>
  - 숫자가 커질 수록 유리해지는 `log` 시간복잡도를 가지게 된다.  

  <br>

### 4. 피보나치 수열
- 재귀적 방법이 비효율적인 예로서 피보나치 수열 알고리즘을 알아보자.  

- 피보나치 수열의 정의는 이러하다.  
  - `n=0`일 때, `0`
  - `n=1`일 때, `1`
  - `n>1`일 때, `fib(n-2) + fib(n-1)`

- 이를 재귀적으로 작성해보자.  

```c
int fibonacci(int n) {
    if(n==0) return 0;
    if(n==1) return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```  

- 피보나치 수열을 재귀적 알고리즘으로 구현했을 때 시간 복잡도는 이러하다.  

  - `T(n) = T(n-1) + T(n-1) + C`  
  따라서 시간 복잡도는 `O(2`<sup>`n`</sup>`)`  
  <br>

- 반면 이를 반복문으로 구현해보자면  

```c
int fibonacci(int n) {
    if(n==0) return 0;
    if(n==1) return 1;
    
    int sum;
    int nMinus1 = 1;
    int nMinus2 = 0;
    for(int i = 2 ; i <= n ; i++) {
        sum = nMinus1 + nMinus2;
        nMinus2 = nMinus1;
        nMinus1 = sum;
    }
    return sum;
}
```

- 반복문으로 구현했을 때 시간복잡도는  

  - `O(n)`에 불과하다.  
  차이가 매우 심하다.  

  <br>

### 5. 하노이 탑 문제
- 재귀를 사용해야만 문제가 깔끔하고 센스있게 풀리는 예로서,  
하노이탑 알고리즘을 알아보자.  

- 하노이탑 알고리즘이란,  
막대 3개가 있을 때,  
막대 A에 크기 내림차순으로 쌓여있는 원판 `n`개를 막대 C로 옮기는 것이다.  

  - 단, 한 번에 하나의 맨 위 원판만 옮길 수 있고,  
  크기가 작은 원판 위에 큰 원판이 쌓일 수 없다.  

- 재귀로 표현하자면 이렇게 작성할 수 있다.  
  - 프린트문을 통해서 어떻게 내부적으로 작동하는 지 확인한다.  

```c
int hanoi_tower(int n, char from, char tmp, char to) {
    if(n == 1) printf("원판 1을 %c에서 %c로 옮긴다.\n", from, to);
    else {
        hanoi_tower(n-1, from, to, tmp);
        printf("원판 %d을(를) %c에서 %c로 옮긴다.\n", n, from, to);
        hanoi_tower(n-1, tmp, from, to);
    }
}
```

<br>

### 6. 꼬리재귀와 머리재귀
- `return n * factorial(n-1)`과 같은 구조를 **꼬리재귀**,  

- `return factorial(n-1) * n`과 같은 구조를 **머리재귀**  
<br>
형태라고 부른다.  

<br>

- 꼬리재귀는 **반복문으로의 변환이 쉽다.**  
- 반면, 머리재귀나 하노이의 탑처럼  
여러 번 재귀호출 하는 경우(multi recursion)는  **반복문으로 변환이 어렵다.**  
  - 명시적인 스택을 만들어서 시뮬레이션이 가능  

- 따라서 동일한 알고리즘을 꼬리재귀와 머리재귀 방식 둘 다로 표현 가능하다면,  
**꼬리재귀로 작성해야 한다.**  


<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 이다영 교수님의 자료구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>