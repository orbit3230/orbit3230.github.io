---
layout: post
title: "[프로그래밍 기초] 13주차 - 비트연산"
excerpt: "2의 보수체계, 비트연산자, 시프트연산자, 비트 마스킹"

tags:
  - [프로그래밍 기초, Java]

toc: true

date: 2024-02-10
last_modified_at: 2024-02-11
---
# 정수 표현
## 1. 양의 정수 표현
- 양의 정수표현은 알다시피 이진법을 사용한다.
  - 가장 오른쪽 비트부터 `(bit == 1) ? 2^0 : 0`
  - 이후 n번째 비트는 `(bit == 1) ? 2^n : 0`
    - 과 같은 각 비트별 값을 모두 더한 것이 해당 이진수의 십진수 표현 값이다.
    - 예 )
      - 1 => `0001`
      - 2 => `0010`
      - 15 => `1111`
      - 33 => `100001`
      - 101 => `1100101`  
<br>

## 2. 음의 정수 표현
- 그렇다면 음의 정수, 즉 음수는 어떻게 비트로 표현할 수 있을까?

### [1] 부호 체계 (Signed-magnitude Notation)
- 가장 왼 쪽의 첫 비트를 부호 비트로 사용하는 방법이다.  
기존 양의 정수 표현 방식과 같은데, 만약 맨 앞 비트가 **0이라면 양수, 1이라면 음수**. 이런 형태다.

### [2] 보수 체계 (Signed-One's Complement)
- 1의 보수 : 음수 표현 시 1을 0으로, 0을 1로 서로 뒤집는 방식이다.  
(Signed 1's Complement)
- 2의 보수 : 음수 표현 시 1을 0으로, 0을 1로 서로 뒤집은 후, ***1을 더하는*** 방식이다.  
(Signed 2's Complement)
  - 차이점? : 2의 보수체계는 정수 0을 표현하는 방식이 단 하나가 된다! (1의 보수는 `0000` -> +0 이면서 -0)  
  <br>
- 그림으로 알아보자.
![signed_notation][def]
- 이처럼 부호 체계와 1의 보수 체계는 정수 0으로 표현하는데에 문제가 발생한다.
  - <span style = "color : darkturquoise"><u><font size = "4">따라서 컴퓨터는 2의 보수 체계를 사용한다.</font></u></span>  
  <br>

## 3. 비트 표현 확장
- 4비트 표현을 8비트 표현으로 확장하려면?
  - 양수는 앞에 `0000`, 음수는 앞에 `1111`을 덧붙인다.  
  <br>

# 비트 연산자(Bitwise Operations)
- 비트 연산자를 사용하여 <u>정수형 기본 데이터 타입</u>의 각 비트를 개별적으로 조작할 수 있다.  
<br>
- 비트 연산을 *왜* 사용하는 가?
  - 비트 연산은 산술 연산보다 ***압도적으로*** 빠르다.
    - 왜냐 ? 컴퓨터는 숫자를 비트로 인식한다.  
    데이터를 가공할 필요 없이 날 것 그대로 컨트롤 가능하다면 얼마나 빠르게 처리 가능하겠는가?  
    <br>

## 1. AND, OR, XOR, NOT
- 산술연산자에 &&, ||, ! 연산자가 있듯이, 비트연산자에도 유사한 것이 존재한다.  

|연산자 명|비트 연산자|설명|사용 예|결과|
|---|:---:|---|---|---|
|비트 AND 연산자|`&`|모두 1이면 1, 아니면 0|`(0011) & (0101)`|`0001`|
|비트 OR 연산자|\||하나라도 1이면 1, 아니면 0|(0011) \| (0101)|`0111`|
|비트 XOR 연산자<br>(eXclusive OR)|`^`|다르면 1, 같으면 0|`(0011) ^ (0101)`|`0110`|
|비트 NOT 연산자|`~`|단항 연산자로서, 모든 비트 값을 반대로|`~(0011)`|`1100`|

-<sup> 비트 NOT 연산자의 기능이 익숙하지 않은가? 바로 보수표현 기능과 같다.  
-<sup> `~A`는 A의 1의 보수표현과 같고, `~A + 1`은 2의 보수표현법이다.  <br>

- 비트 연산자를 boolean 타입 변수에 사용하면 ***논리연산자처럼*** 작동한다.
  - 단, 논리 연산자는 <u>값이 결정되는 순간 까지</u>만 계산한다.
  - 이에 반해, 비트 연산자는 식을 모두 계산한다.
  ![bit_operator_boolean_judgement][def2]  
  <br>

## 2. 시프트 연산자
- 비트를 지정한 수(피연산자) 만큼 왼쪽 or 오른쪽으로 이동(shift) 시키는 연산자이다.

|연산자 명|시프트 연산자|설명|사용 예|결과|
|---|:---:|---|---|---|
|왼쪽 시프트 연산자|`<<`|n만큼 왼쪽으로 shift(맨 오른쪽은 0)|`(0011) << 1`|`0110`|
|오른쪽 시프트 연산자|`>>`|n만큼 오른쪽으로 shift(맨 왼쪽은 기존 비트 복사)|`(1010) >> 1`|`1101`|
|unsigned 오른쪽 시프트 연산자|`>>>`|n만큼 오른쪽으로 shift(맨 왼쪽은 0)|`(1010) >>> 1`|`0101`|

- 시프트 연산자를 잘 활용한다면, 2의 거듭제곱 연산을 센스있게 처리할 수 있다.
  - `<<` 연산자 : 비트가 왼쪽으로 n만큼 이동하면서 모든 각 비트의 지수부분이 `+n` 되었으므로,  
  기존 수에 **`* 2^n`** 를 한 효과와 같다.
  - `>>` 연산자 : 비트가 오른쪽으로 n만큼 이동하면서 모든 각 비트의 지수부분이 `-n` 되었으므로,  
  기존 수에 **`* 1/2^n`** 를 한 효과와 같다.  
  <br>

# 비트 마스킹
- 데이터를 마스크(mask) 비트와 bitwise AND/OR/XOR와 같은 연산자로 연산시킴으로서, 원하는 비트만 걸러내는, 거름망 같은 느낌의 이론이다.  
<br>
![bit_masking][def3]  
<br>

## 1. 집합 구현
- 정수 비트표현을 사용하여 0~31 사이의 정수를 중복 없이 가지는 집합을 꾸려볼 수 있다.  
각 원소에 대응되는 비트를 `1`로 표현함으로서 집합을 구성하는 것이다.
  - 예 )
    - U{2, 4, 9} -> 2^2 + 2^4 + 2^9 = 276
      - `0000 0000 0000 0000 0000 0010 0001 0100`
    - 이렇게 276 이라는 정수는 오로지 집합 U{2, 4, 9}를 설명하는 정수가 된 것이다.  

- 더 나아가, 집합 연산도 가능하다.
  
  |집합|표현|
  |---|---|
  |합집합|A \| B|
  |교집합|`A & B`|
  |차집합|`A & (~B)`|  
  
  <br>

## 2. 비트 마스킹의 활용
- 비트 마스킹의 재미있는 활용 예로서, 피자토핑 문제가 있다.
  - 피자에 토핑이 20가지 있을 때, 각각을 넣을 지 말지는 2가지 경우의 수이다.  
  => 총 2^20가지의 경우의 수  
  <br>
  - 토핑이 아예 없는 피자

  ```java
  int emptyPizza = 0;  // 0000 0000 0000 0000 0000
  ```

  - 토핑이 모두 들어있는 피자(매우 비쌀 것이다)
  
  ```java
  int fullPizza = (1 << 20) - 1; // 1111 1111 1111 1111 1111
  ```

  - p(0~19)번 토핑 추가 (이미 있다면 변화 X)

  ```java
  pizza |= (1 << p);
  ```

  - p(0~19)번 토핑 제거 (이미 있다면 변화 X)

  ```java
  pizza &= ~(1 << p);
  ```

  - p(0~19)번 토핑이 있으면 빼고, 없으면 추가

  ```java
  pizza ^= (1 << p);
  ```

  - p(0~19)번 토핑 확인
  ```java
  int check = pizza & (1 << p); // 있으면 1 이상, 없으면 0 저장
  ```  
  <br>

## 3. 2의 거듭제곱으로 나눈 몫과 나머지 구하기
  - 몫
    - [몫은 위에서 본 것처럼][def4],  
    `num / 2^k` => `num >> k`로 구할 수 있다.
    
    ```java
    // 158(10011110) / 2^5 의 몫
    int quotient = 158 >> 5 // 결과는 4(001)
    ```

  - 나머지
    - 나머지는 비트 마스킹을 통해 구할 수 있다.  
    몫을 구할 때 shifting을 통해 버려지는 구간이 나머지이기 때문에,  
    `num % 2^k` => `num & (1<<k)-1` 로 구할 수 있다.

    ```java
    // 158(10011110) / 2^5 의 나머지
    int remainder = 158 & (1 << 5)-1 // 결과는 30(11110)
    ```  
    <br>

# 부가적인 요소들
## 1. 정수 변환 메소드
- 정수 -> 이진수(문자열) 변환 메소드  

```java
int num = 123
Integer.toBinaryString(num);  // 반환 값은 String 타입이다.
                              // "1111011"
```

- 정수 문자열 -> 정수 변환 메소드

```java
String = "123"
Integer.parseInt(numString);    // 두 번째 인자를 생략 시 10(십진수)
                                // 123
Integer.parseInt(numString, 2); // 1111011
```

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">
이 포스팅은 강원대학교 정충교 교수님의 프로그래밍 기초 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.
</div>
</details>  

[def]: https://i.imgur.com/mKkLvMF.png
[def2]: https://i.imgur.com/oYA4Emh.png
[def3]: https://i.imgur.com/r1OJ4Qy.png
[def4]: https://orbit3230.github.io/2024/02/10/PB_week13/#2-%EC%8B%9C%ED%94%84%ED%8A%B8-%EC%97%B0%EC%82%B0%EC%9E%90