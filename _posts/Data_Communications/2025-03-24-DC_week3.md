---
layout: post
title: "[데이터통신] 3주차 - Principle of Network Applications"
excerpt: "Principle of Network Applications, Web and HTTP"

tags:
  - [데이터통신]

toc: true

date: 2025-03-24
last_modified_at: 2025-03-27
---
## Principle of Network Applications
### 1. Principle of Network Applications  
- Network apps  
  - Social Networking, Web, Text messaging, E-mail, Streaming video, ... etc.  

<br>

- **Creaing a network app**  
![creating_network_app][def]  
  - 이러한 프로그램을 작성할 것이다.  
    - end system에서 실행되는 프로그램
    - 네트워크를 통해 커뮤니케이션
    - e.g., browser software로 커뮤니케이션하는 웹 서버 소프트웨어  

  - 네트워크 코어 디바이스를 위한 소프트웨어를 작성할 필요가 없다.  
    - Network-core 디바이스들은 user application을 실행하지 않는다.  
    - 엔드 시스템에서 동작하는 애플리케이션은 빠른 app development와 propagation을 가능하게 한다.  

    <br>

- **Client-Server Paradigm**  
![client_server_paradigm][def2]  
  - **서버**
    - 항시 인터넷에 접속되어 있는(always-on), 영구적인 IP 주소를 가진 호스트.
    - 때로는 data center에 위치하기도 한다. (for scaling)  

  - **클라이언트**
    - 서버와 contact/communicaate
    - 항상 연결되는 것이 아니라, 간헐적으로 연결될 것이다.  
    - 항상 바뀌는 동적 IP 주소를 가질 것이다.
    - 다른 클라이언트와 서로 직접적으로 커뮤니케이션하지 않는다.
    - e.g., HTTP, IMAP, FTP  

    <br>

- **Peer-to-Peer Architecture**  
![peer_to_peer_architecture][def3]  
  - No always-on server
  - 임의의 엔드 시스템들이 직접적으로 커뮤니케이션.
  - Peers들이 다른 peers에게 서비스를 요청하고, 또 다시 다른 peers에게 서비스를 제공한다.  
    - **self-scalability** : 새로운 peers가 새로운 서비스 capacity를 필요한 만큼만 가져온다. 
  - Peers들은 간헐적으로 연결되고, IP 주소를 바꾼다.  
    - 복잡한 관리  
  - e.g., P2P file sharing, BitTorrent  

    <br>

- **Process Communicating**
  - **Process** : 호스트에서 실행되는 프로그램  
  - Process communication
    - 같은 호스트 내에서, 두 프로세스가 **inter-process communication**을 통해 커뮤니케이션.  
    (defined by OS)  
    - 다른 호스트의 프로세스끼리 메시지를 교환함으로서 커뮤니케이션.
  - 클라이언트 / 서버
    - 클라이언트 프로세스 : 커뮤니케이션을 시작하는 프로세스  
    - 서버 프로세스 : contact 되길 기다리는 프로세스  
  - P2P 아키텍쳐 애플리케이션은 클라이언트 프로세스와 서버 프로세스를 가진다.  

  <br>

- **Sockets**  
![sockets][def4]  
  - 프로세스는 소켓을 통해 메시지를 주고 받는다.  
  - 소켓은 문(door)과 같은 것이다.  
    - 프로세스를 보내는 것은 메시지를 문 밖에 내놓는 것이다.  
    - 프로세스를 보내는 것은, 반대쪽 받는 프로세스의 소켓에 메시지를 보내기 위한 transport infrastructure에 의존한다.  
    - 두 소켓이 포함된다. : 각 side 당 하나씩  

    <br>

- **Addressing Processes**
  - 메시지를 받기 위해서는, 프로세스는 반드시 **identifier**를 가져야 한다.  
  - 호스트 디바이스는 고유한 32-bit IP 주소를 가진다.  
  (현재는 IPv4가 고갈되어 128-bit IPv6를 함께 사용하고 있다.)  
    - Q. 프로세스가 동작하는 그 호스트의 IP 주소만으로도 커뮤니케이션할 프로세스를 식별하는 데 충분한가?  
    -> 그렇지 않다.  
    하나의 호스트 내에서도 여러 프로세스가 동작할 수 있기 때문이다.  
  - **identifier**는 해당 호스트 내 프로세스와 관련된 **IP 주소**와 **포트 번호**를 모두 포함한다.  
  (e.g., HTTP server : `80`, mail server : `25`)  

  <br>

- **Application-layer Protocol**
    - Application-layer 프로토콜은 다음을 정의한다.  
      - 교환된 메세지의 형식 : e.g., request, response
      - 메시지 syntax : 메시지에 어떤 필드가 있는지, 필드들이 어떻게 기술되어 있는지
      - 메시지 semantics : 필드 내 정보의 의미  
      - 언제, 어떻게 프로세스들이 메시지를 전송/응답할 지에 대한 규칙  

    - Open protocols
      - RFCs에 정의되어 있으며, 누구든 protocol definition에 접근할 수 있다.  
      - 서비스 상호 운용성을 보장한다.
      - e.g., HTTP, SMTP
      - c.f., proprietary(상호명이 있는) protocols : e.g., Skype, Zoom  

      <br>

- **What Transport Service Does an App Need?**
  - **Data integrity**
    - 어떤 앱들(e.g., 파일 전송, 웹 트랜잭션)은 100% 정확한 데이터 전송을 요구한다.
    - 다른 앱들(e.g., audio)는 어느 정도 손실은 허용할 수 있다.

  - **Timing**
    - 어떤 앱들(e.g., 인터넷 전화, 실시간 온라인 게임)은 적은 딜레이를 요구한다.  

  - **Throughput**
    - 어떤 앱들(e.g., 멀티미디어)은 최소한 어느 정도 이상의 throughput을 요구한다.  
    - 다른 앱들("elastic apps")은 throughput이 얼마든 상관없다.  

  - **Security**
    - Encryption, data integrity, ... etc.  

    <br>

  |Application|Data loss|Throughput|Time sensitive?|
  |:---:|:---:|:---:|:---:|
  |파일 전송/다운로드|no loss|elastic|no|
  |E-mail|no loss|elastic|no|
  |웹 문서|no loss|elastic|no|
  |실시간 오디오/비디오|loss-tolerant|audio: 5Kbps-1Mbps<br>video: 10Kbps-5Mbps|yes|
  |스트리밍 오디오/비디오|loss-tolerant|audio: 5Kbps-1Mbps<br>video: 10Kbps-5Mbps|yes|
  |실시간 온라인 게임|loss-tolerant|Kbps+|yes|
  |텍스트 메시지|no loss|elastic|yes & no|

  <br>

- **Internet Transport Protocol Services**
  - **TCP** service
    - 프로세스 송/수신 간 **Reliable transport**
    - **Flow control** : 송신자가 수신자에게 부담을 주지 않도록  
    - **Congestion control** : 네트워크 과부하 시 송신자를 제어
    - **Connection-oriented** : 클라이언트와 서버 프로세스 간 setup이 필요  
    - **Does not provide** : **Timing**, **Minimum throughput** guarantees, **Security**

  - **UDP** service
    - 프로세스 송/수신 간 **Unreliable data transfer**  
    - **Does not provide** : **Reliability**, **Flow control**, **Timing**, **Throughput** guarantees, **Security** or **Connection setup**

    <br>

  |Application|Application Layer Protocol|Transport Layer Protocol|
  |:---:|:---:|:---:|
  |파일 전송/다운로드|FTP [RFC 959]|TCP|
  |E-mail|SMTP [RFC 5321]|TCP|
  |웹 문서|HTTP [RFC 7230, 9110]|TCP|
  |인터넷 전화|SIP [RFC 3261], RTP [RFC 3550], or proprietary|TCP or UDP|
  |스트리밍 오디오/비디오|HTTP [RFC 7230], DASH|TCP|
  |실시간 온라인 게임|proprietary|UDP or TCP|

  <br>

- **Securing TCP**
  - Vanilla TCP & UDP sockets
    - **No encryption**
    - 평문 패스워드가 소켓으로 들어가 인터넷 상에서 평문으로 돌아다닌다. (!)  

  - **Transport Layer Security** (TLS)
    - **암호화된 TCP 연결**을 제공한다.  
    - Data Integrity
    - End-point authentication

  - TLS는 Application Layer에서 구현된다.  
    - 애플리케이션은 TLS 라이브러리를 사용하고, TCP를 차례대로 사용한다.  
    - 평문은 소켓으로 들어가 인터넷 상에서 암호화된 상태로 돌아다닌다.  

    <br>

### 2. Web and HTTP
- **Web and HTTP**
  - 웹 페이지는 **objects**로 구성되어 있고, 각 object는 서로 다른 웹 서버에 저장되어 있다.  
  - Object는 HTML 파일이 될 수도 있고, JPEG 이미지, Java applet, audio file, ... 등이 될 수 있다.
  <br>
  - 웹 페이지는 TODO  

  <br>

- **HTTP Overview**
  - Hypetext Transfer Protocol (HTTP)
    - 웹의 application layer 프로토콜
    - Client/Server 모델
      - Client : Web object를 requests, receives, 그리고 display하는 브라우저 (using HTTP 프로토콜)  
      - Server : Web object를 request에 반응하여 전송하는 웹 서버 (using HTTP 프로토콜)  

      <br>

    - **HTTP uses TCP**  
    ![http_tcp](TODO)  
      - 클라이언트는 서버에 80번 포트로 TCP 연결을 생성한다.  
      - 서버는 클라이언트로부터 TCP 연결을 받아들인다. (accept)
      - HTTP 메시지 (application-layer 프로토콜 메시지)가 브라우저(HTTP 클라이언트)와 웹 서버(HTTP 서버) 사이에 교환된다.  
      - TCP 연결이 닫힌다.  

    - **HTTP is stateless**
      - 서버는 클라이언트의 이전 요청에 대한 정보를 유지하지 않는다.  
      - "상태"를 유지하는 프로토콜은 Complex!  

      <br>

- **HTTP Connection Type**  
  - **Non-persistent HTTP**  
  ![non_persistent_http_1](TODO)  
  ![non_persistent_http_2](TODO)  
    - TCP 연결 생성
    - 적어도 하나의 object가 TCP 연결을 통해 전송
    - TCP 연결 종료  
    => 여러 개의 object 다운로드는 여러 연결을 필요로 함.

  - **Persistent HTTP**  
    - TCP 연결 생성
    - 여러 개의 object가 하나의 TCP 연결을 통해 전송 (클라이언트 - 서버)  
    - TCP 연결 종료  

- Persistent HTTP (HTTP 1.1)  
  - TODO  

- **HTTP Request Message**  
  - ASCII (human readable format)  
  ![http_request_message](TODO)  

  - General format  
  ![http_request_message_general_format](TODO)  

- **Other HTTP Request Methods**  
  - **Post method**  
  ![http_post_method](TODO)  
    - 웹 페이지가 input form을 가지고 있을 때
    - user의 input이 클라이언트->서버로 HTTP POST request message의 body에 포함되어 전송된다.  

  - **Get method** (서버로 데이터 전송을 위해)  
    - TODO  

  - **Head method**  
    - TODO

  - **Put method**  
    - TODO  

    <br>

- **HTTP Response Message**  
![http_response_message](TODO)  

- **HTTP Response Status Codes**  
  - **200 OK** : 요청이 성공적으로 처리되었음
  - **301 Moved Permanently** : 요청한 object가 새로운 URL로 이동되었음
  - **400 Bad Request** : 요청이 잘못되었음
  - **404 Not Found** : 요청한 object가 서버에 없음
  - **505 HTTP Version Not Supported** : 서버가 요청한 HTTP 버전을 지원하지 않음

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 데이터통신 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/8QwvpZc.png
[def2]: https://i.imgur.com/T2KwFdk.png
[def3]: https://i.imgur.com/dKt0vDT.png
[def4]: https://i.imgur.com/MTk0UDs.png