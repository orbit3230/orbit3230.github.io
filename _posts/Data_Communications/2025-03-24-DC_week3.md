---
layout: post
title: "[데이터통신] 3주차 - Principle of Network Applications"
excerpt: "Principle of Network Applications"

tags:
  - [데이터통신]

toc: true

date: 2025-03-24
last_modified_at: 2025-03-24
---
## Principle of Network Applications  
- Network apps  
  - Social Networking, Web, Text messaging, E-mail, Streaming video, ... etc.  

<br>

- **Creaing a network app**  
![creating_network_app][def]  
  - 이러한 프로그램을 작성할 것이다.  
    - end system에서 실행되는 프로그램
    - 네트워크를 통해 커뮤니케이션
    - e.g., browser software로 커뮤니케이션하는 웹 서버 소프트웨어  

  - 네트워크 코어 디바이스를 위한 소프트웨어를 작성할 필요가 없다.  
    - Network-core 디바이스들은 user application을 실행하지 않는다.  
    - 엔드 시스템에서 동작하는 애플리케이션은 빠른 app development와 propagation을 가능하게 한다.  

    <br>

- **Client-Server Paradigm**  
![client_server_paradigm][def2]  
  - **서버**
    - 항시 인터넷에 접속되어 있는(always-on), 영구적인 IP 주소를 가진 호스트.
    - 때로는 data center에 위치하기도 한다. (for scaling)  

  - **클라이언트**
    - 서버와 contact/communicaate
    - 항상 연결되는 것이 아니라, 간헐적으로 연결될 것이다.  
    - 항상 바뀌는 동적 IP 주소를 가질 것이다.
    - 다른 클라이언트와 서로 직접적으로 커뮤니케이션하지 않는다.
    - e.g., HTTP, IMAP, FTP  

    <br>

- **Peer-to-Peer Architecture**  
![peer_to_peer_architecture][def3]  
  - No always-on server
  - 임의의 엔드 시스템들이 직접적으로 커뮤니케이션.
  - Peers들이 다른 peers에게 서비스를 요청하고, 또 다시 다른 peers에게 서비스를 제공한다.  
    - **self-scalability** : 새로운 peers가 새로운 서비스 capacity를 필요한 만큼만 가져온다. 
  - Peers들은 간헐적으로 연결되고, IP 주소를 바꾼다.  
    - 복잡한 관리  
  - e.g., P2P file sharing, BitTorrent  

    <br>

- **Process Communicating**
  - **Process** : 호스트에서 실행되는 프로그램  
  - Process communication
    - 같은 호스트 내에서, 두 프로세스가 **inter-process communication**을 통해 커뮤니케이션.  
    (defined by OS)  
    - 다른 호스트의 프로세스끼리 메시지를 교환함으로서 커뮤니케이션.
  - 클라이언트 / 서버
    - 클라이언트 프로세스 : 커뮤니케이션을 시작하는 프로세스  
    - 서버 프로세스 : contact 되길 기다리는 프로세스  
  - P2P 아키텍쳐 애플리케이션은 클라이언트 프로세스와 서버 프로세스를 가진다.  

  <br>

- **Sockets**  
![sockets][def4]  
  - 프로세스는 소켓을 통해 메시지를 주고 받는다.  
  - 소켓은 문(door)과 같은 것이다.  
    - 프로세스를 보내는 것은 메시지를 문 밖에 내놓는 것이다.  
    - 프로세스를 보내는 것은, 반대쪽 받는 프로세스의 소켓에 메시지를 보내기 위한 transport infrastructure에 의존한다.  
    - 두 소켓이 포함된다. : 각 side 당 하나씩  

    <br>

- **Addressing Processes**
  - 메시지를 받기 위해서는, 프로세스는 반드시 **identifier**를 가져야 한다.  
  - 호스트 디바이스는 고유한 32-bit IP 주소를 가진다.  
  (현재는 IPv4가 고갈되어 128-bit IPv6를 함께 사용하고 있다.)  
    - Q. 프로세스가 동작하는 그 호스트의 IP 주소만으로도 커뮤니케이션할 프로세스를 식별하는 데 충분한가?  
    -> 그렇지 않다.  
    하나의 호스트 내에서도 여러 프로세스가 동작할 수 있기 때문이다.  
  - **identifier**는 해당 호스트 내 프로세스와 관련된 **IP 주소**와 **포트 번호**를 모두 포함한다.  
  (e.g., HTTP server : `80`, mail server : `25`)  

  <br>

- **Application-layer Protocol**
    - Application-layer 프로토콜은 다음을 정의한다.  
      - 교환된 메세지의 형식 : e.g., request, response
      - 메시지 syntax : 메시지에 어떤 필드가 있는지, 필드들이 어떻게 기술되어 있는지
      - 메시지 semantics : 필드 내 정보의 의미  
      - 언제, 어떻게 프로세스들이 메시지를 전송/응답할 지에 대한 규칙  

    - Open protocols
      - RFCs에 정의되어 있으며, 누구든 protocol definition에 접근할 수 있다.  
      - 서비스 상호 운용성을 보장한다.
      - e.g., HTTP, SMTP
      - c.f., proprietary(상호명이 있는) protocols : e.g., Skype, Zoom  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 데이터통신 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/8QwvpZc.png
[def2]: https://i.imgur.com/T2KwFdk.png
[def3]: https://i.imgur.com/dKt0vDT.png
[def4]: https://i.imgur.com/MTk0UDs.png