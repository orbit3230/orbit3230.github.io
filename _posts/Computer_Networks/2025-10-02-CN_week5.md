---
layout: post
title: "[컴퓨터네트워크] 5주차 - Control Plane"
excerpt: "Introduction to control plane in network layer, Routing protocols"

tags:
  - [컴퓨터네트워크]

toc: true

date: 2025-10-02
last_modified_at: 2025-10-02
---
## Control Plane
### 1. Introduction to control plane in network layer
- Network layer functions
  - Forwarding : 패킷을 라우터의 input port에서 적절한 라우터의 output port로 전달  
  -> **Data plane**
  
  - Routing : 패킷에 의해 착수된 source-destination 경로를 결정  
  -> **Control plane**  

  - 네트워크 control plane을 구축하는 두 가지 접근법  
    - Per-router control (traditional)
    - Logically centralized control (SDN)  

<br>

- **Per-router control plane**  
![per_router_control][def3]  
  - control plane 내에서 상호작용하는 각각의 모든 라우터들이 개별 routing algorithm을 실행  

- **Software-defined networking(SDN) control plane**  
![sdn_control][def4]  
  - 원격 컨트롤러가 연산하여 라우터 내 forwarding table을 채움  

<br>

### 2. Routing protocols
- Routing protocol  
![routing_protocol][def5]  
  - 라우터가 이루는 네트워크를 거치며 sending hosts -> receiving hosts로의 **"good paths"**를 결정하는 디자인  
    - **path** : 패킷이 주어진 초기 소스 호스트 -> 최종 목적지 호스트로 이동하는 라우터들의 시퀀스
    - **good** : 특정 metric의 관점에서 평가됨 (e.g., "least cost", "fastest", "least congested")  

  - 라우팅은 "top-10" networking challenges 중 하나  

<br>

- Graph abstraction: link costs  
![graph_abstraction][def6]  

<br>

- 라우팅 알고리즘의 분류  
![routing_algorithm_classification][def7]  

<br>

- Global: Link state routing algorithm
  - Network topology와 link costs가 모든 노드에 알려져있다.
    - "link state broadcast"를 통해 달성
    - 모든 노드가 같은 정보를 가짐
  - 하나의 노드(source)에서 다른 모든 노드들로의 least-cost paths를 계산
    - 해당 노드에 대한 forwarding table을 구축
  - Dijkstra's algorithm이 사용됨
    - `k`번의 반복 이후, `k`개의 목적지에 대한 least-cost paths가 결정됨  

- Dijkstra's link state routing algorithm example  
[더 자세한 설명은 알고리즘 포스트를 참조][def]  
![dijkstra_1][def8]  
![dijkstra_2][def9]  
![dijkstra_3][def10]  
![dijkstra_4][def11]  

- Dijkstra's algorithm: discussion
  - 알고리즘의 시간 복잡도 : `n(n+1)/2` -> `O(n`<sup>`2`</sup>`)`
    - 우선순위 큐를 사용하여 더 효율적으로 구현하면 : `O(n log n)`
  - 메시지의 시간 복잡도
    - 각 라우터는 다른 `n-1`개의 라우터에 broadcast하여 링크 상태 정보를 전송
    - 효율적인 broadcast 알고리즘 : `O(n)` link crossing
    - 각 라우터의 메시지는 `O(n)` 링크를 crossing -> 전체 메시지 복잡도는 `O(n`<sup>`2`</sup>`)`

- Oscillation issue in Dijkstra's algorithm
  - Link costs가 트래픽 양에 따라 변할 때, Route oscillation이 발생할 수 있음
  - Sample scenario  
  ![oscillation][def12]  

<br>

- Decentralized: Distance vector algorithm
  - Bellman-Ford(BF) equation에 기반 (dynamic programming)  
  ![bellman_ford][def13]  
    
- Bellman-Ford example  
[더 자세한 설명은 문제해결프로그래밍 포스트를 참조][def2]  
![bellman_ford_example_1][def14]  
![bellman_ford_example_2][def15]  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 컴퓨터네트워크 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://orbit3230.github.io/2024/10/21/AL_week8/#3-dijkstras-algorithm-for-single-source-shortest-path
[def2]: https://orbit3230.github.io/2024/11/05/PS_week10/#2-%EB%B2%A8%EB%A7%8C-%ED%8F%AC%EB%93%9C
[def3]: https://i.imgur.com/1k4d9n5.png
[def4]: https://i.imgur.com/tSKDJlj.png
[def5]: https://i.imgur.com/MX7hIlh.png
[def6]: https://i.imgur.com/7e3VRJB.png
[def7]: https://i.imgur.com/F8b2fpS.png
[def8]: https://i.imgur.com/197T4Sl.png
[def9]: https://i.imgur.com/x2LZ3l1.png
[def10]: https://i.imgur.com/4eyA2jT.png
[def11]: https://i.imgur.com/oAtG8gF.png
[def12]: https://i.imgur.com/kp9ig3S.png
[def13]: https://i.imgur.com/DRPGiyn.png
[def14]: https://i.imgur.com/X5h2KeA.png
[def15]: https://i.imgur.com/CRK2QeP.png