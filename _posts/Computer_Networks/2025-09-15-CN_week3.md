---
layout: post
title: "[컴퓨터네트워크] 3주차 - Internet Protocol (IP)"
excerpt: "IP - the Internet Protocol, NAT & IPv6"

tags:
  - [컴퓨터네트워크]

toc: true

date: 2025-09-15
last_modified_at: 2025-09-29
---
## Internet Protocol (IP)
### 1. IP - the Internet Protocol
- Network layer: Internet  
  - Host, routher network layer functions  
  ![network_layer][def]  

<br>

- IP Datagram format  
![ip_datagram_format_1][def2]  
  - header length : `4` bits
    - IP header의 길이 (단위: 32-bit words)
    - 최소값 : 5 (20 bytes), 최대값 : 15 (60 bytes)
    - 옵션 필드가 없을 경우 : 20 bytes
  - length : `16` bits
    - IP datagram 전체 길이 (단위: bytes)
    - 최소값 : 20 bytes, 최대값 : 65,535 bytes

![ip_datagram_format_2][def3]  

<br>

- IP Fragmentation, Reassembly  
![ip_fragmentation][def4]  
  - 네트워크 링크는 MTU(Maximum Transmission Unit)를 가짐
    - Link-layer frame의 최대 크기
    - 링크 타입은 제각각이므로, MTU도 제각각
      
  - 큰 IP Datagram은 네트워크 내에서 쪼개어져야 할 수도 있음
    - 하나의 Datagram이 여러 datagrams로 쪼개어짐
    - 오직 마지막 도착지에서 Reassembled.
    - 관련된 fragments를 식별하고 순서를 맞추는 데 IP 헤더 비트를 사용  

- Example
  - 4000 byte IP datagram
  - MTU = 1500 bytes인 링크를 통과해야 함  
  ![ip_fragmentation_example][def5]  
    - 마지막 fragment의 크기는 1040 bytes
    - 두 개의 헤더가 추가되었기 때문  
    - 하나의 Datagram에서 쪼개어졌음을 `ID` 필드로 식별  
    - `fragflag` 필드로 마지막 fragment인지 아닌지 식별 (더 있으면 `1`, 마지막이면 `0`)  
    - `offset` 필드로 순서(시작점)를 식별  

- 그러나 Fragmentation은 바람직하지 않음
  - 라우터의 부하 증가
  - Fragment 하나만 손실되어도, 전체 datagram이 손실됨  

- Solution?  
-> Path MTU Discovery  

<br>

- IP Addressing: Introduction  
![ip_addressing_intro][def6]  
  - IP address : 각 호스트(or 라우터) 인터페이스에 할당된 32-bit identifier  

  - Interface
    - 호스트/라우터와 물리적 링크 간의 연결
    - 라우터는 일반적으로 여러 인터페이스를 가짐
    - 호스트는 일반적으로 하나 or 두 개의 인터페이스를 가짐 (유선, 무선)  

  - Q. 인터페이스들은 실제로 어떻게 연결되는가?  
  ![ip_addressing_intro_answer][def7]  
  -> 추후 다룹니다.  

  <br>

- Subnet
  - What's a subnet?  
  -> 라우터의 개입 없이 직접 물리적으로 서로 도달할 수 있는 디바이스 인터페이스  
  -> 즉, 라우터 이전의 내부 네트워크 집합  
  - IP 주소는 두 부분으로 나뉨
    - (1) Subnet ID : 호스트가 속한 subnet을 식별 (상위 `n`비트)
    - (2) Host ID : 호스트를 식별 (e.g., 하위 `32-n`비트)
  - 상위 `n`비트가 Subnet ID이면, `/n` 표기법을 사용하여, `x.x.x.x/n`으로 표현 (Subnet mask)  

<br>

- 과거에는 32-bit IP 주소를 다섯 개의 클래스로 나뉘었음  
![ip_addressing_classful_1][def8]  
![ip_addressing_classful_2][def9]  
  - 예를 들어 class A를 가져가면, `2^24`개의 호스트를 가질 수 있음  
  - 그래서 많은 주소가 낭비됨  

<br>

- IP addressing: CIDR (Classless Inter-Domain Routing)
  - "cider"라고 발음
  - 주소의 **subnet 부분**에 대해 임의의 길이가 허용됨
  - format : `a.b.c.d/x` (x = 주소에서 subnet 부분의 비트 수)  
  ![ip_addressing_cidr][def16]  

<br>

- 그렇다면 두 가지 질문이 생긴다.
  - (1) 호스트는 네트워크 내에서 IP 주소를 어떻게 얻는가? (주소의 host part)  
  - (2) 네트워크 자신은 IP 주소를 어떻게 얻는가? (주소의 subnet part(network part))
  - 즉, IP 주소를 어떻게 얻는가?

- Q1. How does a host get IP address?
  - (1) config 파일 내 sysadmin으로 하드 코딩 (e.g., /etc/rc.config in UNIX)
  - (2) DHCP (Dynamic Host Configuration Protocol)  
    - 서버로부터 동적으로 주소를 get
    - "Plug-and-play"  

- Dynamic Host Configuration Protocol (DHCP)  
  - 목표 : 호스트가 네트워크에 "join"할 때, 네트워크 서버로부터 IP 주소를 얻음
    - 사용 중인 주소에 대한 임대 갱신 가능  
    - 주소에 대한 재사용 가능
    - 네트워크르르 들락날락하는 모바일 유저들에 대한 지원  

  - DHCP overview
    - (1) 호스트는 **DHCP discover** 메시지를 브로드캐스트로 보냄
    - (2) DHCP 서버는 **DHCP offer** 메시지로 응답 (가능한 IP 주소를 제안)
    - (3) 호스트는 **DHCP request** 메시지로 IP 주소를 요청
    - (4) DHCP 서버는 **DHCP ACK** 메시지로 요청을 승인  
    ![dhcp_overview_1][def10]  
    ![dhcp_overview_2][def11]  
    ![dhcp_overview_3][def12]  

  - (1), (2) 두 단계는 만약 클라이언트가 이전에 할당되었던 네트워크 주소를 기억하고 재사용하길 원한다면 생략될 수 있음  

  - 왜 (2) 단계에서 받은 IP 주소를 바로 사용하지 않는가?
    - 클라이언트는 브로드캐스트로 discover 메시지를 보냈기 때문에, 여러 DHCP 서버로부터 offer 메시지를 받을 수 있음  
    - 따라서 클라이언트는 그 중 하나를 선택하여 request 메시지를 보내야 하기 때문  

  - DHCP는 단순히 IP 주소 뿐만 아니라, 더 많은 정보도 반환해줌
    - 클라이언트의 first-hop 라우터 주소
    - DNS 서버의 이름과 IP 주소
    - 네트워크 마스크 (network vs host의 비율을 나타내는)  
    
  - 이 모든 정보들이 네트워킹을 위한 인터페이스를 설정하는 데 필요함

  - DHCP example  
  ![dhcp_example_1][def13]  
  ![dhcp_example_2][def14]  

- Q2. How does network get subnet part of IP address?
  - 자신의 provider ISP의 주소 공간의 할당된 일부를 get  
  ![how_does_network_get_subnet_part_of_ip_address][def15]  

- Hierarchical addressing: Route aggregation  
  - Hierarchical addressing은 라우팅 정보에 대한 효율적인 표현을 가능하게 함  
  ![hierarchical_addressing_route_aggregation][def17]  

  - 위 상황에서 Organization 1이 Fly-By-Night-ISP로부터 ISPs-R-Us로 이동했다.
    - ISPs-R-Us는 이제 Organization 1으로의 더 구체적인 경로를 광고해야 함  
    ![hierarchical_addressing_route_aggregation_example][def18]  

- 그렇다면 ISP는 어떻게 IP 주소 블록을 얻는가?
  - Internet Corporation for Assigned Names and Numbers (ICANN)
    - 5개의 Regional registries(RRs)를 통해 IP 주소들을 할당
    - DNS root zone과 delegation of individual TLD(.com, .edu, ...) 관리

  - 이와 같은 32-bit 주소는 충분한가?
    - ICANN은 2011년에 RRs에 마지막 IPv4 주소 chunk를 할당했음
      - NAT가 IPv4 주소 공간의 부족을 완화하는 데 도움을 줌
      - IPv6는 128-bit 주소 공간을 제공함  

<br>

### 2. NAT & IPv6
- NAT : 로컬 네트워크의 모든 디바이스들이 단 하나의 IPv4 주소를 공유할 수 있게 함  
![nat][def19]  
  - Public IP address : 인터넷에서 라우팅 가능한 주소. Unique.
  - Private IP address : 로컬 네트워크 내에서만 유효한 주소. Unique하지 않음.  
    - `10/8`, `172.16/12`, `192.168/16`  
  - 로컬 네트워크에서 인터넷에 패킷을 보낼 때, NAT 라우터는 패킷의 출발지 주소를 자신의 public IP 주소로 바꿈  
  - Advantages
    - 모든 디바이스에 대해 provider ISP로부터 단 하나의 public IP 주소만 필요함
    - 네트워크 내 호스트의 주소를 바깥 세상에 알리지 않고도 바꿀 수 있음
    - 로컬 네트워크 디바이스들의 주소를 ISP 변경 없이 바꿀 수 있음
    - 보안: 로컬 네트워크 내 디바이스들은 직접 접근 불가하고, 밖에서 보이지 않음

- Two identifiers
  - `L`<sub>`addr`</sub> : 소스 IP 주소 (private IP), port `#`
  - `G`<sub>`addr`</sub> : NAT IP 주소 (globally routable IP), new port `#`

- Implementation: NAT 라우터는 반드시 (투명하게)
  - 나가는 datagrams에 대해서, `L`<sub>`addr`</sub>을 `G`<sub>`addr`</sub>로 바꿔야함
    - 원격 클라이언트/서버들은 `G`<sub>`addr`</sub>을 목적지 주소로 사용하여 응답할 것이다.
  - NAT translation table에서 `L`<sub>`addr`</sub>와 `G`<sub>`addr`</sub>의 매핑을 유지해야함  
  - 모든 들어오는 datagram에 대하여 destination field의 `G`<sub>`addr`</sub>를 NAT translation table에 저장되어있는 적절한 `L`<sub>`addr`</sub>로 바꿔야함  

- Network Address Translation  
![nat_translation_table][def20]  

<br>

- NAT의 controversies
  - 라우터는 Layer 3 까지만 처리할 수 있음
  - 주소 부족 문제는 IPv6로 해결되어야 함
  - end-to-end argument 위배 (network-layer 장비의 포트 번호 변경)
  - NAT traversal: 만약 클라이언트가 NAT 뒤의 서버에 접속하고 싶다면?
    
- 그러나 NAT는 여전히 널리 사용됨
  - 가정과 기관 네트워크, 4G/5G 네트워크에서 매우 많이 사용됨  

<br>

- IPv6 motivation
  - 초기 motivation : 32-bit IPv4 주소 공간이 모조리 할당될 것  
  - 추가적인 motivation
    - 더 빠른 processing/forwarding
      - 40-byte fixed-length header
      - IPv4 header는 optional fields 때문에 variable-length  
    - 서로 다른 network-layer "flows"에 대한 구별  

- IPv6 Datagram format  
![ipv6_datagram_format][def21]  
  - IPv4와 비교했을 때, 사라진 것  
    - (1) No checksum (라우터의 처리 속도 향상)
    - (2) No fragmentation / reassembly
    - (3) No options (upper-layer, next header에서 available)  

- Extension headers
  - IPv6 header 다음에 올 수 있는 0개 이상의 headers
  - `next hdr` 필드에 적혀있는 것이 있다면, selective하게 처리됨  
  - recommanded order에 따라 나타남  
  ![extension_headers][def22]  

- IPv6 Addressing
  - 128-bit 주소
  - 8개의 네 자리수 16진수로 표현. No dotted decimal notation  
  ![ipv6_addressing][def23]  

  - 축약 표현 규칙  
    - Rule 1. 모두 `0`인 그룹은 `::`로 표현 가능 (한 번만)  
    ![ipv6_reduction_example_1][def24]  
    - Rule 2. 선행하는 `0`은 생략 가능  
    ![ipv6_reduction_example_2][def25]  
    ![ipv6_reduction_example_combination][def26]  

  - A few more examples for shortening addresses
    - Match-all address (`0.0.0.0` in IPv4)
      - `0000:0000:0000:0000:0000:0000:0000:0000` -> `::`
    - Loop-back address (`127.0.0.1` in IPv4)
      - `0000:0000:0000:0000:0000:0000:0000:0001` -> `::1`
    - All-nodes multicast address (`224.0.0.1` in IPv4)
      - `FF02:0000:0000:0000:0000:0000:0000:0001` -> `FF02::1`
    - Random link-local address
      - `FE80:0000:0000:0000:0F19:1FAF:0008:5010` -> `FE80::F19:1FAF:8:5010`  

<br>

- CIDR notation in IPv6  
![cidr_notation_in_ipv6][def27]  
  - 일반적으로, prefix length는 4의 배수  
  ![cidr_ipv6_prefix_length][def28]  

<br>

- IPv6 address types
  - Unicast
    - IPv6 enabled node의 **a single interface**를 위한 식별자  
    - **One-to-one** 커뮤니케이션

  - Multicast
    - 서로 다른 IPv6 enabled nodes에 속한 **a set of interfaces**를 위한 식별자
    - **One-to-many** 커뮤니케이션

  - Anycast
    - 서로 다른 IPv6 enabled nodes에 속한 **a set of interfaces**를 위한 식별자
    - **One-to-closest** 커뮤니케이션 (best routing metric)  

  - **No Broadcast address**

  - 128-bits address space  
  ![ipv6_address_space][def29]  

- Special addresses
  - Link local address : 모든 IPv6 인터페이스에 auto-configured된 unicast address의 특수한 타입
    - globally unique할 필요 없이, 특정 링크에 부착되어 노드가 커뮤니케이션 할 수 있게 함
    - e.g., 만약 우리가 여러 IPv6 노드를 스위치에 연결하면, 이들은 인터페이스를 link-local address로 auto-configure하여 서로를 발견하고 커뮤니케이션 할 수 있음  
    - 라우터는 link-local source/destination address를 가지는 패킷을 포워딩하지 않음
    - `FE80::/10` prefix와 인터페이스의 MAC 주소를 조합하여 생성  
    ![link_local_address][def30]

  - Loopback address : physical 인터페이스와 연결되지 않은 logical 인터페이스를 가리키며, 항상 활성화된 상태.
    - loopback address로 보내진 패킷은 항상 자신으로 돌아옴. 주로 테스트 용도로 사용됨.
    - IPv4에서는 `127.0.0.0/8` 전체 범위가 loopback address로 예약되어 있으나, 대부분의 운영체제는 `127.0.0.1`만 default로 사용 (localhost), 나머지는 잘 사용하지 않음.
    - IPv6에서는 `::1/128`이 loopback address로 예약되어 있음.

  - Unspecified address : 유효한 IP 주소가 없는 경우, 운영체제에서 사용. 주로 DHCP와 같은 과정에서 사용됨.
    - default 라우팅을 표시하는 데 주로 사용
    - 라우터는 unspecified address로 source/destination address가 설정된 패킷을 포워딩하지 않음
    - IPv4에서는 `0.0.0.0/32`
    - IPv6에서는 `::/128`

  - Unique local address : global unicast address와 유사. 실수로 조직 밖으로 유출되더라도, 다른 IPv6 global prefixes와 충돌하지 않음. (unique)
    - 구조가 well-known이기 때문에, 바운더리에서도 쉽게 필터링 가능
    - ISP 독립적인 주소 공간. 따라서 이 주소들은 다른 어떠한 ISP assigned ranges와도 충돌하지 않음
    - 비록 unique하지만, 라우터는 incoming/outgoing 패킷을 filter out.  
    ![unique_local_address][def31]

<br>

- Embedded IPv4 in IPv6
  - Unicast address는 아래를 가지고 있다.
    - (1) 첫 96 bits : `0`으로 세팅
    - (2) 마지막 32 bits : IPv4 주소
    - e.g., IPv4 주소가 `A.B.C.D`라면, IPv6 주소는 `0:0:0:0:0:0:A.B.C.D` or `::A.B.C.D`  
    ![embedded_ipv4_in_ipv6](TODO)  
  - IPv4와 IPv6 프로토콜 스택을 모두 지원하는 automatic tunnels에서 사용됨  
  - 하나의 인터페이스는 여러 IPv6 주소를 가질 수 있음
    - e.g., link-local address, global unicast address, embedded IPv4 address 등  

<br>

- Multicast address : 여러 인터페이스를 하나의 그룹으로 식별하는 IPv6 주소  
  - IPv4에서는 224.0.0.0/24 영역
  - IPv6에서는 `FF00::/8` 영역 (`1111 1111`로 시작)  
    - 모든 IPv6 멀티캐스트 주소는 `FF00::/8` 범위에 속함
    - 모든 well-known 멀티캐스트 주소는 `FF0X::/12`로 시작
  - 두 가지 중요한 규칙이 IPv4 & IPv6 멀티캐스트에 적용
    - (1) 멀티캐스트 그룹으로 전송되는 패킷은 항상 unicast source address를 가짐
    - (2) 멀티캐스트 주소는 패킷의 source address가 될 수 없음

  <br>

- Solicited-node multicast address
  - IPv6 multicast의 특수한 타입
  - IPv4의 broadcast delivery에 대한 더 효율적인 접근법 (no broadcast in IPv6)
    - address resolution, neighbor discovery, duplicate address detection 등에서 사용됨
  - 인터페이스의 IPv6 unicast를 사용하여 자동으로 생성됨
    - 어떤 unicast address든 대응되는 solicited-node multicast address가 있음
  - e.g., application for ARP service
    - IPv4에서 ARP(Address Resolution Protocol)는 특정 IP 주소에 대응되는 MAC 주소를 알아내기 위해 브로드캐스트를 썼음.
    - IPv6에서는 ARP가 없고, 대신 Neighbor Discovery Protocol(NDP)을 사용함
    - 요청을 보낼 때 목적지 주소는 해당 IPv6 주소에서 자동으로 파생된 solicited-node multicast address로 지정

<br>

- Transition from IPv4 to IPv6
  - 모든 라우터가 동시에 업그레이드 될 수 없음
    - No "flag days"
  
  - Q. 어떻게 IPv4 라우터와 IPv6 라우터를 혼합하여 네트워크를 운영할 수 있을까?
    - A. **Tunneling** is the answer !!

- Tunneling  
![tunneling][def32]  
  - IPv6 datagram은 IPv4 라우터 사이에서 IPv4 datagram 안에 payload로 캡슐화될 수 있음  
  - Tunneling은 4G/5G 네트워크에서 매우 일반적으로 사용됨  

- Tunneling & encapsulation  
  - IPv4 네트워크가 두 개의 IPv6 라우터와 연결  
  ![tunneling_and_encapsulation_1][def33]  
  - IPv4 터널이 두 개의 IPv6 라우터를 연결  
  ![tunneling_and_encapsulation_2][def34]  

- Tunneling Example  
![tunneling_example][def35]  

<br>

- IPv6의 Deployment  
![ipv6_deployment_1][def36]  
![ipv6_deployment_2][def37]  
  - IPv6 adoption이 점점 증가하고 있음  
  - Google : ~45%의 클라이언트들이 IPv6를 사용하여 서비스에 접속
  - NIST : US 정부 도메인의 1/3이 IPv6를 지원  
  - Very long time for deployment of new network layer
    - Limited penetration to date (즉, 아직까지는 IPv6 adoption이 제한적)
    - 대조적으로, 애플리케이션 계층 프로토콜은 훨씬 더 빠르게 채택됨  
      - 웹, 메시징, 스트리밍 미디어, 분산형 게임, 소셜 미디어, etc.
    - Why? 
      - 네트워크 계층 프로토콜은 end-to-end argument에 의해 제한됨
      - 새로운 네트워크 계층 프로토콜은 기존의 네트워크 인프라와 호환되어야 함  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 컴퓨터네트워크 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/90UJWVt.png
[def2]: https://i.imgur.com/Jskn5eM.png
[def3]: https://i.imgur.com/HEfhlUJ.png
[def4]: https://i.imgur.com/QWs5PUt.png
[def5]: https://i.imgur.com/v8ol4n2.png
[def6]: https://i.imgur.com/Fm8Bxz3.png
[def7]: https://i.imgur.com/1jzYcMY.png
[def8]: https://i.imgur.com/APsFqEW.png
[def9]: https://i.imgur.com/xxf0Ooz.png
[def10]: https://i.imgur.com/i1cOFNp.png
[def11]: https://i.imgur.com/FrWpndb.png
[def12]: https://i.imgur.com/jXHJ875.png
[def13]: https://i.imgur.com/7PZ4keT.png
[def14]: https://i.imgur.com/1Gjhe4E.png
[def15]: https://i.imgur.com/FIs1WjE.png
[def16]: https://i.imgur.com/t9ZbDNi.png
[def17]: https://i.imgur.com/hAKXqfK.png
[def18]: https://i.imgur.com/KaalXmM.png
[def19]: https://i.imgur.com/7qyPTrJ.png
[def20]: https://i.imgur.com/JrdmsmP.png
[def21]: https://i.imgur.com/PEJo88z.png
[def22]: https://i.imgur.com/UyGGods.png
[def23]: https://i.imgur.com/FIoJvOh.png
[def24]: https://i.imgur.com/HCTz8P6.png
[def25]: https://i.imgur.com/4LeqoB7.png
[def26]: https://i.imgur.com/PNc3n7o.png
[def27]: https://i.imgur.com/wN3Zz26.png
[def28]: https://i.imgur.com/nz6zQJG.png
[def29]: https://i.imgur.com/dwLYyOT.png
[def30]: https://i.imgur.com/P97xzIz.png
[def31]: https://i.imgur.com/53ndlvu.png
[def32]: https://i.imgur.com/brxZ0fJ.png
[def33]: https://i.imgur.com/zHw4ycx.png
[def34]: https://i.imgur.com/MbWhPEb.png
[def35]: https://i.imgur.com/FUllFhc.png
[def36]: https://i.imgur.com/XPRMydC.png
[def37]: https://i.imgur.com/FX2bwpw.png