---
layout: post
title: "[컴퓨터네트워크] 8주차 - SDN & ICMP"
excerpt: "Control plane in SDN, Internet Control Message Protocol (ICMP), Network management & configuration"

tags:
  - [컴퓨터네트워크]

toc: true

date: 2025-10-20
last_modified_at: 2025-10-23
---
## SDN & ICMP
### 1. Control plane in SDN
- Software Defined Network (SDN)
  - Internet network layer
    - 과거에는 distributed, per-router control plane 방식으로 구현되었음
    - Monolithic router
      - Switching hardware를 포함
      - 제조사마다 자기들만의 독점 router OS에서 Internet standard protocol(IP, RIP, IS-IS, OSPF, BGP)를 독점 구현하여 동작 (e.g., Cisco IOS). 따라서 다른 제조사의 장비와 호환이 어려움
      - 서로다른 network layer 기능에 대해 서로 다른 "middleboxes" (e.g., firewall, NAT, load balancer) 존재. 이로 인해 네트워크 구성이 복잡해짐
    - ~ 2005
      - network control plane을 다시 생각해보며 문제를 느끼기 시작.

<br>

- SDN - logically centralized control plane을 생각하게 된 이유?
  - **더 쉬운 네트워크 관리**
    - 라우터 misconfiguration을 피하고, 더 유연한 traffic flow 관리를 가능하게 함

  - Table 기반 forwarding은 **"programmable" 라우터를 가능하게 함**
    - Centralized 프로그래밍언 더 쉽다 - 라우팅 테이블은 centralized 방식으로 계산되고 그 후에 배포됨
    - Distributed 프로그래밍은 더 어려움 - 테이블을 각 모든 라우터에서 구현된 distributed 알고리즘을 통해 계산해야 함  

  - Control plane에 대한 **열린(non-proprietary) 구현**
    - 더 빠른 혁신 가능  

<br>

- SDN analogy: mainframe to PC revolution  
![sdn_analogy][def]  

<br>

- Traffic engineering    
  - Traditional routing이 겪는 어려움
  - Q1 - 만약 네트워크 관리자가 `u`->`z` 트래픽이 `u`->`x`->`y`->`z` 경로가 **아닌** `u`->`v`->`w`->`z` 경로를 따르길 원한다면?  
  ![traffic_engineering_question_1][def2]  
    - A1. link weight를 재정의하여, 라우팅 알고리즘이 경로를 올바르게 계산하도록 할 필요가 있을 것이다. (또는 새로운 라우팅 알고리즘이 필요)
    - Link weight가 유일한 컨트롤 노브이다. -> 컨트롤 가능한 파라미터가 제한적임

  - Q2. 만약 네트워크 관리자가 `u`->`z` 트래픽을 `u`->`v`->`w`->`z` 경로와 `u`->`x`->`y`->`z` 경로로 나누어 로드밸런싱 하길 원한다면?  
  ![traffic_engineering_question_2][def3]  
    - A2. 불가능하다! (또는 새로운 라우팅 알고리즘이 필요)

  - Q3. 만약 `w`가 blue 트래픽과 red 트래픽을 `z`로 다른 경로로 라우팅하길 원한다면?  
  ![traffic_engineering_question_3][def4]  
    - A3. 불가능하다! (destination-based 포워딩 & LS/DV 라우팅으로는.)

  - 그러나, SDN은 원하는 어떠한 라우팅도 가능하게 한다!  

<br>

- Software Defined Network (SDN)  
![sdn_overview][def5]  

<br>

- Data plane switches in SDN  
![sdn_data_plane][def6]  
  - 빠르고 간편한, 하드웨어에서 generalized data-plane 포워딩을 구현한 스위치들
  - Flow(포워딩) 테이블이 계산되고, controlled supervison 하에 설치됨
  - 테이블 기반 스위치 컨트롤을 위한 API (e.g., OpenFlow)
    - 무엇이 컨트롤 가능하고, 그렇지 않은 지를 정의
  - 컨트롤러와 커뮤니케이션 하기 위한 프로토콜 (e.g., OpenFlow)

- SDN Controller (network OS)  
![sdn_control_plane][def7]  
  - 네트워크 상태 정보를 유지
  - 위쪽의 네트워크 컨트롤 애플리케이션과 *northbound API*를 통해 상호작용
  - 아래쪽의 네트워크 스위치들과 *southbound API*를 통해 상호작용
  - Performance, Scalability, Fault-tolerance, Robustness를 위해 분산 시스템으로 구현됨    

- Network-control apps  
![sdn_network_control_apps][def8]  
  - 컨트롤의 "Brain"  
    - lower-level 서비스와 SDN 컨트롤러가 제공하는 API를 활용하여 control function을 구현
  - Unbundled
    - 3rd party에 의해 제공될 수 있음
    - Routing vecdor나 SDN 컨트롤러와는 독립적임  

<br>

- SDN Controller의 구성요소  
![sdn_controller_components][def9]  
  - Network control apps에 대한 interface layer : 추상화 API
  - Network-wide state management : 네트워크 링크, 스위치, 서비스에 대한 상태 - 분산 데이터베이스
  - Communication : SDN 컨트롤러와 스위치 간의 커뮤니케이션  

<br>

- OpenFlow 프로토콜  
![openflow_overview][def10]  
  - 컨트롤러와 스위치 간에서 작동
  - 메시지를 교환하기 위해 TCP가 사용된다.  
    - optional encryption
  - OpenFlow 메시지에는 세 가지 클래스가 있다.
    - Controller-to-switch
    - Asynchronous (switch-to-controller)
    - Symmetric (misc.)
  - OpenFlow API와는 별개임.
    - API는 generalized forwarding action을 구체화하는 데 사용됨  
    - API는 개발자용 명령어 라이브러리일 뿐, 내부는 신경쓰지 않음

- 주요 controller-to-switch 메시지
  - `features` : 컨트롤러는 스위치에 어느 기능이 있는지 **묻는다**.
  - `configure` : 컨트롤러는 **스위치 설정 파라미터를 쿼리/설정** 한다.
  - `modify-state` : OpenFlow 테이블에 **flow entry를 추가/수정/삭제** 한다.
  - `packet-out` : 컨트롤러는 **패킷을 특정 스위치 포트로 전송**할 수 있다.
  - `read-state` : **통계를 수집**

- 주요 switch-to-controller 메시지
  - `packet-in` : 패킷을 컨트롤러에 전달한다.  
  - `flow-removed` : flow entry가 스위치에서 제거되었음을 알린다.
  - `port-status` : 컨트롤러에 포트 상태 변경을 알린다.
  - `error` : 스위치에서 오류가 발생했음을 알린다.

- 다행히도, 네트워크 관리자는 OpenFlow 메시지를 **직접** 다루어서 **프로그래밍 할 필요는 없다**.  
대신, 컨트롤러에서 제공하는 **고수준 API**(higher-level abstraction)을 사용한다.  

<br>

- Control/data plane interaction example  
![sdn_control_data_plane_interaction][def11]  
  - (1) S1은 link failure를 경험했고, OpenFlow 메시지 `port-status`를 notify하기 위해 컨트롤러에 보낸다.
  - (2) SDN 컨트롤러는 OpenFlow 메시지를 받았고, **link status info를 업데이트** 한다.
  - (3) **Dijkstra 라우팅 알고리즘** 애플리케이션은 이전까지 link status가 변화했을 때마다 호출되도록 되어있었다. **따라서 호출된다.**  
  - (4) Dijkstra 라우팅 알고리즘이 컨트롤러의 network graph info와 link state에 액세스하여, 새로운 경로를 계산한다.  
  - (5) link state 라우팅 애플리케이션이 SDN 컨트롤러의 flow 테이블 요소와 상호작용한다. 이는 우리가 필요로하는 **새로운 flow tables를 계산한다.**
  - (6) 컨트롤러는 OpenFlow를 사용하여 업데이트가 필요한 **스위치 내 새로운 테이블을 설치** 한다.  

<br>

- OpenDayLight(ODL) controller  
![odl_controller](TODO)  

<br>

- ONOS controller  
![onos_controller](TODO)  

<br>

- SDN이 마주하고 있는 도전과제들
  - Control plane을 단단하게 만드는 것 : Dependable, reliable, performance-scalable, secure distributed system  
    - 실패에 대한 robustness : 신뢰할 수 있는 분산 시스템에 대한 강력한 이론을 활용하여 Control plane을 구축
    - Dependability, security : 처음 설계부터 완전히 충족시킬 수는 없음

  - 네트워크와 프로토콜은 mission-specific한 요구사항을 만족해야 함
    - e.g., real-time, ultra-reliable, ultra-secure

  - Internet-scaling : single AS를 넘어서 확장

  - SDN critial in 5G cellular networks

<br>

- Traditional network protocol의 미래는?
  - SDN-computed vs. router-computed forwarding tables
    - logically-centralized-computed vs. protocol computed

  - SDN-computed congestion control도 생각해볼 수 있음
    - Controller가 직접 라우터가 컨트롤러에게 알려준 congestion level을 바탕으로 sender rates를 설정

<br>

### 2. Internet Control Message Protocol (ICMP)  
- Host나 Router가 network-level 정보를 교환하기 위해 사용하는 프로토콜  
![icmp_overview](TODO)  
  - Error reporting (unreachable host, network, port, protocol 등)
  - Echo request/reply (ping에서 사용)

- IP "위의" Network layer  
![icmp_in_ip](TODO)  
  - ICMP 메시지는 IP datagram 내에 캡슐화되어 전송됨

- ICMP 메시지  
![icmp_message_format](TODO)  
  - Type, code, plus header, 그리고 error를 발생시킨 IP datagram의 처음 8바이트를 포함  
    - 왜 처음 8바이트인가? -> transport layer header (TCP/UDP header)를 포함하기 위해서
    - 그 중에서도 Port 번호와 sequence number를 포함하기 위해서

<br>

- ICMP 메시지는 type과 code의 조합에 의해 정의됨  
![icmp_types_and_codes](TODO)  

- ICMP 메시지 포맷 Examples  
  - Destination unreachable  
  ![icmp_destination_unreachable](TODO)  

  - Time exceeded  
  ![icmp_time_exceeded](TODO)  

  - Source quench (not used anymore)  
  ![icmp_source_quench](TODO)  

  - Bad parameter (redirection)  
  ![icmp_redirection](TODO)  

  - Echo request/reply  
  ![icmp_echo_request_reply](TODO)  
    - "Are you alive?"
    - IP 프로토콜의 작동을 체크하는 데 사용  

  - Timestamp request/reply  
  ![icmp_timestamp_request_reply](TODO)  
    - 다른 기기의 시간을 알아내기 위해 사용  

<br>

- ICMP & trace route  
![icmp_trace_route](TODO)  
  - Source는 Destination에 UDP segments들의 set을 보냄
    - 첫 번째 set은 TTL = 1  
    - 두 번째 set은 TTL = 2
    - ...

  - TODO  

<br>

###  3. Network management & configuration

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 컴퓨터네트워크 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/6exQM78.png
[def2]: https://i.imgur.com/1qsk1Nn.png
[def3]: https://i.imgur.com/pAoxwr2.png
[def4]: https://i.imgur.com/ZYJAtHY.png
[def5]: https://i.imgur.com/84MXZgE.png
[def6]: https://i.imgur.com/zvWaWTV.png
[def7]: https://i.imgur.com/t1DUpjT.png
[def8]: https://i.imgur.com/U1EAB2g.png
[def9]: https://i.imgur.com/OsLHABy.png
[def10]: https://i.imgur.com/79HyNYz.png
[def11]: https://i.imgur.com/YvThCGC.png