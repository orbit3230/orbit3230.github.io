---
layout: post
title: "[컴퓨터네트워크] 11주차 - Introduction to the Link Layer and LANs"
excerpt: "Introduction to the Link Layer and LANs, Error Detection and Correction, Multiple Access Protocols"

tags:
  - [컴퓨터네트워크]

toc: true

date: 2025-11-10
last_modified_at: 2025-11-20
---
## Introduction to the Link Layer and LANs
### 1. Introduction to the Link Layer and LANs
- Terminology
  - Nodes : 호스트 / 라우터
  - Links : 서로 이웃하고 있는 노드들을 연결하는 커뮤니케이션 채널
    - wired, wireless, LANs, ...
  - Frame : layer-2 패킷. encapsulated datagram

- Link layer는 datagram을 한 노드에서 물리적으로 인접한 다른 노드로 보내는 데 의무가 있다.  
![link_layer_overview][def2]  

<br>

- Link layer services
  - **Framing, link access**
    - datagram을 frame으로 캡슐화 / 헤더, 트레일러 추가
    - shared medium이라면, Channel access
    - source/destination 노트 구별을 위한 frame header 내 "MAC" addresses

  - **Reliable delivery between adjacent nodes**
    - 우리는 어떻게 하는 지 이미 알고있다 !
    - low-bit error 링크에서는 거의 필요 없음
    - Wireless 링크에서 필요 : High error rates
    - 왜 link-level & end-to-end reliability 메커니즘이 모두 사용될까?
      - link-level에서 recovery 시 end-to-end 재전송 필요성이 감소한다.  
      end-to-end에서의 recovery보다 더 빠르고 효율적임에 의심의 여지가 없다.
      - 그러나 cost-effectiveness 측면에서 항상 link-level recovery를 할 수 있는 것은 아니다.  

  - **Flow control**
    - 인접한 송신 노드와 수신 노드 사이의 속도 조절

  - **Error detection**
    - 신호 간섭이나 노이즈로 인해 에러가 발생할 수 있다.
    - 수신자는 (1) 에러를 감지하고, (2) 신호 재전송을 요청하거나 (3) 프레임을 드랍한다.

  - **Error correction**
    - 수신자는 재전송 없이 에러를 감지하고 수정할 수 있다.

  - **Half-duplex / Full-duplex**
    - Half-duplex 환경에서는 양 쪽 노드가 동시에 전송할 수는 없다.  

<br>

- Link layer는 어디에 구현되어 있을까?  
![link_layer_location][def3]  
  - 각각의 모든 호스트에 구현되어 있다.
  - 정확히는 Link layer는 Network Interface Card(NIC) 또는 Chip에 구현되어 있다.
    - Ethernet, WiFi card or chip
    - link, physical layer를 구현
  - 호스트의 시스템 버스에 연결되어 있다.
  - Hardware, software, firmware의 조합으로 구현되어 있다.  

<br>

- Interfaces Communicating  
![link_layer_interfaces][def4]  
  - 송신 측
    - Datagram을 frame으로 캡슐화
    - Error checking bits, Reliable data transfer, Flow control 등 추가

  - 수신 측
    - Error, Reliable data transfer, Flow control 등 확인
    - Datagram 추출 후 상위 계층에 전달

<br>

### 2. Error Detection and Correction
- Error detection이 항상 100% reliable한 것은 아니다.
  - 프로토콜은 몇몇 오류를 놓칠 수 있지만, 그래도 매우 드물게 발생해야 한다.
  - 더 큰 EDC 필드는 더 나은 detection과 correction을 제공한다.

- **EDC**
  - Error Detection and Correction bits (e.g., redundancy)

- **D**
  - Data protected by error checking
  - 헤더 필드를 포함할 수 있다.  
  ![d_example][def5]  

<br>

- Parity checking
  - Single bit parity
    - single bit error를 **감지**  
    ![single_bit_parity_example][def6]  

    - 짝수 패리티(even parity) : 1의 개수가 짝수가 되도록 패리티 비트를 설정  
    - 홀수 패리티(odd parity) : 1의 개수가 홀수가 되도록 패리티 비트를 설정

  - Two-dimensional bit parity
    - single bit error를 **감지 및 수정**  
    ![two_dimensional_parity_example][def7]  

<br>

- Recap: Internet checksum  
  - [데이터 통신 포스팅을 참조][def]  

<br>

- Cyclic Redundancy Check (CRC)
  - 더 강력한 에러 검출 메커니즘
  - Terms
    - `D` : data bits
    - `G` : bit pattern (generator) of `r+1` bits

  - `r` CRC bits = `R`을 고른다. `<D, R>`이 정확히 `G`로 나누어 떨어지도록.  
  ![crc_example][def8]  
    - 수신자는 사전에 `G`를 알고있다.
    - `<D, R>`을 `G`로 나눈다. 만약 나누어떨어지지 않으면 에러가 발생한 것이다.  
    - 이를 통해 `r+1` 비트보다 작은 burst error를 감지할 수 있다.  
    - 실제로 ethernet, wifi 등에서 사용되고 있다.

  - CRC example  
  ![crc_example_calculation][def9]  
    - 우리는 `D`*`2`<sup>`r`</sup> XOR `R` = `nG`를 만족하는 `R`을 원한다.
    - 이는 곧,  
    `D`*`2`<sup>`r`</sup> XOR (XOR `R`) = `nG`  
    `D`*`2`<sup>`r`</sup> = `nG` XOR `R`  
    - 따라서, `R` = remainder of [`D`*`2`<sup>`r`</sup> / `G`]  

  - 더 큰 burst error를 감지하기 위해서는 더 큰 `r`이 필요하다.  
  물론, 더 큰 `r`은 더 많은 오버헤드를 의미한다.  
  그렇지만 bit pattern `G`이 커지기 때문에, 더 나은 에러 검출 능력을 제공한다.  

<br>

### 3. Multiple Access Protocols
- Two types of "links"
  - Point-to-point
    - 이더넷 스위치와 호스트 간의 Point-to-point 링크
    - dial-up 액세스를 위한 PPP
  
  - Broadcast (shared wire or medium)
    - Old-fashioned 이더넷
    - cable-based 액세스에서의 Upstream HFC
    - IEEE 802.11 무선 LANs, 4G/5G, satellite  

<br>

- Multiple access protocols
  - Single shared broadcast channel
  - 두 개 이상의 노드에서 동시 전송 -> **간섭**(interference)
    - 한 노드가 두 개 이상의 시그널을 동시에 받으면 -> Collision

  - **Multiple access protocol**
    - 어떻게 노드들이 채널을 공유하는 지를 결정하는 분산 알고리즘
    - 채널 공유 제어를 위한 통신은 채널 자체를 사용해야 한다.
      - No out-of-band channel for coordination

- Ideal Multiple access protocol
  - Given
    - `R`bps의 Multiple access channel

  - Desirable
    - **Fully utilized** : 하나의 싱글 노드가 전송을 원할 때, `R`bps로 전송할 수 있다.
    - **Fairly shared** : `N`개의 노드가 전송을 원할 때, 각 노드는 `R/N`bps로 전송할 수 있다.  
    - **Fully decentralized**
      - 전송을 coordinate할 특수 노드가 없어야 한다.
      - clock이나 slots에 대한 동기화가 없어야 한다
    - **Simple**

<br>

- Three broad classes of MAC protocols
  - **Channel partitioning**
    - 채널을 더 작은 서브채널로 나눔 (time slot, frequency, code, etc.)
    - Exclusive use를 위한 조각을 노드에 할당

  - **Random access**
    - 채널을 나누지 않고, Collision을 허용
    - 충돌이 발생하면 "Recover"

  - **Taking turns**
    - 노드는 차례를 가진다. 다만, 더 전송할 것이 있는 노드는 더 긴 차례를 가질 수 있다.  

<br>

- Channel partitioning: TDMA
  - Time Division Multiple Access (TDMA)  
  ![tdma_example][def10]
    - 순서대로 채널에 액세스
    - 매 차례바다, 각 station은 고정 길이의 **slot**을 받음 (length = 패킷 전송 시간)
    - 사용되지 않는 slots은 idle 상태
    - LAN에 6개의 station이 있는 Example  
      - Slots 1, 3, 4 : 보낼 패킷이 있음
      - Slots 2, 5, 6 : idle  

- Channel partitioning: FDMA
  - Frequency Division Multiple Access (FDMA)  
  ![fdma_example][def11]
    - 채널 스펙트럼이 **frequency bands**로 나누어짐
    - 각 station은 고정 frequency band를 받음
    - 사용되지 않는 frequency bands는 idle 상태
    - LAN에 6개의 station이 있는 Example  
      - Bands 1, 3, 4 : 보낼 패킷이 있음
      - Bands 2, 5, 6 : idle  

- Random access protocols
  - 노드가 보낼 패킷이 있을 때,  
    - `R`의 full channel rate로 전송
    - 노드 간 prior coordination 없음  
  - 두 개 이상의 전송하려는 노드가 있다면 -> "collision" 발생 가능
  - Random access MAC protocol은 다음을 정의한다.
    - 어떻게 collision을 감지할 지
    - 충돌이 발생하면 어떻게 복구할 지  

  - Examples
    - ALOHA, slotted ALOHA
    - CSMA, CSMA/CD, CSMA/CA  

<br>

- SLOTTED ALOHA
  - 가정
    - 모든 프레임 길이는 동일
    - 시간은 같은 크기의 슬롯으로 나누어짐 (1 프레임 전송에 걸리는 시간)
    - 노드는 오직 슬롯의 시작 부분에서만 전송 가능
    - 만약 같은 슬롯에서 두 개 이상의 노드가 전송을 시도하면 -> 모든 노드가 충돌을 감지  

  - 동작
    - 노드가 새로운 프레임을 가지고 있다면, 다음 슬롯에서 전송 시도
      - 충돌 X -> 노드는 새로운 프레임을 다음 슬롯에서 전송할 수 있음
      - 충돌 O -> 노드는 성공할 때 까지 매 슬롯마다 확률 `p`로 프레임 재전송 시도  

  - 장점
    - 하나의 active 노드가 계속해서 full channel rate로 전송 가능
    - Highly decentralized - 오직 슬롯 동기화만 필요
    - Simple

  - 단점
    - 충돌이 발생하면 전체 슬롯이 낭비됨
    - Idle slots (for random backoff)
    - Clock synchronization 필요
    - 노드가 slot-duration 도중에 충돌을 감지하더라도, 즉각 전송을 중단할 수 없음. 즉각적인 조치는 불가능  

  - 효율성 : Long-run fraction of successful slots

  - 간단한 성능 분석
    - 많은 프레임을 전송해야 할 노드가 `N`개
    - 각각은 슬롯에서 `p`의 확률로 전송 시도
      - 슬롯에서 주어진 노드가 성공적으로 전송할 확률 = `p(1-p)`<sup>`N-1`</sup>  
      - 슬롯에서 어떤 노드가 성공적으로 전송할 확률 = `Np(1-p)`<sup>`N-1`</sup>
      - `Np(1-p)`<sup>`N-1`</sup>를 최대화하는 `p`<sup>`*`</sup> = `1/N`  
      - 최대 효율성 = `N(1/N)(1-1/N)`<sup>`N-1`</sup> → `1/e` ≈ `0.37` (`N` → `∞`) 로 수렴  

<br>

- Pure ALOHA
  - Unslotted ALOHA : 더 간단하고, synchronization이 없음
    - 프레임이 생성되면, 즉시 전송됨

  - Synchronization이 없기 때문에, 충돌 확률이 더 높음
    - `t`<sub>`0`</sub>에 보내진 프레임은 `[t`<sub>`0`</sub>`-1`, `t`<sub>`0`</sub>`+1]` 구간에 보내진 다른 프레임과 충돌 가능  
    - 최대 효율성 = `1/(2e)` ≈ `0.18` (`N` → `∞`) 로 수렴  
      - Slotted ALOHA 보다 더 좋지 못하다.  

<br>

- Carrier Sense Multiple Access (CSMA)
  - Simple CSMA
    - 전송하기 전에 Listen.
    - 만약 채널이 idle로 감지되면, 전체 프레임을 전송
    - 만약 채널이 busy로 감지되면, 전송을 나중으로 연기  
    -> Don't Interrupt Others !

  - CSMA/CD
    - CSMA + Collision Detection
    - Collision은 짧은 시간 내에 감지됨
    - Collision을 발생시키는 전송을 중단하여, 채널 낭비를 줄임
    - Collision 감지는 유선 환경에서 쉽지만, 무선 환경에서는 어렵다.  
    -> The Polite Conversationist !

  - Collision in CSMA  
  ![csma_collision_example][def12]  
    - Collision은 Carrier sensing을 하더라도 여전히 발생할 수 있다.
      - Propagation delay가 존재하기 때문에, 두 노드는 서로가 이제 막 전송을 시작했음을 당장 모를 수 있다.  
    - Collision
      - 전체 패킷 전송 시간이 낭비된다.
      - Distance & Propagation delay가 Collision 발생 확률에 영향을 미친다.  

- CSMA/CD는 Collision에서 시간 낭비를 줄인다.  
![csma_cd_collision_example][def13]  

<br>

- Ethernet CSMA/CD Algorithm
  - (1) NIC(Network Interface Card)가 네트워크 계층으로부터 datagram을 받아 frame 생성
  - (2) NIC가 채널을 Sense.
    - 만약 idle이면 -> 프레임 전송 시작
    - 만약 busy면 -> 채널이 idle이 될 때까지 기다렸다가 전송
  - (3) 만약 NIC가 Collision 없이 전체 프레임을 전송했다면, 전송 완료
  - (4) 만약 전송 도중 다른 전송을 감지한다면, **멈추고**, **jam signal** 전송
  - (5) 전송 중지 후, NIC는 **Binary Exponential Backoff** 알고리즘을 사용하여 재전송 시간 결정
    - `m`번째 Collision 이후, NIC는 `{0, 1, 2, ..., 2`<sup>`m`</sup>`-1}` 중 하나의 정수 `K`를 무작위로 선택
    - NIC는 `K` x `512` 비트 타임동안 기다렸다가 (2)로 돌아감
    - 더 많은 Collisions -> 더 긴 backoff interval  

<br>

- Efficiency of CSMA/CD
  - `T`<sub>`prop`</sub> : 두 노드 간 최대 propagation delay
  - `T`<sub>`trans`</sub> : max-size 프레임을 전송하는 데 걸리는 시간
  - Efficiency  
  ![csma_cd_efficiency_formula][def14]  
    - `T`<sub>`prop`</sub> 이 `0`으로 가거나, `T`<sub>`trans`</sub> 이 `∞`로 갈수록 효율성은 `1`에 가까워진다.  

  - ALOHA보다 더 나은 성능을 보인다.
  - 게다가 더 간단하고, 값 싸고, Decentralized하다.  

<br>

- "Taking turn" MAC protocols
  - **Polling**  
  ![polling_example][def15]
    - Master 노드가 전송할 차례에 있는 다른 노드를 "invites"
    - 주로 "dumb" devices에서 사용
    - 문제점
      - Polling overhead
      - Latency
      - Single point of failure (master node)  
    - 그럼에도 random access는 이론상 무한한 대기 시간을 가질 수 있기 때문에,  
    "Taking turn" 프로토콜은 Wifi와 같은 무선 네트워크에서 종종 사용된다.  

  - **Token passing**  
  ![token_passing_example][def16]  
    - Control 토큰이 한 노드에서 다음 노드로 순서대로 전달됨  
    - Token message
    - 문제점
      - Token overhead
      - Latency
      - Single point of failure (token loss)

<br>
    
- Cable access network
  - FDM, TDM, and random access
  - Multiple downstream (broadcast) FDM channels: up to 1.6Gbps/channel
    - 하나의 CMTS가 여러 채널에 전송 -> no multiple access 문제
  - Multiple upstream channels: up to 1Gbps/channel
    - Multiple access : 모든 유저가 upstream channel time slots을 경쟁
    - 나머지는 TDM 방식대로 assign  
    ![cable_access_network_example][def17]  

  - DOCSIS (Data Over Cable Service Interface Specification)
  - upstream/downstream frequency 채널에 대해서는 FDM
  - TDM upstream : 몇몇 슬롯은 assigned, 나머지는 경쟁
    - random access 방식에 있는 upstream 슬롯에 대해 Request
    - Downstream MAP frame : upstream 슬롯 할당  
    ![cable_docsis_example][def18]  

  <br>

- Summary of MAC protocols
  - Channel partitioning by 시간, 주파수, 코드
    - Time division, Frequency division, Code division

  - Random access (dynamic)
    - ALOHA, Slotted ALOHA, CSMA, CSMA/CD, CSMA/CA
    - Carrier sensing : 몇몇 기술에서는 쉽지만(wired), 몇몇 기술에서는 어려움(wireless)
    - CSMA/CD : ethernet에서 사용됨
    - CSMA/CA : IEEE 802.11 무선 LAN에서 사용됨

  - Taking turns
    - Polling from a master node, Token passing
    - Bluetooth, FDDI, token ring

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 컴퓨터네트워크 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://orbit3230.github.io/2025/05/08/DC_week10/#3-connectionless-transport-udp
[def2]: https://i.imgur.com/SsvxmHk.png
[def3]: https://i.imgur.com/cok437b.png
[def4]: https://i.imgur.com/mgxATkj.png
[def5]: https://i.imgur.com/C3fCRhm.png
[def6]: https://i.imgur.com/pUbHBcB.png
[def7]: https://i.imgur.com/u2cjCpj.png
[def8]: https://i.imgur.com/SQEC68N.png
[def9]: https://i.imgur.com/ixXwL3S.png
[def10]: https://i.imgur.com/RN5RWD7.png
[def11]: https://i.imgur.com/pTiRseZ.png
[def12]: https://i.imgur.com/nphTzFs.png
[def13]: https://i.imgur.com/qlJsPmF.png
[def14]: https://i.imgur.com/QF7aCrK.png
[def15]: https://i.imgur.com/WlrQFuD.png
[def16]: https://i.imgur.com/is7lnot.png
[def17]: https://i.imgur.com/URc2QRz.png
[def18]: https://i.imgur.com/DFQoEeV.png