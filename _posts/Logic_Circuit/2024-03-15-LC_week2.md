---
layout: post
title: "[논리회로] 2주차 - 논리 게이트와 수 체계, 음수 표현"
excerpt: "논리 연산, 논리 게이트, 2, 8, 10, 16진수, 부호화-크기 표현, 1의 보수, 2의 보수"

tags:
  - [논리회로]

toc: true

date: 2024-03-08
last_modified_at: 2024-03-08
---
## 논리 게이트
- **2진 정보를 처리**하기 위한 **기본적인 논리회로 부품**이다.  

- 트랜지스터들을 이용하여 구현할 수 있다.  

- 여러 가지 논리 연산들을 지원할 수 있도록 다양한 종류가 존재한다.  
  - 다양한 종류의 논리 게이트들을 알아보자.

  <br>

### 1. `NOT` 게이트 - 7404 Gate
- 입력 신호를 반전시켜 출력하는 논리 게이트
  - 따라서, 인버터(inverter) 라고도 부른다.

- 논리 표현식
  - `Y = `<span style="text-decoration: overline">`A`</span>

- 기호와 진리표  
![not_gate][def]

<br>

### 2. `OR` 게이트 - 7432 Gate
- `OR` 연산을 수행하는 논리 게이트

- 논리 표현식
  - `Y = A + B`

- 기호와 진리표  
![or_gate][def2]

<br>

### 3. `AND` 게이트 - 7408 Gate
- `AND` 연산을 수행하는 논리 게이트

- 논리 표현식
  - `Y = AB`

- 기호와 진리표
![and_gate][def3]

- `Y = A + B`
### 4. `XOR` 게이트 - 7486 Gate
- `XOR` 연산을 수행하는 논리 게이트
  - `XOR`(eXclusive OR) 연산이란,  
  두 입력이 서로 다르면 1, 같으면 0을 발생시키는 연산  

- 논리 표현식
  - `Y = `<span style="text-decoration: overline">`A`</span>`B + A`<span style="text-decoration: overline">`B`</span>

- 기호와 진리표  
![xor_gate][def4]

- 네트워크에서 페리티 코드를 만들 때 사용함.
  - 1의 개수만 체크하는 기법
    - 페리티코드가 0 : 1의 개수가 짝수
    - 페리티코드가 1 : 1의 개수가 홀수

- 암호문을 만들 때에도 사용함.

<br>

### 5. `NAND` 게이트 - 7400 Gate
- `NAND` 연산을 수행하는 게이트
  - `NAND` 연산이란,  
  `AND` 연산과 반대되는 출력을 발생시키는 연산

- `Y = `<span style="text-decoration: overline">`AB`</span>
- 기호와 진리표  
![nand_gate][def5]

<br>

### 6. `NOR` 게이트 - 7402 Gate
- `NOR` 연산을 수행하는 게이트
  - `NOR` 연산이란,  
  `OR` 연산과 반대되는 출력을 발생시키는 연산  

- `Y = `<span style="text-decoration: overline">`A+B`</span>
- 기호와 진리표  
![nor_gate][def6]

<br>

### 7. `XNOR` 게이트 - 74266 Gate
- `XNOR` 연산을 수행하는 게이트
  - `XNOR` 연산이란,  
  두 입력이 서로 다르면 0, 같으면 1을 발생시키는 연산

- `Y = AB+`<span style="text-decoration: overline">`A`</span><span style="text-decoration: overline">`B`</span>
- 기호와 진리표  
![xnor_gate][def7]

<br>

### 8. 조합회로
- 논리 게이트들로만 구성한 회로 모듈.

- 각각의 게이트가 입력 신호를 받아 연산 수행 후 출력,  
해당 출력을 또 다시 다음 게이트로 입력되어 처리  
-> 반복하며 최종 결과를 생성.  

- 이전의 신호에 대한 기록은 남기지 않으며, 
오직 현재 신호에 대해서만 연산을 수행하고 출력을 발생시키기만 한다.  

<br>

- 주로,
  - 2-비트 가산기(2-bit adder)
  - BCD-7SEG 디코더(BCD-to-seven segment decoder)

<br>

### 9. 순차회로
- 논리 게이트들과 기억 소자(memory element)로 구성한 회로 모듈.

  - 기억 소자는 플립-플롭(flip-flop)을 사용

- 기억 소자에 이전의 결과들이 저장되고, 새로운 연산 후 출력을 발생시킬 때  
해당 시점의 입력과 더불어 저장되어있던 이전의 값들도 함께 이용한다.  

<br>

- 가장 복잡한 논리회로 :
  - 디지컬 컴퓨터(기억 소자로서 반도체 기억 장치를 이용)

<br>

## 수 체계(number system)
### 1. 10진수(demical number)
- **0 ~ 9** 까지의 10진 숫자들을 사용

### 2. 2진수(binary number)
- **2진 숫자**(binary digit) = 비트(bit) = `0` 혹은 `1`

### 3. 8진수(octal number)
- **0 ~ 7** 까지의 8진 숫자들을 사용  

### 4. 16진수
- **0 ~ F(15)** 까지의 16진 숫자들을 사용 

<br>

## 2진수 표현
- 비트(bit) - binary digit의 약자로서,  
디지털 시스템에서 수나 문자같은 정보를 표현하는 기본 단위.  
`0` 또는 `1`을 가지는 2진수 표현이다.  

- 비트 수(`n`)가 많아질수록, 표현 가능한 범위가 증가한다.  
`0 - (2`<sup>`n`</sup>`-1)`

### 1. 2진수 -> 8진수 간 변환
  - 2진수의 자리 값을 세 자리씩 끊어 읽는다.  

### 2. 2진수 -> 16진수 간 변환
- 2진수의 자리 값을 네 자리씩 끊어 읽는다.  

### 3. 소수점 이하의 10진수 -> 2진수 변환
- 변환 방법
  - (1) 1보다 작은 10진수에 2를 곱한다.
  - (2) 결과값이 1보다 작으면 `0`을 기록, 1보다 크면 `1`을 기록하고 1을 뺀다.
  - (3) 결과값이 정확히 0이 될 때까지 반복한다.  

- 하지만, 소수점을 2진수로 표현하려면 비트의 개수는 제한적이므로  
**오차가 발생** 할 수 밖에 없다.  
비트 수(`n`)가 커질수록, 오차는 줄어들 수는 있다.

### 4, 소수점 이하의 2진수 -> 10진수 변환
- 소수점 우측으로 `n = 2`<sup>`-1`</sup> 부터 차수가 1씩 작아지는  
Coefficient를 곱하여 나온 값을 더한다.

<br>

## 음수 표현
### 1. 부호화-크기 표현
- ***signed-magnitude representatiion***

- 가장 앞 비트를 부호 비트(MSB)로 사용하고,  
나머지 비트로 절댓값(수의 크기, magnitude)을 나타내는 아주 간단한 방법이다.

  - 최대 표현 범위 : `-(2`<sup>`n-1`</sup>`-1) ~ +(2`<sup>`n-1`</sup>`-1)`

- 하지만, 문제가 발생한다.
  - (1) 덧셈 연산을 수행할 때, 부호 비트와 나머지 비트 부분을 따로 처리해야한다.  
  (e.g., 부호가 서로 다른 덧셈 연산)

  - (2) **0에 대한 표현이 두 개**이다.
    - `00000000` = `+0`
    - `10000000` = `-0`

<br>

### 2. 1의 보수 표현
- ***1's complement representation***

- 음수 표현 시, 모든 비트들을 반전시킨다. (`~`)

  - 최대 표현 범위 : `-(2`<sup>`n-1`</sup>`-1) ~ +(2`<sup>`n-1`</sup>`-1)`

- 하지만, 1의 보수 표현 또한 같은 문제가 발생한다.
  - **0에 대한 표현이 두 개**이다.
    - `00000000` = `+0`
    - `11111111` = `-0`

<br>

### 3. 2의 보수 표현
- ***2's complement representation***

- 음수 표현 시, 모든 비트들을 반전시키고 `+1` 한다.  

  - 최대 표현 범위 : `-2`<sup>`n-1`</sup>` ~ +(2`<sup>`n-1`</sup>`-1)`

- 2의 보수 표현은, `+1`을 하는 과정에서 만약 MSB로 부터 올림수가 발생하면 버린다.  
따라서, `00000000`의 1의 보수 표현인 `11111111`에서 `+1`을 하면  
`00000000`이다.  
  - 따라서, **0을 나타내는 표현이 단 하나**이다.

- 이런 이유로서, **컴퓨터는** 음수 표현 방식으로 **2의 보수** 표현을 채택하였다.

  <br>

### 4. 각 표현 별 예시
(8 bit 기준)
- `+24`  
  - 부호화 크기 : `00011000`  
  - 1의 보수 : `00011000`  
  - 2의 보수 : `00011000`  

- `-24`  
  - 부호화 크기 : `10011000`  
  - 1의 보수 : `11100111`   
  - 2의 보수 : `11101000`

역으로 변환
- `11001011`
  - 부호화 크기 : `01001011` -> `-75`
  - 1의 보수 : `00110100` -> `-52`
  - 2의 보수 : `00110101` -> `-53`
    - 참고로, `0`이 더 많이 들어있는 2진수 표현을 2의 보수표현 하 10진수로 변환 할 때는,  
    첫 비트만 첫 비트만 음수로 취급하여 모두 더하면 같은 값이 나온다.  
    (e.g., `10000011` -> `-128 + 2 + 1 = -125`)

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 허정화 교수님의 논리회로 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>

[def]: https://i.imgur.com/iMOCUNf.png
[def2]: https://i.imgur.com/zjoigDa.png
[def3]: https://i.imgur.com/DkvvVN9.png
[def4]: https://i.imgur.com/f5FeB0w.png
[def5]: https://i.imgur.com/ByDtMGk.png
[def6]: https://i.imgur.com/lS0xKku.png
[def7]: https://i.imgur.com/RqV9ygk.png