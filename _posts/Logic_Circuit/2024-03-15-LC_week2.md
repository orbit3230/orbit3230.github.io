---
layout: post
title: "[논리회로] 2주차 - "
excerpt: ""

tags:
  - [논리회로]

toc: true

date: 2024-03-08
last_modified_at: 2024-03-08
---
## 논리 연산
### 1. `NOT` 연산
### 2. `OR` 연산
### 3. 


## 논리 게이트
### 1. `NOT` 게이트
- 입력 신호를 반전시켜 출력하는 논리 게이트
  - 따라서, 인버터(inverter) 라고도 부른다.

- 논리 표현식
  - `Y = `<span style="text-decoration: overline">`A`</span>

- 기호와 진리표  
![not_gate]()

<br>

### 2. `OR` 게이트 - 7432 Gate
- `OR` 연산을 수행하는 논리 게이트

- 논리 표현식
  - `Y = A + B`

- 기호와 진리표  
![or_gate]

<br>

### 3. `AND` 게이트 - 7408 Gate
- `AND` 연산을 수행하는 논리 게이트

- 논리 표현식
  - `Y = AB`

- `Y = A + B`
### 4. `XOR` 게이트 - 7486 Gate
- `XOR` 연산을 수행하는 논리 게이트
  - `XOR`(eXclusive OR) 연산이란,  
  두 입력이 서로 다르면 1, 같으면 0을 발생시키는 연산  

- 논리 표현식
  - `Y = `<span style="text-decoration: overline">`A`</span>`B + A`<span style="text-decoration: overline">`B`</span>
- 기호와 진리표  
![xor_gate]()

- 네트워크에서 페리티 코드를 만들 때 사용함.
  - 1의 개수만 체크하는 기법
    - 페리티코드가 0 : 1의 개수가 짝수
    - 페리티코드가 1 : 1의 개수가 홀수

- 암호문을 만들 때에도 사용함.

<br>

### 5. `NAND` 게이트
- `NAND` 연산을 수행하는 게이트
  - `NAND` 연산이란,  
  `AND` 연산과 반대되는 출력을 발생시키는 연산

- `Y = `<span style="text-decoration: overline">`AB`</span>
- 기호와 진리표  
![nand_gate]()

<br>

### 6. `NOR` 게이트 - 7402 Gate
- `NOR` 연산을 수행하는 게이트
  - `NOR` 연산이란,  
  `OR` 연산과 반대되는 출력을 발생시키는 연산  

- `Y = `<span style="text-decoration: overline">`A+B`</span>
- 기호와 진리표  
![nor_gate]()

<br>

### 7. `XNOR` 게이트
- `XNOR` 연산을 수행하는 게이트
  - `XNOR` 연산이란,  
  두 입력이 서로 다르면 0, 같으면 1을 발생시키는 연산

- `Y = AB+`<span style="text-decoration: overline">`A`</span><span style="text-decoration: overline">`B`</span>
- 기호와 진리표  
![xnor_gate]()

<br>

### 8. 조합회로

<br>

### 9. 순차회로

<br>

## 수 체계(number system)
### 1. 10진수(demical number)
- 0 ~ 9 까지의 10진 숫자들을 사용

<br>

### 2. 2진수(binary number)
- 2진 숫자(binary digit) = 비트(bit) = `0` 혹은 `1`

### 3. 8진수(octal number)
- 0 ~ 7 까지의 8진 숫자들을 사용

- 2진수 -> 8진수 간 변환
  - 2진수의 자리 값을 세 자리씩 끊어 읽는다.  

  <br>

### 4. 16진수
- 0 ~ F(15) 까지의 16진 숫자들을 사용

- 2진수 -> 16진수 간 변환
  - 2진수의 자리 값을 네 자리씩 끊어 읽는다.  

<br>

## 2진수 표현
- 비트(bit) - binary digit의 약자로서,  
디지털 시스템에서 수나 문자같은 정보를 표현하는 기본 단위.  
`0` 또는 `1`을 가지는 2진수 표현이다.  

- 비트 수(`n`)가 많아질수록, 표현 가능한 범위가 증가한다.  
`0 - (2`<sup>`n`</sup>`-1)`

...

<br>

## 음수 표현
### 1. 부호화-크기 표현
- signed-magnitude representatiion

- 가장 앞 비트를 부호 비트(MSB)로 사용하고,  
나머지 비트로 절댓값(수의 크기, magnitude)을 나타내는 아주 간단한 방법이다.

  - 최대 표현 범위 : `-(2`<sup>`n-1`</sup>`-1) ~ +(2`<sup>`n-1`</sup>`-1)`

- 하지만, 문제가 발생한다.
...

<br>

### 2. 1의 보수 표현
- 1's complement representation

- 음수 표현 시, 모든 비트들을 반전시킨다. (`~`)

  - 최대 표현 범위 : `-(2`<sup>`n-1`</sup>`-1) ~ +(2`<sup>`n-1`</sup>`-1)`

- 하지만, 1의 보수 표현 또한 같은 문제가 발생한다.
...

<br>

### 3. 2의 보수 표현
- 2's complement representation

- 음수 표현 시, 모든 비트들을 반전시키고 `+1` 한다.  

  - 최대 표현 범위 : `-2`<sup>`n-1`</sup>` ~ +(2`<sup>`n-1`</sup>`-1)`

- 2의 보수 표현은, `+1`을 하는 과정에서 만약 MSB로 부터 올림수가 발생하면 버린다.  
따라서, `00000000`의 1의 보수 표현인 `11111111`에서 `+1`을 하면  
`00000000`이다.  
  - 따라서, 0을 나타내는 표현이 단 하나이다.

  <br>

### 4. 각 표현 별 예시
(8 bit 기준)
- `+24`  
  - 부호화 크기 : `00011000`  
  - 1의 보수 : `00011000`  
  - 2의 보수 : `00011000`  

- `-24`  
  - 부호화 크기 : `10011000`  
  - 1의 보수 : `11100111`   
  - 2의 보수 : `11101000`

역으로 변환
- `11001011`
  - 부호화 크기 : `01001011` -> `-75`
  - 1의 보수 : `00110100` -> `-52`
  - 2의 보수 : `00110101` -> `-53`

