---
layout: post
title: "[논리회로] 3주차 - "
excerpt: ""

tags:
  - [논리회로]

toc: true

date: 2024-03-22
last_modified_at: 2024-03-22
---
## 2의 보수 산술 연산
### 1. 2의 보수 덧셈
- 2의 보수 덧셈(2'complement addition)
  - 두 수를 더하고, 올림수(캐리)가 발생하면 버린다.

- 더하려는 두 수를 같은 크기의 비트표현으로 표현해야 한다.  
  - e.g., 4bit + 4bit 연산, 8bit + 8bit 연산

- 8bit로 표현한 두 수의 덧셈 연산 예제이다.  

  -  **96 + 15** :   
  96  = 64 + 32 = `01100000`  
  15  = `00001111`  
  96 + 15 = `01101111` = **111**

  - **100 + 34** :  
  100 = 64 + 32 + 4 = `01100100`  
  34 = 32 + 2 = `00100010`  
  100 + 34 = `10000110` = **-122**  
  => **????**  
  *문제가 발생한다.*

<br>

### 2. 오버플로우(overflow)
- 2진수의 연산을 할 때에는 말했다시피  
더하려는 두 수의 비트 크기표현을 같게 맞추어야 한다.  
그러나 8bit + 8bit 연산을 하였을 때  
최대 표현가능한 결과의 범위는 `-128 ~ 127` 이다.

  - 따라서, 위와 같은 문제가 발생하는 것이다.  
  이처럼 덧셈 결과가 수의 표현 범위를 초과함으로써 틀린 결과를 산출하는 경우를  
  ***오버플로우(overflow)*** 라고 한다.  

  <br>

### 3. 2의 보수 뺄셈

- 8bit로 표현한 두 수의 뺄셈 연산 예제이다.  

- 2의 보수를 취하여 음수화 한 다음,  
결국 똑같이 덧셈을 이용하여 수행한다.  

  - **100 - 72** :  
  100 = 64 + 32 + 4 = `01100100`  
  72 = 64 + 8 = `01001000`  
  -72 = `10111000`  
  100 + (-72) = `00011100` = **28**  

  - **-36 - 24** :  
  36 = 32 + 4 = `00100100`  
  -36 = `11011100`  
  24 = 16 + 8 = `00011000`  
  -24 = `11101000`  
  (-36) + (-24) = `11000100`  
  `00111100` = 4 + 8 + 16 + 32 = 60  
  `11000100` = **-60**

<br>

## 다양한 2진 코드
### 1. 8421 코드
- 네 개의 각 비트들이 `2`<sup>`n-1`</sup>의 자릿수를 가지는 가중치 코드(weighted code)로서,  
**BCD(Binary Coded Decimal)** 이라고도 한다.  

  - 각 자리를 따로 취급하는 방식이다.  
  (e.g., 76 -> 7과 6)

  - 자릿수 = 8, 4, 2, 1

  - 예)  
    => `(792)`<sub>`10`</sub> -> `(0111 1001 0100)`<sub>`BCD`</sub>

<br>

### 2. 2421 코드
- **Aiken 코드** 라고도 불리는 가중치 코드(weighted code) 이다.

  - 자릿수 = 2, 4, 2, 1

<br>

### 3. 84-2-1
- 우측의 두 비트들이 음의 자릿수(negative weight)를 가지는 코드 방식이다.  

  - 자릿수 = 8, 4, -2, -1

<br>

### 4. 3증수(초과) 코드

<br>

### 5. 존슨 코드

<br>

### 6. 밀집형 10진수(packed BCD)
- **묶음 10진수** 혹은 **팩형 10진수** 라고도 불린다.  
한 데이터 단어에 여러 개의 10진 숫자를 넣는 방식이다.

  - 마지막 4비트 : 니블(nibble) - 부호를 표현

  <br>

### 7. 그레이 코드(Gray Code) - ★
- 자릿수를 가지지 않는 코드이다.  
***순서적으로 +1과 -1 숫자에 대한 비트표현과 단 한 개의 비트만 서로 다르다.**

  - 2진수 -> 그레이 코드 변환 방법은,  
    - 첫 비트는 그대로 가져가고,  
    이후 비트부터는 앞 비트와 **xor**연산 하였을 때 값을 가진다.  

  - 예를들어, 2진수 `10101100`은  
    그레이 코드 -> `11111010` 로 표현한다.

  - 그레이 코드 -> 2진수 변환 방법은,  
    - 첫 비트는 그대로 가져가고,  
    이후 비트부터는 결과로 나온 비트와 다음 input 비트를 **xor**연산 하였을 때 값을 가진다.  

  - 예를들어, 그레이 코드 `11111010`은  
  2진수 - `10101100` 으로 표현한다.

  <br>

- 그레이 코드를 왜 사용하냐면,  
  - 위에서 말했다시피 연속되는 숫자에 대한 비트 차이가 서로 단 한자리 이다.  
  따라서 아주 작은 차이를 가지는 연속적인 아날로그 값들이 들어올 때,  
  데이터 변환 시간이 단축되고, 오류 발생 가능성이 낮아  
  해당 경우에 유용하게 쓰인다.  

  <br>

### 8. ASCII 코드
- 7비트를 이용하여 문자, 숫자, 혹은 특수 문자를 표현하는  
국제 표준 코드이다.

![ASCII_codes]()
  - 보면, 상위 3비트에 따라 그룹별로 비슷한 성질의 문자끼리 모인다.  
  - 이 상위 3비트는

<br>

### 9. 오류 검출 코드
#### [1] 페리티 비트(parity bit)
- 통신 과정에서 발생하는 비트 오류를 검출하기 위해 추가되는 비트이다.  
  - **한 비트 오류 검출**만 가능하며, **정정(correction)은 불가능**하다.  

- 종류
  - 짝수 패리티(Even parity) : 전체 데이터에 포함되는 1의 수가 짝수가 되도록 패리티 비트를 추가
  - 홀수 패리티(Odd parity) : 전체 데이터에 포함되는 1의 수가 홀수가 되도록 패리티 비트를 추가  

  <br>

#### [2] 해밍 코드(Hamming code) - ★
- 오류 검출 뿐만 아니라, 오류 정정(correction)도 가능한 코드이다.
  - 다만, 물론 **한 비트 오류 검출**만 가능하다.  

- 다수의 패리티 비트를 추가하는 방식이다.
  - 패리티 비트 수 : `k`, 데이터 비트 수 : `d` 일 때,
  `2`<sup>`k`</sup>`-1 >= d + k`를 만족하는 `k`를 결정한다.  
  (e.g., `d = 4` -> `k = 3`)

- 4비트 데이터에 대한 해밍 코드 형식
![4bit_hamming]()

- 패리티 비트 계산 방법
  - `p`<sub>`1`</sub> : 비트번호(`3`, `5`, `7`)을 `xor`
    - `1`개씩 묶고 `1`씩 건너뛴다.
  - `p`<sub>`2`</sub> : 비트번호(`3`, `6`, `7`)을 `xor`
    - `2`개씩 묶고 `2`씩 건너뛴다.
  - `p`<sub>`4`</sub> : 비트번호(`5`, `6`, `7`)을 `xor`
    - `4`개씩 묶고 `4`씩 건너뛴다.

- 오류 검출 및 정정을 위한 신드롬 비트(syndrome bit) 계산
  - 방법 : 데이터 비트와 짝수 패리티 비트를 함께 사용

- 신드롬 비트 계산 방법
  - `s`<sub>`1`</sub> : 비트번호(`1`, `3`, `5`, `7`)을 `xor`
    - `1`개씩 묶고 `1`씩 건너뛴다.
  - `s`<sub>`2`</sub> : 비트번호(`2`, `3`, `6`, `7`)을 `xor`
    - `2`개씩 묶고 `2`씩 건너뛴다.
  - `s`<sub>`4`</sub> : 비트번호(`4`, `5`, `6`, `7`)을 `xor`
    - `4`개씩 묶고 `4`씩 건너뛴다.
    <br>
  - 신드롬 단어(`s`<sub>`4`</sub> `s`<sub>`2`</sub> `s`<sub>`1`</sub>)
    - 만약 신드롬 단어가 `0`이 아니라면, 해당 수의 해당하는 비트에 오류가 발생한 것이다.  
    (e.g., 신드롬 단어 : `111` -> `7`번 비트에 오류가 발생.)

    <br>

## 논리 게이트
### 1. 기본 논리 게이트
#### [1] `AND` 게이트
![and_gate]()
  - 두 개 혹은 그 이상의 입력 신호들에 대하여 `AND` 연산을 수행하고 결과 신호를 출력하는 게이트

  - 타이밍도
  ![timing_diagram_and]()

  - 3-입력 `AND` 게이트
  ![3-input-and_gate]()

  <br>

#### [2] `OR` 게이트
![or_gate]()
  - 두 개 혹은 그 이상에 입력 신호들에 대하여 `OR` 연산을 수행하고 결과 신호를 출력하는 게이트

  - 타이밍도
  ![timing_diagram_or]()

  - 3-입력 `OR` 게이트
  ![3-input-or_gate]()

  <br>

#### [3] `NOT` 게이트

<br>

#### [4] `NAND` 게이트


- `NAND` 게이트를 이용하여 다른 게이트를 구성 가능하다.  
  - 그래서 만능 게이트(universal gate) 라고도 부른다.
  ![universal_gate_nand]()

<br>

#### [5] `NOR` 게이트


- `NOR` 게이트를 이용하여 다른 게이트를 구성 가능하다.
  - 그래서 만능 게이트(universal gate) 라고도 부른다.
  ![universal_gate_nor]()

<br>

#### [6] `XOR` 게이트
- 두 입력이 서로 다른 값을 가지

<br>

### 2. 논리 게이트의 내부 회로
- 논리 게이트는 전자회로 소자들(Transistor, Diode, Resistor, 등)을 이용한 반도체 칩 제조에 사용된다.  

<br>

#### [1] 트랜지스터
- 종류
  - NPN 트랜지스터
  - PNP 트랜지스터

- RTN 스위칭 회로 : 저항(resistor) 및 NPN 트랜지스터로 구현
  - 인버터(`NOT` 게이트)기능 수행

- NAND 게이트 : 두 개의 NPN 트랜지스터를 직렬로 접속하여 구성

- NOR 게이트 : 두 개의 NPN 트랜지스터를 병렬로 접속하여 구성

#### [2] CMOS(Complementary MOS) 게이트 
- NMOS 및 PMOS 트랜지스터를 함께 이용하여 구현
  - 장점 : 저전력, 고밀도, 저비용

- NAND 게이트 : 두 개의 PMOS 트랜지스터를 병렬로 접속하고, 두 개의 NMOS 트랜지스터는 직렬로 접속

- NOR 게이트 : 두 개의 PMOS 트랜지스터를 직렬로 접속하고, 두 개의 NMOS 트랜지스터는 병렬로 접속

<br>

### 3. 논리 게이트 IC 칩을 이용한 회로 구현
