---
layout: post
title: "[컴퓨터 애니메이션] 5주차 (1) - Linear Solvers"
excerpt: "Problem Definition, Properties of Linear systems for DGP, Linear Solvers, Jacobi Iterative Solever, Factorization, LU Factorization, QR Factorization, Cholesky Factorization, Under-determined Systems, Over-determined Systems, Laplacian Smoothing"

tags:
  - [컴퓨터 애니메이션]

toc: true

date: 2025-09-30
last_modified_at: 2025-10-15
---
## Linear Solvers
`Ax = b` 형태의 선형 방정식 시스템을 푸는 방법

<br>

### 1. Problem Definition
- 모든 행렬이 invertible한 것은 아님
  - Not Square  
    - Over determined  
    ![over_determined][def]  
    - Under determined  
    ![under_determined][def2]  

  - 만일 invertible 하더라도,
    - Very expensive `O(n`<sup>`3`</sup>`)`
    - 주로 `n` = `# of vertices(points)` / `# of faces(triangles)`  

<br>

- Problem Definition
  - Input
    - Matrix `A`<sub>`m x n`</sub>
    - Vector `b`<sub>`m x 1`</sub>
  
  - Output
    - vector `x`<sub>`n x 1`</sub>
    - Such that `Ax = B`  

  - Goal : 추가적인 정보를 사용하여 적은 시간과 메모리 복잡도로 문제를 해결  

  <br>

### 2. Properties of Linear systems for DGP
- Sparse `A`  
![sparse_A][def3]
  - 방정식은 graph neighborhood에만 의존
  - 위 그림에서는 한 행당 평균적으로 7개의 non-zero entry 존재
  - non-zero entry의 수는 `O(n)`에 비례  

<br>

- `f(x, y)` = `ax`<sup>`2`</sup> + `by`<sup>`2`</sup> + `cxy` 인 경우,  
이는 `x`<sup>`T`</sup>`Ax` 형태로 쓸 수 있음  
  - 여기서 `A` = [[`a`, `c/2`], [`c/2`, `b`]]  

- Symmetric Positive Definite (SPD)
  - `x`<sup>`T`</sup>`Ax > 0` for all non-zero vectors `x` (positive eigenvalues)
    - `Ax = λx` 에서 `x`를 eigenvector, `λ`를 eigenvalue라고 함  
    - `>=` 인 경우 Positive Semi-Definite (PSD)
  - 많은 경우 `A`는 Laplacian matrix
  - Laplacian system은 주로 SPD

- `Ax = b`에서 주로 `A`는 remains, `b`가 changes (**multiple right-hand sides**)
  - Interactive applications
  - Mesh geometry - X, Y, Z에 대하여 동일한 matrix `A` 사용 가능  

<br>

### 3. Linear Solvers
- Indirect solvers - iterative : `x`를 `0`부터 시작하여 반복문을 통해 점진적으로 개선
  - **Jacobi**
  - Gauss-Seidel
  - Conjugate Gradient (CG)

- Direct solvers - factorization : `A`를 분해하여 간단한 문제로 변환  
  - **LU**
  - **QR**
  - **Cholesky**

- Multigrid solvers

<br>

### 4. Jacobi Iterative Solever
- 아래와 같이 equation이 주어졌을 때,  
`a`<sub>`i1`</sub>`x`<sub>`1`</sub> + `a`<sub>`i2`</sub>`x`<sub>`2`</sub> + ... + `a`<sub>`in`</sub>`x`<sub>`n`</sub> = `b`<sub>`i`</sub>

- Idea
  - 초기 값 설정
  - 수렴할 때 까지 반복

<br>

- `x`<sup>`*`</sup>가 `Ax = b`의 해라고 할 때,  
![jacobi_1][def4]  
  - 기존 `Ax`<sup>`*`</sup> = `b`를 각 `x`<sub>`i`</sub>에 대해 풀어쓴 것  

- Jacobi method
  - `x`<sub>`i`</sub><sup>`(0)`</sup> = `0` 로 설정
    - `0`이 아닌 임의의 초기값 설정 가능 (자유, but 수렴 속도에 영향)  
  - 수렴할 때 까지, `i` = `1` ~ `n`에 대해 아래를 반복  
  ![jacobi_2][def5]  

<br>

- 장점
  - 구현이 간단함  
  - 적은 메모리 소비 (`O(n)`)
  - sparse structure의 장점 활용 가능
  - 병렬화 가능  

- 단점
  - 완전히 diagonal dominant하지 않으면 수렴하지 않을 수 있음
  - 느린 수렴 속도 (오차가 smooth하면, 느리게 수렴)
  - 아래의 장점을 활용하지 못함
    - Same `A`, different `b`
    - SPD `A`  

    <br>

### 5. Factorization
- Direct solvers - factorization : `A`를 분해하여 간단한 문제로 변환  
![factorization][def6]  
-> `A`가 diagonal/triangular인 경우 해결이 쉬움
-> pre-computation 하기 때문에, **multiple right-hand sides**에 유리

<br>

- Diagonal  
![diagonal][def7]  

- Lower Triangular  
![lower_triangular][def8]  

- Upper Triangular  
![upper_triangular][def9]  

<br>

### 6. LU Factorization
- `A = LU`로 분해
  - `L` : lower triangular matrix
  - `U` : upper triangular matrix

- 어느 non-singular square matrix든 `LU`로 분해 가능  
![lu_factorization][def10]  

<br>

- `LUx = b`를 푸는 과정  
  - (1) `Ly = b` 를 푼다 (forward substitution)
  - (2) `Ux = y` 를 푼다 (backward substitution)

<br>

### 7. QR Factorization
- `A = QR`로 분해
  - `Q` : orthogonal matrix (`Q`<sup>`I`</sup> = `Q`<sup>`T`</sup>`)
  - `R` : upper triangular matrix

- 어느 matrix든 `QR`로 분해 가능  
![qr_factorization][def11]  

- `Rx = Q`<sup>`T`</sup>`b` 로 해결 가능하다.  

<br>

### 8. Cholesky Factorization
- `A = LL`<sup>`T`</sup> 로 분해
  - `L` : lower triangular matrix

- `A`가 SPD인 경우에만 가능  
  - `A`가 Symmetric
  - `A`가 Positive Definite (`v`<sup>`T`</sup>`Av > 0` for all vectors `v`)  
![cholesky_factorization][def12]  

- Numerical Error에 대해서 Stable하다.  

- `LL`<sup>`T`</sup>`x = b` 를 푸는 과정  
  - (1) `Ly = b` 를 푼다 (forward substitution)
  - (2) `L`<sup>`T`</sup>`x = y` 를 푼다 (backward substitution)

<br>

### 9. Singular Value Decomposition (SVD)  
- `M` x `N` 크기의 행렬 `A`를 분해 (`M` >= `N`)  
`A = UΣV`<sup>`T`</sup> 또는 `A = UDV`<sup>`T`</sup>  
![svd][def18]  
  - `U` : orthogonal matrix
  - `Σ` / `D` : Diagonal matrix (filled with singular values)
  - `V` : orthogonal matrix  

- `U`, `D`, `V` 모두 역행렬을 구하기 쉬우므로, 만약 `A`가 non-singular라면  
`A`<sup>`-1`</sup> = `VD`<sup>`-1`</sup>`U`<sup>`T`</sup> 로 구할 수 있음
  - `D`<sup>`-1`</sup>는 `D`의 대각 원소들의 역수로 구성된 대각 행렬  

- `A`가 singular하다면 몇몇 singular value가 `0`이다.  

<br>

### 10. Under-determined Systems
- System이 under-determined 된 경우 -> too many variables  
![underdetermined_systems][def13]  

- Solution : 고정된 변수에 대해 제약조건을 추가
  - (1) Add equations `x`<sub>`1`</sub> = `c`<sub>`1`</sub>, `x`<sub>`2`</sub> = `c`<sub>`2`</sub>, ... , `x`<sub>`k`</sub> = `c`<sub>`k`</sub>  
  or  
  - (2) Equation 내 변수를 상수로 치환  
    - 이 방법이 less expensive
    - adding equation은 make system not square

<br>

### 11. Over-determined Systems
- System이 over-determined 된 경우 -> too many equations  
![overdetermined_systems][def14]  

- Solution : 만약 equations가 dependent하지 않다면, no solution.
- 대신, minimize `||Ax - b||`<sup>`2`</sup> (least squares solution)

- 이는 아래의 solution  
`A`<sup>`T`</sup>`Ax = A`<sup>`T`</sup>`b`  
`x` = (`A`<sup>`T`</sup>`A`)<sup>`-1`</sup>`A`<sup>`T`</sup>`b`
  - Pseudo-inverse (`A`<sup>`+`</sup> = (`A`<sup>`T`</sup>`A`)<sup>`-1`</sup>`A`<sup>`T`</sup>)  

- `A`<sup>`T`</sup>`A`는 SPD이므로, Cholesky factorization 사용 가능  

- 평면 상에서 점들에 가장 잘 맞는 직선(`y` = `ax`+`b`을 찾는 문제 (linear regression)도 over-determined system의 예시  

<br>

### 12. Laplacian Smoothing
![Laplacian_smoothing][def15]  
  - `p`<sub>`0`</sub> 에서는 forward velocity만 존재 (backward velocity가 없음)
  - `p`<sub>`n`</sub> 에서는 backward velocity만 존재 (forward velocity가 없음)
  - 나머지는 `p`<sub>`1`</sub>, `p`<sub>`2`</sub>, ..., `p`<sub>`n-1`</sub> 에서 forward, backward velocity가 모두 존재하므로, acceleration 계산 가능  

- 따라서 다음과 같은 행렬식이 됨  

```
[ -1  1   0   0   0   0   . . . 0  0 ]
[ 1  -2  1   0   0   0   . . . 0  0 ]
[ 0   1  -2   1   0   0   . . . 0 ]
[ .  .   .   .   .   .    . . . . ]
[ 0   0   0   0   0  . . . 1  -2   1 ]
[ 0   0   0   0   0   0 . . . -1  1 ]
```

- 이 행렬과 vertex vector의 곱이 `0` vector에 가까워지도록 함으로써, smoothing 효과를 얻음  

- 또는 아래와 같은 행렬식을 사용하기도 한다.  

```
[ 1   0   0   0   0   0 . . . 0   0 ]
[-1   2   1   0   0   0 . . . 0   0 ]
[ 0   -1   2   1   0   0 . . . 0   0 ]
[ .  .  .  .  .  .   . . . . ]
[ 0   0   0   0 . . .  -1   2   -1 ]
[ 0   0   0   0  . . .  0   0   0   1 ]  
```

- `0` vector와 같도록 하면 항상 `x`가 `0`이므로,  
결과의 `p`<sub>`0`</sub>, `p`<sub>`n`</sub>는 고정시키고,

- Jacobi iterative solver를 사용하여 smoothing 수행 가능  
![Laplacian_smoothing_jacobi_iteration][def16]  

<br>

- 2D에서는 `L(p`<sub>`i`</sub>`)` = (`p`<sub>`i-1`</sub> + `p`<sub>`i+1`</sub>) / `2` 를 `0`에 가깝게 함으로써 smoothing  
  - Laplacian Equation
- 3D에서는 `p`<sub>`i`</sub>의 neighbor vertex의 평균 위치로 이동시키는 것과 동일  
neighbor vertex의 개수가 `N`이라면,  
`L(p`<sub>`i`</sub>`)` = (`p`<sub>`j1`</sub> + `p`<sub>`j2`</sub> + ... + `p`<sub>`jN`</sub>) / `N`  
  - Smoothing a 3D surface  
  ![jacobi_smoothing_3D_surface][def17]  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김종민 교수님의 컴퓨터 애니메이션 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details> 

[def]: https://i.imgur.com/vO86Wxz.png
[def2]: https://i.imgur.com/V8LFIAz.png
[def3]: https://i.imgur.com/LvqhKmH.png
[def4]: https://i.imgur.com/9w5uRwe.png
[def5]: https://i.imgur.com/ejKUno9.png
[def6]: https://i.imgur.com/73f9UHE.png
[def7]: https://i.imgur.com/luDvKGO.png
[def8]: https://i.imgur.com/YRUQ4iQ.png
[def9]: https://i.imgur.com/7v9xD4g.png
[def10]: https://i.imgur.com/xJhZNyG.png
[def11]: https://i.imgur.com/A18DyR6.png
[def12]: https://i.imgur.com/zPOry0a.png
[def13]: https://i.imgur.com/zPoPFVm.png
[def14]: https://i.imgur.com/gJbTbQC.png
[def15]: https://i.imgur.com/RYt102M.png
[def16]: https://i.imgur.com/vHFgR7j.png
[def17]: https://i.imgur.com/oeOVTun.png
[def18]: https://i.imgur.com/2Sxp0KO.png