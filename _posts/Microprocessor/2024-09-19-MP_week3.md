---
layout: post
title: "[마이크로프로세서] 2주차 - 어셈블리 언어 (2)"
excerpt: "TODO"

tags:
  - [마이크로프로세서]

toc: true

date: 2024-09-19
last_modified_at: 2024-09-19
---
## 어셈블리 문법
### 1. 분기 명령어
- 프로그램의 분기
  - 직전 실행 결과에 따라 다음 작업을 선택
  - C나 Java 따위에서의 **조건문**에 해당

- 분기 조건 : CCR의  조건 비트들을 활용
  - 직전의 연산 결과가 음수인 지 -> CCR의 N 비트가 `1`인 지
  - 직전이 연산 결과가 0인 지 -> CCR의 Z 비트가 `1`인 지

  <br>
  
- CCR의 비트 설정
  - `N` : 직전 연산 결과의 최상위 비트(MSB)에 해당
  - `Z` : 직전 연산 결과의 모든 비트가 `0`이면 `1`, 그렇지 않으면 `0` (NOR)  

  <br>

- 분기 명령어 : `BR 조건, addr`  
  - e.g., `BR nz, 4000`  
  -> 직전 실행 결과가 음수 or `0`이면, 4000번지로 실행위치 이동  

  <br>

- 절댓값을 구하는 프로그램

```s
        LOAD R1, x
        CMP R1, 0
        BR zp, next
        COPY R2, 0
        SUB R1, R2, R1
        STORE R1, x
next:
        ...
x:    .FILL -23
```

<br>

- 분기 조건 표시

|조건|조건 표시|CCR의 N,Z 비트 조건(회로 설계에 반영)|
|:---:|:---:|---|
|작다|`n`|음수이면 (`N=1`이면)|
|같다|`z`|0이면 (`Z=1`이면)|
|크다|`p`|양수이면(`N=0`&&`Z=0`이면)|
|작거나 같다|`nz`|TODO from here|
|같지 않다|`np`||
|크거나 같다|`zp`||
|무조건(true)|`nzp`||

<br>

### 2. 비교 명령어
- 비교 명령어 : `CMP Rs Rs2`
  - `Rs - Rs2`의 계산 과정에서 CCR 비트들을 갱신
  - 계산 결과는 저장하지 않음
  - e.g., `CMP R1, 99`  
  -> `R1 - 99`의 과정에서 CCR 비트들만  적절히 갱신  

  <br>

- 두 수 중에서 작은 수를 저장하는 프로그램  
`y <- min(x, 15)`  

```s
        LOAD R1, x
        CMP R1, 15
        BR n, else
        COPY R2, 15
        STORE R2, y
        BR nzp, addr
else:
        COPY R2, R1
        STORE R2, y
addr:
        ...
```

<br>

### 3. 시프트 연산 명령어
- 시프트 연산 명령어
  - `LSL Rd, Rs, n` : Logical Shift Left
  - `ASL Rd, Rs, n` : Arithmetic Shift Left
  - `LSR Rd, Rs, n` : Logical Shift Right
  - `ASR Rd, Rs, n` : Arithmetic Shift Right  

  <br>

- C언어와 시프트 연산

|C 언어 표현|어셈블리 언어 표현|
|---|---|
|`int x;`<br>`unsigned y;`|`x: .BLOCK 1`<br>`y: .BLOCK 1`|
|`x = (x >> 1);`|TODO from here|
|`y = (y >> 2);`||
|`x = (x << 3);`||
|`y = (y << 4);`||

<br>

- 시프트 연산을 활용한 곱하기 `10` 의 처리
  - `value x 10` = `value x (8 + 2)` = `(value x 8) + (value x 2)`  

  ```s
        .ORIGIN 0x2000
        LOAD R1, value
        LSL R2, R1, 3
        LSL R3, R1, 1
        ADD R1, R2, R3
        STORE R1, result
  value: .FILL 123456
  result: .BLOCK 1
  ```

  <br>

- 정수를 8로 나눈 몫과 나머지 구하기

```s
        .ORIGIN 0x2000
        LOAD R1, value
        ASR R2, R1, 3
        STORE R2, quotient
        AND R2, R1, 0x07
        STORE R2, remain
value: .FILL 0x12345
quotient: .BLOCK 1
remain: .BLOCK 1
```

<br>

### 4. 유효주소 저장 명령어
- 유효주소 저장 명령어 : LEA (Load Effective Address)
  - 특정 주소를 저장해두고 이후에 계속해서 사용할 때 쓰인다. (포인터)
  - 문법 : `LEA R1, addr`  
  ![lea_visualize](TODO)  

  <br>

- `LEA`와 `LOAD`의 비교

```s
        .ORIGIN 0x2000
        LOAD R1, value
        LEA R2, value
value: .FILL 0x1234
```

- `LOAD R1, value` : value의 값을 R1에 저장
- `LEA R2, value` : value에 해당하는 주소를 R2에 저장

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 김용석 교수님의 마이크로프로세서 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>