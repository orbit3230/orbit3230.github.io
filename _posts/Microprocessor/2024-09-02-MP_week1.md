---
layout: post
title: "[마이크로프로세서] 1주차 - 마이크로프로세서의 프로그램 실행 원리"
excerpt: "프로세서, 프로세서와 메모리, 레지스터, 어셈블리 언어 프로그램, 프로세서의 명령어 실행"

tags:
  - [마이크로프로세서]

toc: true

date: 2024-09-02
last_modified_at: 2024-09-02
---
## 프로세서
### 1. 프로세서와 메모리
- 간단한 덧셈 프로그램을 프로세서가 처리하는 과정을 생각해보자.  
`Z = X + Y`

- 덧셈을 위하여 두 변수 `X`와 `Y`의 내용을 읽고 더한 후의 값을 변수 `Z`에 덮어써야 할 것이다.  

  - 그러나 프로세서는 단순 전자 회로인데, 읽어들인 내용을 어떻게 기억할까?  

  <br>

### 2. 레지스터
- 그래서 프로세서 내부에는 레지스터(Register)가 존재한다.  

- 레지스터(Register) : 작업 중간 결과를 임시로 저장하기 위한 장치

  - 레지스터는 메모리의 특정 주소로 구분되는 공간에 접근하여 데이터를 읽어와 저장한다.  
    - (1) `R1 <- M[X]`
    - (2) `R2 <- M[Y]`
    - (3) `R3 <- R1 + R2`
    - (4) `M[Z] <- R3`  
    (`M` : 메모리, `R` : 레지스터, `X`,`Y`,`Z` : 주소)

<br>

### 3. 어셈블리 언어 프로그램  
- 어셈블리 언어는 위와 같은 과정을 명령어를 통하여 직접 수행한다.  

```s
LOAD R1, X
LOAD R2, Y
ADD R3, R1, R2
STORE R3, Z
```

- 명령어(Instruction)
  - `LOAD` : 메모리 내 특정 주소의 내용을 레지스터로 로드
  - `ADD` : 프로세서 내부에서 덧셈 작업 수행
  - `STORE` : 레지스터 내용을 메모리 특정 주소에 저장  

  <br>

- 컴파일러(compiler) : 고급수준 프로그래밍 언어로 작성한 프로그램을 어셈블리 언어로 번역하는 소프트웨어
- 어셈블러(assembler) : 어셈블리 언어 프로그램을 기계어로 번역하는 소프트웨어  

![compile_assemble][def]  

<br>

### 4. 프로세서의 명령어 실행
- 메모리에서는 변수 뿐만 아니라 프로그램(명령어)도 저장한다.  
  - PC (Program Counter)
  - CCR (Condition Code Register)  

  ![program_counter][def2]  

  <br>

- 명령어의 실행 과정은 다음과 같은 세 단계의 반복이다.  
![TODO]()
![TODO]()
  
<br>

## 비트와 정수 연산
### 1. 정수의 표현 범위  
- unsigned 정수의 표현 범위

|비트 수|10진수 표현|2진수 표현|16진수 표현|
|:---:|:---:|:---:|:---:|
|4||||
|8||||
|16||||

<br>

- signed 8비트 정수의 표현 범위

|수의 범위|2진수 표현|16진수 표현|
|:---:|:---:|:---:|
|1 ~ 127|||
|0|||
|-128 ~ -1|||


- 음수에 대해서는 2의 보수 표현을 사용한다.  

<br>

- unsigned 정수와 8비트 정수의 2진수 표현을 비교하자면 아래와 같다.  
![TODO]()  

<br>

### 2. 비트 수 확장
- 연산 시에는 비트 자리 수를 통일하여야 한다.  

- unsigned 정수의 비트 확장 (제로 확장)

  - unsigned 정수는 MSB에 관계 없이, `0`으로 채워 확장한다.  
  ![TODO]()  

-  signed 정수의 비트 확장 (부호 확장)  
  
  - unsigned 정수는 MSB로 부호를 결정하기 때문에, MSB를 복사하여 채워 확장한다.  
  ![TODO]()  

  <br>

### 3. 오버플로우
#### [1] 덧셈과 캐리의 발생 (unsigned 정수 연산)
- 덧셈의 결과로서 표현 가능한 범위를 넘어서는 경우,  
최상위 비트에서 발생하는 Carry 비트가 발생한다.  
![TODO]()  

<br>

#### [2] 뺄셈과 캐리의 발생 (unsigned 정수 연산)
- 뺄셈 연산의 경우 2의 보수를 더하는 것으로 감산회로를 설계한다.  
- 뺄셈의 결과로서 표현 가능한 범위를 넘어서는 경우,  
최하위 비트에서 Borrow 비트가 발생한다.  
![TODO]()  

<br>

#### [3] 오버플로우의 발생
- signed 정수 연산 시 정수의 표현 가능한 범위를 넘어서는 경우, 부호가 반대로 되며  
***Overflow***가 발생한다.  
  - Overflow 비트도 별도로 저장한다.  

![TODO]()

- 오버플로우를 판단하는 회로로서  
두 피연산자의 MSB 비트(부호)가 같으면서,  
반면 결과로 나온 숫자의 MSB 비트(부호)는 이와 다른 경우 오버플로우로 판단할 수 있다.  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 김용석 교수님의 마이크로프로세서 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/lU7Lmo0.png
[def2]: https://i.imgur.com/5QMxTkv.png