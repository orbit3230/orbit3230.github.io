---
layout: post
title: "[C++ 프로그래밍] 14주차 - C++ STL"
excerpt: "STL(Standard Template Library), Container in STL, Vector, Iterator, List, Map, Stack"

tags:
  - [CPP 프로그래밍, CPP]

toc: true

date: 2024-06-04
last_modified_at: 2024-06-04
---
## STL(Standard Template Library)
- 자주 사용되는 자료구조나 함수에 대해 제공해주는 유용한 C++ Template classes 집합(라이브러리)이다.  

TODO

### 1. Container in STL
- Container란, objects나 data를 담는 것을 말한다.  

- Template이기 때문에, 어떠한 type이든 담을 수 있다 !!

- Container의 종류
  - Sequence Containers
    - array
    - vector
    - deque
    - forward_list
    - list

  - Associative Containers
    - set
    - map
    - multiset
    - multimap

  - Unordered Associative Containers
    - unordered_set
    - unordered_map
    - unordered_multiset
    - unordered_multimap

  - Container adaptors
    - stack
    - queue
    - priority_queue

    <br>

### 2. Vector
- `#include <vector>`

- `std::vector`
  - Dynamic arrays와 같다.  
    - Element가 삽입/삭제 될 때 자동적으로 resize 한다.  
  - Elements가 contiguous storage에 저장된다.  
    - 그래서 `push`의 사용이 Dangerous!
  - Elements가 iterators로 다루어질 수 있다.  

  <br>

- 정수를 담는 vector를 사용해보자 !

```c++
vector<int> v = {1, 2, 3, 4, 5};

v.push_back(6);
v.push_back(7);
v.push_back(8);
printVector(v);

v.pop_back();
printVector();
```

```c++
void printVector(vector<int>& v) {
    cout << "Elements in vector : ";
    for(int i = ; i < v.size() ; i++) {
        cout << v[i] << '\t';
    }
    cout << endl;
}
```

<br>

### 3. Iterator
- 위 코드에서는, vector의 각 값에 접근하기 위하여 `[]`가 사용되었다.  

- Iterator를 사용하면 smart하게 값에 접근 가능하다.  

```c++
void printVector(vector<int>& v) {
    cout << "Elements in vector : ";

    vector<int>::iterator it;
    for(it = v.begin() ; it < v.end() ; it++) {
        cout << *it << '\t';
    }
    cout << endl;
}
```

- `begin()` : container의 시작점을 반환한다 (pointer)

- `end()` : container의 끝점을 반환한다. (pointer)  

- Iterator는 메모리 주소를 저장한다 !!  
(like pointers)
  - 따라서 실제 값을 획득하려면 de-referencing `*`

- `advance(iter, num)` : `num` 만큼 iterator의 위치를 이동시킨다.  

- `next(iter, num)` : `advance()` 처럼 `num` 만큼 위치를 이동시키지만,  
이동시킨 후의 새로운 iterator를 반환하므로  
기존의 iterator 위치는 영향을 받지 않는다.  

- `prev(iter, num)` : `num` 만큼 위치를 뒤로 이동시키지만,  
이동시킨 후의 새로운 iterator를 반환하므로  
기존의 iterator 위치는 영향을 받지 않는다.  

- `insert(iter, element)` : iterator가 가리키는 위치에 `element`를 삽입한다.  

- `erase(iter)` : iterator가 가리키는 위치의 `element`를 삭제한다.  

<br>

- iterator 또한 template 타입으로 사용할 수 있을까 ?  

```c++
template <typename T>
void printVector(vector<T>& v) {
    cout << "Elements in vector : ";

    typename vector<T>::iterator it;
    for(it = v.begin() ; it < v.end() ; it++) {
        cout << *it << " ";
    }
    cout << endl;
}
```

- 유의할 점은,  
`vector<T>::iterator it;` 와 같이 선언하면 컴파일되지 않는다는 것이다.  
  - 컴파일러는 `T`에 대한 iterator 타입 추론이 불가능하다.  
- 따라서, `typename vector<T>::iterator it;`와 같이,  
iterator 또한 새로운 타입으로 인정해주어야 한다.  

<br>

- `for - each`를 사용하면 더 편리한 방법으로 사용할 수 있다 !

```c++
template <typename T>
void printVector(vector<T>& v) {
    cout << "Elements in vector : ";

    for(T element : v) {
        cout << element << " ";
    }
    cout << endl;
}
```

<br>

### 4. List
- `#include <list>`

- `std::list`
  - non-contiguous memory allocation Sequence container.  
  (`vector`는 contiguous memory space를 사용하는 Sequence container 였다.)  
    - Non-contiguous memory allocation -> slow traversal, quick insertion/deletion  

  - Doubly linkedList  
    - cf) "forward list"는 singly linked list를 구현하는데 사용된다. 

  <br>

- 정수를 담는 list를 사용해보자 !  

```c++
list<int> l1{0, 1};
list<int> l2{900, 800};

for(int i = 2 ; i < 10 ; i++) {
    l1.push_back(i*10);
    l2.push_front(i*100);
}

printList(l1);
printList(l2);

l1.pop_front();
printList(l1);
l2.pop_back();
printList(l2);

l1.reverse();
printList(l1);
l2.sort();
printList(l2);
```

```c++
void printList(list<int>& v) {
    list<int>::iterator it;
    for(it = v.begin() ; it != v.end() ; ++it) {
        cout << *it << " ";
    }
    cout << endl;
}
```

<br>

- 더 많은 메소드들을 알아보자.  

```c++

```

<br>

### 5. Map
- `#include <map>`

- `std::map`
  - Associative container의 한 종류이다.  
  - Keys들은 자동적으로 정렬되며 Unique 하다.  

<br>

- <정수, 정수>를 담는 Map을 사용해보자 !

```c++
map<int, int> mp;
mp.empty();  // 1(true)

mp.insert({3, 20});
mp.insert({2, 10});
mp.insert({1, 40});
mp.insert({1, 30}); // Key conflicted - IGNORE
printMap(mp);
mp.empty();  // 0(false)
mp.size();   // 4
mp.count(1); // 40

mp.erase(3); // 3:20 -> ERASED

mp.clear();
mp.empty();  // 1(true)
```

<br>

### 6. Stack
- `#include <stack>`

- `std::stack`
  - Container adapter의 한 종류이다.  

  <br>

- 정수를 담는 Stack을 사용해보자 !

```c++
// TODO
```