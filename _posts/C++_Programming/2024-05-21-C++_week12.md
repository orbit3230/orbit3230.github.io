---
layout: post
title: "[C++ 프로그래밍] 12주차 - Template"
excerpt: ""

tags:
  - [CPP 프로그래밍, CPP]

toc: true

date: 2024-05-21
last_modified_at: 2024-05-21
---
## Template
- Integer value를 다루는 Queue 자료구조 class를 만들어보자.  

  - `Enqueue()`, `Dequeue()`와 같은 메소드가 필요할 것이다.  
  - `front()`, `back()`, `size()`와 같은 메소드도 필요할 것이다.  
  - Constructor와 Destructor 또한 필요할 것이다.  
  ...

- 이러한 메소드들을 구현하며,  
열심히 Integer value를 컨트롤하는 Queue class를 만들었다.  

  - ?! 그런데 `string` value를 다루는 새로운 Queue가 필요해졌다 . . .

  - 어떻게 하면 좋을까?  
  코드를 새로 짜야 할 것이다 . . .   

<br>

- 이럴 때 필요한 것이, 바로 ***Template*** 이다.  

  - In Java, Generic과 같은 개념이다.  

  - 만약 parameter로 data type을 받을 수 있다면,  
  또 다른 different data type에 대한 코드를 또 작성할 필요가 없어질 것이다.  

  <br>

### 1. Template Function
- Template은 이러한 형식으로 선언한다.  

```c++
template <typename T>
```  

<br>

- 이제 template function을 선언해보자.  

```c++
template <typename T>
T getMax(T x, T y) {
  return (x > y) ? x : y;
}
```

- Template는 컴파일 단계에서 expended 된다. (like macro)  

  - `int` 타입에 대한 template function TODO
  - `char` TODO

- omit type specification TODO

<br>

### 2. Template Class
- 2개의 Type을 parameter로 받는 class를 만들어보자.  

```c++
template<typename T, typename U>
class OOP {
    private:
    T x;
    U y;
    public :
        OOP(T v1, U v2) : x(v1, y(v2)) {}
        T add() {
            return x + y;
        }
}
```

- 이 class에 대한 instance를 만들 때는,  
TODO

<br>

### 3. Template Specialization
- 하지만, 특정 data type에 대해서는 독단적으로 다른 코드를 원하게 될 수도 있다.  

- 그리하여 template specialization이 존재한다.  

  - function template specialization

    ```c++
    template <typename T>
    T getMax(T x, T y) {
        return (x > y) ? x : y;
    }

    template <>  // Template Specialization
    string getMax(string x, string y) {
        return x;
    }
    ```

  - class template specialization

    ```c++
    template <typename T>
    class OOP {
        public :
        OOP() {
            cout << "general template object \n";
        }
    };
    
    template <>  // Template Specialization
    class OOP <int>{
        public :
        OOP() {
            cout << "Specialized template object \n";
        }
    };
    ```

    - 두 개의 parameter 중 하나에 대해서만 template specialization 시킬 수도 있다.  

    ```c++
    template <typename T, typename U>
    class OOP {
        public :
        OOP(T v1, U v2) : x(v1), y(v2) {}
        T add() {
            return x + y;
        }
    };
    
    template <typename T>  // Template Specialization
    class OOP <T, char>{
        public :
        OOP(T v1, char v2) : x(v1), y(v2) {}
        string add() {
            return "" + to_string(x) + y;
        }
    };
    ```

<br>

- Template Specialization은 어떻게 작동하는가 ?

  - 앞에서 template는 컴파일 단계에서 expended 된다고 했다. (like macro)  

  - 만약 specialized version이 존재한다면,  

    - (1) 컴파일러는 specialized version을 가장 우선시하여 체크한다.  
      - 여기서 만약 발견된다면,  
      이를 먼저 사용한다.  

    - (2) 그리고 나서야, main template을 체크한다.  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 김도형 교수님의 C++프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details>