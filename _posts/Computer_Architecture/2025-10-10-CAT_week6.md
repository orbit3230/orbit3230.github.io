---
layout: post
title: "[컴퓨터구조] 6주차 - ISA: Tradeoff"
excerpt: "Complex vs. Simple Instructions, ISA-level Tradeoffs: Semantic Gap, Small Semantic Gap, Small vs. Large Semantic Gap, Translation, ISA-level Tradeoffs: Instruction Length, ISA-level Tradeoffs: Uniform Decode, ISA-level Tradeoffs: Number of Registers, ISA-level Tradeoffs: Addressing Modes, Summary, Other Examples of ISA-level Tradeoffs"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-10-08
last_modified_at: 2025-10-15
---
## ISA: Tradeoff
- Computer Architecture는 다양한 design point가 존재하고, 적절한 tradeoff를 찾아야 함  

### 1. Complex vs. Simple Instructions
- Complex instruction : 많은 일을 하는 instruction
  - 여러 operations
  - e.g.,
    - Double linked list에 insert
    - `cos(x)` 계산, Fast Fourier Transform\
    - 문자열 복사

- Simple instruction : 적은 일을 하는 instruction
  - e.g.,
    - Add
    - Xor
    - Shift

<br>

### 2. ISA-level Tradeoffs: Semantic Gap
- ISA를 어디에 위치시킬 것인가? - Semantic Gap
  - High-level language(HLL)에 가깝게 vs. hardware control signals에 가깝게
  - RISC vs. CISC vs. HLL machines

- Very large semantic gap
  - 하드웨어에 가깝다. signal을 직접 컨트롤한다.
  - Complex compiler, simple hardware

- Very small semantic gap
  - ISA가 high-level language에 가깝다.
  - Simple compiler, complex hardware
  - ISA가 복잡해지면, Backward compatibility 유지가 어려워진다. (e.g., x86)

<br>

### 3. Small Semantic Gap
- x86: Small Semantic Gap: String Operations
  - 문자열에 대해 연산하는 하나의 명령어
    - 임의의 길이의 문자열을 다른 메모리 위치로 복사 
    - 두 문자열을 비교

- `REP`라고 불리는 접두어(prefix)를 사용하여, 문자열 연산 명령어를 반복적으로 수행
  - e.g., `REP MOVS` instruction  
  ![rep_movs][def]  

<br>

- Small Semantic Gap Examples in VAX
  - FIND FIRST
    - 비트 필드에서 첫 set bit를 찾음
    - OS의 자원 할당 연산을 지원
  - SAVE CONTEXT, LOAD CONTEXT
    - 특수한 context switching 명령어
  - INSQUEUE, REMQUEUE
    - doubly linked list에 대한 연산
  - INDEX
    - bounds checking과 함께 배열 액세스
  - STRING Operations
    - Compare strings, find substrings, ...
  - Cyclic Redundance Check Instructions  

  <br>

- 이렇게 Small Semantic Gap의 복잡한 명령어로 인해 F00F 버그가 발생했다. (Intel Pentium)
  - conditional swap 명령어를 단 `2`byte의 `0F C7`로 제공
  - 그런데 `eax` 레지스터와 함께 사용 시 exception 발생
  - 여기에 더불어 `lock` prefix(`F0`)를 붙이면, 컴퓨터 전체가 멈추는 치명적인 버그 발생  

<br>

### 4. Small vs. Large Semantic Gap
- CISC vs. RISC
  - Complex Instruction Set Computer -> 복잡한 명령어
  - Reduced Instruction Set Computer -> 단순한 명령어
    - 목표 : 더 나은 컴파일러 컨트롤과 최적화

- RISC의 제작 동기
  - Complex instruction 작업이 오래 걸리면 memory stall이 발생, pipeline이 멈추는 문제
    - 컴퓨터의 성능에 upper bound가 생긴다.
  - 하드웨어의 단순화 -> 더 낮은 비용, 더 높은 frequency
  - 컴파일러로 하여금 코드를 더 잘 최적화하게 하려고
    - stall을 줄이기 위한 fine-grain parallelism

<br>

- Small Semantic Gap (Complex instructions)의 장점
  - Denser encoding -> 더 작은 코드 크기 -> off-chip bandwidth 절약, 더 나은 cache-hit rate
  - 간단한 컴파일러

- Small Semantic Gap (Complex instructions)의 단점
  - 더 많은 일을 한번에 처리하려고 함 -> 컴파일러는 최적화의 기회를 잃음
  - 더 복잡한 하드웨어 -> signal 컨트롤과 최적화를 위해 하드웨어 차원에서 translation을 필요로 함

<br>

### 5. Translation
- ISA는 쉽게 변경되기 어렵다.  
그럼에도 시간이 지나며 여러 고려사항들을 반영하고/만족시키기 위해 진화해왔다.

- Examples
  - 제한된 on-chip & off-chip memory size
  - 제한된 컴파일러 최적화 기술
  - 제한된 memory bandwidth
  - 중요한 애플리케이션에 대한 specialization의 필요성 (e.g., MMX)

- Translation의 사용은 ISA에 관계 없이 underlying implementation들이 유사해질 수 있도록 만들었다.

- Effect of Translation
  - 한 ISA에서 다른 ISA로 translate하여, Semantic Gap tradeoff를 극복
    - ISA (virtual ISA) -> Implementation ISA

  - Examples
    - Intel과 AMD의 x86 프로세서들은 x86 명령어를 programmer-invisible **micro-operations**로 번역 (in hardware)
    - Transmeta의 x86 프로세서들은 x86 명령어를 "secret" VLIW ISA로 번역 (in software)

- Hardware-Based Translation  
![hardware_translation][def2]  

- Software-Based Translation  
![software_translation][def3]  

<br>

### 6. ISA-level Tradeoffs: Instruction Length
- Fixed Length : 모든 명령어가 동일한 길이
  - 장점
    - 하드웨어에서 명령어 decoding이 쉬움
    - 여러 명령어를 동시에 decoding하기 쉬움
  - 단점
    - 명령어에 낭비되는 bits가 생김
    - ISA를 확장하기 어려움

- Variable Length : 명령어 길이가 다양함 (opcode와 sub-opcode로 결정됨)
  - 장점
    - 컴팩트한 encoding
  - 단점
    - 한 명령어를 decoding하는데 더 많은 로직 필요
    - 여러 명령어를 동시에 decoding하기 어려움

- Tradeoffs
  - 코드 크기 vs. 하드웨어 복잡도
  - ISA의 확장력과 표현력
  - Smaller code와 imperfect decode 간의 성능 tradeoff

<br>

### 7. ISA-level Tradeoffs: Uniform Decode
- Uniform Decode : 모든 명령어가 동일한 형식. 각 명령어의 같은 비트는 같은 의미에 대응됨
  - Opcode가 항상 같은 위치
  - Ditto operand specifiers, immediate values, ...
  - 대부분의 "RISC" ISAs: Alpha, MIPS, SPARC
  - 장점
    - 더 쉬운 decoding, 간단한 하드웨어
    - 병렬화를 가능하게 함 : 명령어가 branch임을 알기 전에, target address 생성
  - 단점
    - 명령어 형식을 제한(-> fewer instructions) 또는 공간 낭비

- Non-uniform Decode : 명령어 형식이 다양함
  - e.g., x86에서 opcode는 1st-3th byte에 있을 수 있음
  - 장점
    - 더 컴팩트하고 파워풀한 명령어 형식
  - 단점
    - 더 복잡한 decoding 로직

<br>

- x86 vs. Alpha 명령어 형식  
![x86_vs_alpha][def4]  

<br>

- Uniform decode는 주로 fixed-length
- Variable-length ISA에서, uniform decode는 같은 길이 명령어들 끼리의 property
  - 서로 다른 길이의 명령어의 uniformity는 보장하지 않음

<br>

### 8. ISA-level Tradeoffs: Number of Registers
- Affects
  - 레지스터 주소 encoding에 필요한 bits 수
  - Fast storage(register file)에 저장되는 값의 수
  - (uarch) Size, access time, register file의 power consumption

- Large # of Registers
  - 장점
    - 컴파일러가 더 많은 값을 레지스터에 저장할 수 있음 -> 메모리 접근 감소
    - 컴파일러 입장에서 편함 (지역변수나 함수 인자 등에서)
  - 단점
    - 더 큰 명령어 크기
    - 더 큰 register file 크기  

    <br>

### 9. ISA-level Tradeoffs: Addressing Modes
- Addressing mode는 명령어에서 operand를 어떻게 지정하는지 정의
  - Register
  - Immediate
  - Memory (displacement, register indirect, indexed, absolute, memory indirect, autoincrement, autodecrement, ...)  

- More modes
  - 장점
    - 프로그래밍 구조적으로 더 많은 지원을 제공 (배열, 포인터 기반 접근)
  - 단점
    - 아키텍트들로 하여금 디자인하기 어렵게 만듬
    - 컴파일러에게 너무 많은 선택지를 줌
      - 같은 것에 대해 많은 방법이 존재하면 컴파일러 디자인을 복잡하게 만듬

<br>

- x86 Addressing Modes  
![x86_addressing_modes_1][def5]  
![x86_addressing_modes_2][def6]  
![x86_addressing_modes_3][def7]  
  - Displacement : Static address
  - Base : Dynamic storage
  - Base + Didsplacement : Arrays, Records
  - (Index + Scale) + Displacement : Static arrays with fixed-size elements
  - Base + Index + Displacement : 2D arrays, Structure
  - Base + (Index + Scale) + Displacement : 2D arrays  

<br>

### 10. Summary
- Usually...
  - RISC
    - Simple instructions
    - Fixed-length
    - Uniform decode
    - Few addressing modes

  - CISC
    - Complex instructions
    - Variable-length
    - Non-uniform decode
    - Many addressing modes

<br>

### 11. Other Examples of ISA-level Tradeoffs
- Condition codes vs. not
- VLIW (Very Long Instruction Word) vs. single instruction
- Precise vs. imprecise exceptions
- Virtual memory vs. not
- Unaligned access vs. not
- Hardware interlocks vs. software-guaranteed interlocking
- Software vs. hardware mannaged page fault handling
- Cache coherence (hardware vs. software)
- ... etc.

<br>

- 많은 ISA features들은 프로그래머 친화적으로 디자인되었음.
- 그러나 이는 하드웨어 디자이너의 일을 복잡하고 어렵게 만듬.

<br>

### 12. Aligned Access vs. Unaligned Access
- MIPS : Aligned Access  
![mips_aligned_access][def8]  
  - LW(Load Word)/SW(Store Word) alignment restriction : 4-byte word-alignment
    - word boundary 내에 있지 않은 메모리 bytes를 fetch하지 않도록 디자인
    - unaligned bytes를 레지스터로 회전시키지 않도록 디자인
  - 특수한 케이스에서 드물게 seperate opcodes 제공  
  ![seperate_opcodes][def9]  
    - LWL과 LWR 역시 여전히 word boundary 내에서 fetch함

- x86 : Unaligned Access  
![x86_unaligned_access][def10]  
  - LD(Load)/ST(Store) 명령어는 "word" boundary를 span하여 자동으로 데이터를 align
  - 프로그래머나 컴파일러는 어디에 데이터가 저장되어 있는 지 (word-aligned location 내에 있는 지 아닌 지) 신경쓰지 않아도 됨  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/PsRlyUX.png
[def2]: https://i.imgur.com/2gSHhjZ.png
[def3]: https://i.imgur.com/Ulnn1KN.png
[def4]: https://i.imgur.com/imP5IAz.png
[def5]: https://i.imgur.com/4AZVbmr.png
[def6]: https://i.imgur.com/BJ4FcCt.png
[def7]: https://i.imgur.com/NB1tqMv.png
[def8]: https://i.imgur.com/rD0ehs3.png
[def9]: https://i.imgur.com/krKXtWG.png
[def10]: https://i.imgur.com/wvZCtd0.png