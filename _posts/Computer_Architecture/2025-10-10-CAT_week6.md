---
layout: post
title: "[컴퓨터구조] 6주차 - ISA: Tradeoff"
excerpt: "Complex vs. Simple Instructions, ISA-level Tradeoffs: Semantic Gap, Small Semantic Gap"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-10-08
last_modified_at: 2025-10-14
---
## ISA: Tradeoff
- Computer Architecture는 다양한 design point가 존재하고, 적절한 tradeoff를 찾아야 함  

### 1. Complex vs. Simple Instructions
- Complex instruction : 많은 일을 하는 instruction
  - 여러 operations
  - e.g.,
    - Double linked list에 insert
    - `cos(x)` 계산, Fast Fourier Transform\
    - 문자열 복사

- Simple instruction : 적은 일을 하는 instruction
  - e.g.,
    - Add
    - Xor
    - Shift

<br>

### 2. ISA-level Tradeoffs: Semantic Gap
- ISA를 어디에 위치시킬 것인가? - Semantic Gap
  - High-level language(HLL)에 가깝게 vs. hardware control signals에 가깝게
  - RISC vs. CISC vs. HLL machines

- Very large semantic gap
  - 하드웨어에 가깝다. signal을 직접 컨트롤한다.
  - Complex compiler, simple hardware

- Very small semantic gap
  - ISA가 high-level language에 가깝다.
  - Simple compiler, complex hardware
  - ISA가 복잡해지면, Backward compatibility 유지가 어려워진다. (e.g., x86)

<br>

### 3. Small Semantic Gap
- x86: Small Semantic Gap: String Operations
  - 문자열에 대해 연산하는 하나의 명령어
    - 임의의 길이의 문자열을 다른 메모리 위치로 복사 
    - 두 문자열을 비교

- `REP`라고 불리는 접두어(prefix)를 사용하여, 문자열 연산 명령어를 반복적으로 수행
  - e.g., `REP MOVS` instruction  
  ![rep_movs][def]  

<br>

- Small Semantic Gap Examples in VAX
  - FIND FIRST
    - 비트 필드에서 첫 set bit를 찾음
    - OS의 자원 할당 연산을 지원
  - SAVE CONTEXT, LOAD CONTEXT
    - 특수한 context switching 명령어
  - INSQUEUE, REMQUEUE
    - doubly linked list에 대한 연산
  - INDEX
    - bounds checking과 함께 배열 액세스
  - STRING Operations
    - Compare strings, find substrings, ...
  - Cyclic Redundance Check Instructions  

  <br>

- 이렇게 Small Semantic Gap의 복잡한 명령어로 인해 F00F 버그가 발생했다. (Intel Pentium)
  - conditional swap 명령어를 단 `2`byte의 `0F C7`로 제공
  - 그런데 `eax` 레지스터와 함께 사용 시 exception 발생
  - 여기에 더불어 `lock` prefix(`F0`)를 붙이면, 컴퓨터 전체가 멈추는 치명적인 버그 발생  

<br>

### 4. Small vs. Large Semantic Gap
- CISC vs. RISC
  - Complex Instruction Set Computer -> 복잡한 명령어
  - Reduced Instruction Set Computer -> 단순한 명령어
    - 목표 : 더 나은 컴파일러 컨트롤과 최적화

- RISC의 제작 동기
  - Complex instruction 작업이 오래 걸리면 memory stall이 발생, pipeline이 멈추는 문제
  - 하드웨어의 단순화 -> 더 낮은 비용, 더 높은 frequency
  - 컴파일러로 하여금 코드를 더 잘 최적화하게 하려고
    - stall을 줄이기 위한 fine-grain parallelism

<br>

- Small Semantic Gap (Complex instructions)의 장점
  - Denser encoding -> 더 작은 코드 크기 -> off-chip bandwidth 절약, 더 나은 cache-hit rate
  - 간단한 컴파일러

- Small Semantic Gap (Complex instructions)의 단점
  - 더 많은 일을 한번에 처리하려고 함 -> 컴파일러는 최적화의 기회를 잃음
  - 더 복잡한 하드웨어 -> signal 컨트롤과 최적화를 위해 하드웨어 차원에서 translation을 필요로 함

<br>

### 5. Translation
- ISA는 쉽게 변경되기 어렵다.  
그럼에도 시간이 지나며 여러 고려사항들을 반영하고/만족시키기 위해 진화해왔다.

- Examples
  - 제한된 on-chip & off-chip memory size
  - 제한된 컴파일러 최적화 기술
  - 제한된 memory bandwidth
  - 중요한 애플리케이션에 대한 specialization의 필요성 (e.g., MMX)

- Translation의 사용은 ISA에 관계 없이 underlying implementation들이 유사해질 수 있도록 만들었다.

- Effect of Translation
  - 한 ISA에서 다른 ISA로 translate하여, Semantic Gap tradeoff를 극복
    - ISA (virtual ISA) -> Implementation ISA

  - Examples
    - Intel과 AMD의 x86 프로세서들은 x86 명령어를 programmer-invisible **micro-operations**로 번역 (in hardware)
    - Transmeta의 x86 프로세서들은 x86 명령어를 "secret" VLIW ISA로 번역 (in software)

- Hardware-Based Translation  
![hardware_translation][def2]  

- Software-Based Translation  
![software_translation][def3]  

<br>

### 6. ISA-level Tradeoffs: Instruction Length
- Fixed Length : 모든 명령어가 동일한 길이
  - 장점
    - 하드웨어에서 명령어 decoding이 쉬움
    - 여러 명령어를 동시에 decoding하기 쉬움
  - 단점
    - 명령어에 낭비되는 bits가 생김
    - ISA를 확장하기 어려움

- Variable Length : 명령어 길이가 다양함 (opcode와 sub-opcode로 결정됨)
  - 장점
    - 컴팩트한 encoding
  - 단점
    - 한 명령어를 decoding하는데 더 많은 로직 필요
    - 여러 명령어를 동시에 decoding하기 어려움

- Tradeoffs
  - 코드 크기 vs. 하드웨어 복잡도
  - ISA의 확장력과 표현력
  - Smaller code와 imperfect decode 간의 성능 tradeoff

<br>

### 7. ISA-level Tradeoffs: Uniform Decode
- Uniform Decode : 모든 명령어가 동일한 형식. 각 명령어의 같은 비트는 같은 의미에 대응됨
  - Opcode가 항상 같은 위치
  - Ditto operand specifiers, immediate values, ...
  - 대부분의 "RISC" ISAs: Alpha, MIPS, SPARC
  - 장점
    - 더 쉬운 decoding, 간단한 하드웨어
    - 병렬화를 가능하게 함 : 명령어가 branch임을 알기 전에, target address 생성
  - 단점
    - 명령어 형식을 제한(-> fewer instructions) 또는 공간 낭비

- Non-uniform Decode : 명령어 형식이 다양함
  - e.g., x86에서 opcode는 1st-3th byte에 있을 수 있음
  - 장점
    - 더 컴팩트하고 파워풀한 명령어 형식
  - 단점
    - 더 복잡한 decoding 로직

<br>

- x86 vs. Alpha 명령어 형식  
![x86_vs_alpha][def4]  

<br>

- Uniform decode는 주로 fixed-length
- Variable-length ISA에서, uniform decode는 같은 길이 명령어들 끼리의 property
  - 서로 다른 길이의 명령어의 uniformity는 보장하지 않음

<br>

### 8. ISA-level Tradeoffs: Number of Registers
- Affects
  - 레지스터 주소 encoding에 필요한 bits 수
  - Fast storage(register file)에 저장되는 값의 수
  - (uarch) Size, access time, register file의 power consumption

- Large # of Registers
  - 장점
    - 컴파일러가 더 많은 값을 레지스터에 저장할 수 있음 -> 메모리 접근 감소
    - 컴파일러 입장에서 편함 (지역변수나 함수 인자 등에서)
  - 단점
    - 더 큰 명령어 크기
    - 더 큰 register file 크기

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/PsRlyUX.png
[def2]: https://i.imgur.com/2gSHhjZ.png
[def3]: https://i.imgur.com/Ulnn1KN.png
[def4]: https://i.imgur.com/imP5IAz.png