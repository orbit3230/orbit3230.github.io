---
layout: post
title: "[컴퓨터구조] 11주차 - MIPS Microarchitecture"
excerpt: "Introduction, Instruction Processing"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-11-12
last_modified_at: 2025-11-12
---
## MIPS Microarchitecture
### 1. Introduction
- 성능을 결정하는 요소
  - Instruction count
    - ISA와 compiler에 의해 결정
  - CPI (Cycles Per Instruction) & Cycle time
    - CPU hardward에 의해 결정  

- 우리는 두 가지 MIPS 구현에 대해 배울 것이다.
  - A simplified version (a.k.a. single-cycle uArch)
  - A more realistic **pipelined** version

- Datapath 생성과, 핵심 MIPS 명령어 집합의 simple subset 컨트롤을 디자인하는데 사용된 핵심 principles를 다루어 볼 것이다.
  - Memory reference : `lw`, `sw`
  - Arithmetic/logical : `add`, `sub`, `and`, `or`, `slt`
  - Control transfer : `beq`, `j`  

<br>

### 2. Instruction Processing
- Machine은 어떻게 명령어를 처리할까?
  - 명령어를 처리한다는 것의 의미는 무엇일까?
  - von Neumann Model을 기억해보자.  
  ![instruction_processing][def]  
  - Processing an instruction : 명령어에 대한 ISA specification에 따라, `AS` -> `AS'`로 상태를 변화시키는 것  
    - MIPS의 ISA specification은 green sheet에서 볼 수 있다.  

    <br>

- ISA는 간략하게 `AS'`가 무엇이 되어야 하는 지, 명령어와 `AS`를 고려하여 정의한다.
  - 이는 abstract finite state machine을 정의하고, 여기서  
    - State = programmer visible state
    - Next-state logic = instruction execution specification

  - ISA의 관점에서 보면,  명령어 실행 중에 `AS`와 `AS'` 사이의 어떠한 "중간 단계"도 존재하지 않는다.
    - 명령어 당 하나의 state transition이 존재한다.  

    <br>

- Microarchitecture는 어떻게 `AS`가 `AS'`로 변화하는지를 구현한다.
  - 구현에는 many choices가 존재한다.
  - 우리는 명령어 실행 속도를 최적화하기 위해 **programmer-invisible** state를 가질 수 있다. (명령어 당 여러 단계의 state transition)
    - Choice 1 : `AS` -> `AS'` (in a single clock cycle)
    - Choice 2 : `AS` -> `AS` + `MS1` -> `AS` + `MS2` -> `AS` + `MS3` -> `AS'` (in multiple clock cycles)  

    <br>

- A Very Basic Instruction Processing Engine  
  - 각 명령어는 실행하는 데 single clock cycle을 소요한다.  
  - 따라서 명령어 실행을 구현하는 데 조합회로면 충분하다.  
    - No intermediate, programmer-invisible state updates  
  ![instruction_processing_engine][def2]  

  - Single-cycle machine  
  ![single_cycle_machine][def3]  
    - **clock cycle**을 결정짓는 것은?
    - 조합회로의 **critical path**를 결정짓는 것은?  

<br>

- Remeber: Programmer Visible (Architectural) State  
![programmer_visible_state][def4]  

- Single-cycle vs. Multi-cycle Machines  
  - Single-cycle machines
    - 각 명령어가 single clock cycle을 소요
    - 모든 상태 업데이트는 명령어 실행의 끝에서 수행됨
    - **Big advantage** : 가장 느린 명령어가 cycle time을 결정지음 -> long clock cycle time  

  - Multi-cycle machines
    - 명령어 처리가 여러 cycles/stages로 나누어 들어감
    - 상태 업데이트는 명령어 실행 중에 이루어질 수 있음
    - 그러나 Architectural state 업데이트는 오직 명령어 실행의 끝에서만 이루어짐
    - **Advantage over single-cycle** : 가장 느린 "stage"가 cycle time을 결정지음  

  - Literally, Single-cycle machine과 multi-cycle machine 모두 microarchitecture level에서 von-Neumann machine을 따른다.  

<br>

- Instruction Processing "Cycle"
  - 명령어는 "control unit"의 방향으로 스텝 바이 스텝으로 처리된다.
  - Instruction cycle : 명령어를 처리하기 위한 스텝의 Sequence  
    - Fetch
    - Decode
    - Evaluate Address
    - Fetch Operands
    - Execute
    - Store Result  

  - 모든 명령어가 모든 6개의 단계를 거쳐야 하는 것은 아니다.  

- Instruction Processing "Cycle" vs. Machine Clock Cycle
  - Single-cycle machine : 명령어 처리 사이클의 모든 6단게가 하나의 **single machine clock cycle**에 완수

  - Multi-cycle machine : 명령어 처리 사이클의 모든 6단계가 여러 **machine clock cycles**에 걸쳐 완수
    - 실제로, 각 단계가 하나 이상의 multiple clock cycles를 소요할 수 있다.  

  <br>

- Instruction Processing Viewed Another Way
  - 명령어는 Data(`AS`)를 Data'(`AS'`)로 변화시킴
  - 이 변화는 functional units에 의해 수행됨
    - data에 대해 "operate"하는 Units
  - 이 Units들은 데이터에 대해 무엇을 해야할 지 알아야 함
  - **Intruction processing engine**은 두 가지 주요 컴포넌트로 구성됨
    - **Datapath** : 데이터 시그널을 다루고 변형하는 하드웨어 elements로 구성
      - 데이터 위에서 작동하는 functional units
      - functional units와 레지스터로의 데이터 플로우를 가능하게 하는 hardware structures(e.g., wires & muxes)
      - 데이터를 저장하는 storage units

    - **Control Unit** : 컨트롤 시그널을 결정하는 하드웨어 elements로 구성
      - 즉, datapath의 각 요소가 무엇을 해야할 지 결정  

  <br>

- Single-cycle vs. Multi-cycle & Data
  - Single-cycle machine : 같은 clock cycle에서 생성된 컨트롤 시그널을 하나로 취급 (데이터 시그널이 작동하는 동안)
    - 명령어와 관련된 모든 것들이 하나의 clock cycle에 일어남 (serialized processing)

  - Multi-cycle machine : 다음 사이클에 필요한 컨트롤 시그널이 현재 사이클에서 생성될 수 있음
    - 컨트롤 프로세싱의 Latency가 Datapath operation의 Latency와 오버랩될 수 있음 (more parallelism)

<br>

- Many Ways of Datapath & Control Design
  - Datapath와 Control logic을 디자인하는 많은 방법이 존재
  - Single-cycle, multi-cycle, pipelined datapath and control
  - Single-bus vs. multi-bus datapaths
  - Hardwired/Combinational vs. Microcoded/Microprogrammed control
    - Combinational logic에서 생성되는 컨트롤 시그널 vs. 메모리 구조에 저장된 컨트롤 시그널

  - 컨트롤 시그널과 구조는 datapath의 디자인에 따라 달라짐  

<br>

- Flash-Forward: Performance Analysis
  - 명령어 Execution Time = `{CPI}` x `{Clock Cycle Time}`

  - 프로그램 Execution Time = `{Instruction Count}` x `{Average CPI}` x `{Clock Cycle Time}`

  - Single cycle microarchitecture performance
    - `CPI` = `1`
    - `Clock Cycle Time` = long (critical path)

  - Multi-cycle microarchitecture performance
    - `CPI` = 명령어 마다 다름
      - `Average CPI` -> hopefully 낮음
    - `Clock Cycle Time` = short

<br>

- Let's Start with the State Elements
  - Data & Control inputs  
  ![state_elements][def5]  

- 이제부터, 이렇게 가정
  - "Magic" Memory & Register File
  - Combinational read
  - Synchronous write
  - Single-cycle, synchronous memory

<br>

- Instruction Processing - 5 Generic Steps
![instruction_processing_steps][def6]  
  - (IF) Instruction Fetch
  - (ID/RF) Instruction Decode & Register Operand Fetch
  - (EX/AG) Execute / Evaluate Memory Address
  - (MEM) Memory Operand Fetch
  - (WB) Store / Writeback Result

- Instruction Processing (Cont'd)
  - Fetch Instruction
    - PC -> instruction memory

  - Decode Instruction

  - Read Registers
    - Register numbers -> register file

  - Depending on instruction class
    - 계산하는 데에 ALU 사용
      - 산술연산 결과
      - Load/Store를 위한 메모리 주소
      - Branch target address
    - Load/Store를 위한 데이터 메모리 접근
    - PC <- target address or PC + 4

<br>

- Aside: A Big Picture  
![big_picture][def7]  

<br>

- The Full MIPS Datapath  
![full_mips_datapath][def8]  

<br>

### 3. MIPS Instructions Design
- Logic Design Basics
  - 정보는 binary signal로 표현됨
    - Low voltage = `0`, High voltage = `1`
    - 하나의 bit 당 하나의 wire
    - Multi-bit-date는 Multi-wire buses에 인코딩됨

  - Datapath elements
    - Combinational element
      - e.g., adders, shifters, MUXes, ...
    - State (sequential) elements
      - e.g., registers, memory, ...

<br>

- Fetching Instructions  
![instruction_fetching][def9]  
  - Instruction을 Fetch하고 PC를 증가  
  ![instruction_fetching_datapath][def10]  

<br>

### 4. Single-Cycle Datapath for Arithmetic and Logical Instructions  
- R-Type ALU Instructions
  - Assembly (e.g., register-register signed addition)  
  `ADD rd`<sub>`reg`</sub>` rs`<sub>`reg`</sub>` rt`<sub>`reg`</sub>  

  - Machine encoding  
  ![r_type_encoding][def11]  

  - Semantics  
  ![r_type_semantics][def12]  

  - ALU Datapath  
  ![r_type_alu_datapath][def13]  

<br>

- I-Type ALU Instructions
  - Assembly (e.g., register-immediate signed addition)  
  `ADDI rt`<sub>`reg`</sub>` rs`<sub>`reg`</sub>` immediate`<sub>`16`</sub>  

  - Machine encoding  
  ![i_type_encoding][def14]  
  
  - Semantics  
  ![i_type_semantics][def15]  

  - Datapath for R & I-Type ALU Instructions  
  ![i_type_alu_datapath][def16]  

<br>

### 5. Single-Cycle Datapath for Data Movement Instructions  
- Load Instructions  
  - Assembly (e.g., load 4-byte word)  
  `LW rt`<sub>`reg`</sub>` offset`<sub>`16`</sub>`(base`<sub>`reg`</sub>`)`  

  - Machine encoding  
  ![load_encoding][def17]  

  - Semantics  
  ![load_semantics][def18]  

  - LW Datapath  
  ![lw_datapath][def19]  

<br>

- Store Instructions  
  - Assembly (e.g., store 4-byte word)  
  `SW rt`<sub>`reg`</sub>` offset`<sub>`16`</sub>`(base`<sub>`reg`</sub>`)`  

  - Machine encoding  
  ![store_encoding][def20]  

  - Semantics  
  ![store_semantics][def21]  

  - SW Datapath  
  ![sw_datapath][def22]  

  <br>

- Load-Store Datapath  
![load_store_datapath_1][def23]  
![load_store_datapath_2][def24]  

  <br>

### 7. Single-Cycle Datapath for Control-Flow Instructions  
- Unconditional Jump Instructions  
  - Assembly  
  `J immediate`<sub>`26`</sub>  

  - Machine encoding  
  ![jump_encoding][def25]  

  - Semantics  
  ![jump_semantics][def26]  

  - Unconditional Jump Datapath  
  ![jump_datapath_1][def27]  
  ![jump_datapath_2][def28]  
  ![jump_datapath_3][def29]  

  <br>

- Conditional Branch Instructions  
  - Assembly (e.g., branch if equal)  
  `BEQ rs`<sub>`reg`</sub>` rt`<sub>`reg`</sub>` offset`<sub>`16`</sub>  

  - Machine encoding  
  ![branch_encoding][def30]  

  - Semantics  
  ![branch_semantics][def31]  

  - Conditional Branch Datapath  
  ![branch_datapath][def32]  

<br>

### 8. Datapath for All MIPS Instructions  
- Putting It All Together  
![datapath_all_mips_instructions][def33]  

<br>

### 9. Single-Cycle Control Unit Design
- Single-Cycle Control Logic
  - `Inst`=`MEM[PC]`의 Combinational function으로서,  
  ![single_cycle_control_logic][def34]  

  - 고려해야 할 것  
    - 모든 R-Type 과 I-Type ALU 명령어들
    - `LW`, `SW`
    - `BEQ`, `BNE` 
    - `J`, `JR`, `JAL`  

<br>

- Single-Bit Control Signals  
![single_bit_control_signals_1][def35]  
![single_bit_control_signals_2][def36]  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/JeKEldY.png
[def2]: https://i.imgur.com/KBnisJB.png
[def3]: https://i.imgur.com/9wQh2U0.png
[def4]: https://i.imgur.com/LJM5FaY.png
[def5]: https://i.imgur.com/Ki1Tjjp.png
[def6]: https://i.imgur.com/tw4Je2t.png
[def7]: https://i.imgur.com/JhyUAya.png
[def8]: https://i.imgur.com/TVij8qa.png
[def9]: https://i.imgur.com/2Tn8qO2.png
[def10]: https://i.imgur.com/XHZgTB6.png
[def11]: https://i.imgur.com/WWmqR1Y.png
[def12]: https://i.imgur.com/uWmUnPF.png
[def13]: https://i.imgur.com/sx54ALL.png
[def14]: https://i.imgur.com/g2wt4Wn.png
[def15]: https://i.imgur.com/vpdFGKW.png
[def16]: https://i.imgur.com/CHoqB3S.png
[def17]: https://i.imgur.com/7WtPTBc.png
[def18]: https://i.imgur.com/lEcThUY.png
[def19]: https://i.imgur.com/H9rXY2V.png
[def20]: https://i.imgur.com/2SC0aMw.png
[def21]: https://i.imgur.com/4ursoc0.png
[def22]: https://i.imgur.com/PAWhNBT.png
[def23]: https://i.imgur.com/wealG8U.png
[def24]: https://i.imgur.com/KPLGwA8.png
[def25]: https://i.imgur.com/emRQXXZ.png
[def26]: https://i.imgur.com/A17ugkT.png
[def27]: https://i.imgur.com/zGdbLYE.png
[def28]: https://i.imgur.com/Ztcy9Cw.png
[def29]: https://i.imgur.com/FT70mWj.png
[def30]: https://i.imgur.com/ieOk70s.png
[def31]: https://i.imgur.com/SX8KtTe.png
[def32]: https://i.imgur.com/BF8ltBX.png
[def33]: https://i.imgur.com/esFaCrN.png
[def34]: https://i.imgur.com/vE4Nubn.png
[def35]: https://i.imgur.com/ksIoGzA.png
[def36]: https://i.imgur.com/Dk0IRIS.png