---
layout: post
title: "[컴퓨터구조] 11주차 - MIPS Microarchitecture"
excerpt: "Introduction, Instruction Processing"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-11-12
last_modified_at: 2025-11-12
---
## MIPS Microarchitecture
### 1. Introduction
- 성능을 결정하는 요소
  - Instruction count
    - ISA와 compiler에 의해 결정
  - CPI (Cycles Per Instruction) & Cycle time
    - CPU hardward에 의해 결정  

- 우리는 두 가지 MIPS 구현에 대해 배울 것이다.
  - A simplified version (a.k.a. single-cycle uArch)
  - A more realistic **pipelined** version

- Datapath 생성과, 핵심 MIPS 명령어 집합의 simple subset 컨트롤을 디자인하는데 사용된 핵심 principles를 다루어 볼 것이다.
  - Memory reference : `lw`, `sw`
  - Arithmetic/logical : `add`, `sub`, `and`, `or`, `slt`
  - Control transfer : `beq`, `j`  

<br>

### 2. Instruction Processing
- Machine은 어떻게 명령어를 처리할까?
  - 명령어를 처리한다는 것의 의미는 무엇일까?
  - von Neumann Model을 기억해보자.  
  ![instruction_processing][def]  
  - Processing an instruction : 명령어에 대한 ISA specification에 따라, `AS` -> `AS'`로 상태를 변화시키는 것  
    - MIPS의 ISA specification은 green sheet에서 볼 수 있다.  

    <br>

- ISA는 간략하게 `AS'`가 무엇이 되어야 하는 지, 명령어와 `AS`를 고려하여 정의한다.
  - 이는 abstract finite state machine을 정의하고, 여기서  
    - State = programmer visible state
    - Next-state logic = instruction execution specification

  - ISA의 관점에서 보면,  명령어 실행 중에 `AS`와 `AS'` 사이의 어떠한 "중간 단계"도 존재하지 않는다.
    - 명령어 당 하나의 state transition이 존재한다.  

    <br>

- Microarchitecture는 어떻게 `AS`가 `AS'`로 변화하는지를 구현한다.
  - 구현에는 many choices가 존재한다.
  - 우리는 명령어 실행 속도를 최적화하기 위해 **programmer-invisible** state를 가질 수 있다. (명령어 당 여러 단계의 state transition)
    - Choice 1 : `AS` -> `AS'` (in a single clock cycle)
    - Choice 2 : `AS` -> `AS` + `MS1` -> `AS` + `MS2` -> `AS` + `MS3` -> `AS'` (in multiple clock cycles)  

    <br>

- A Very Basic Instruction Processing Engine  
  - 각 명령어는 실행하는 데 single clock cycle을 소요한다.  
  - 따라서 명령어 실행을 구현하는 데 조합회로면 충분하다.  
    - No intermediate, programmer-invisible state updates  
  ![instruction_processing_engine][def2]  

  - Single-cycle machine  
  ![single_cycle_machine][def3]  
    - **clock cycle**을 결정짓는 것은?
    - 조합회로의 **critical path**를 결정짓는 것은?  

<br>

- Remeber: Programmer Visible (Architectural) State  
![programmer_visible_state][def4]  

- Single-cycle vs. Multi-cycle Machines  
  - Single-cycle machines
    - 각 명령어가 single clock cycle을 소요
    - 모든 상태 업데이트는 명령어 실행의 끝에서 수행됨
    - **Big advantage** : 가장 느린 명령어가 cycle time을 결정지음 -> long clock cycle time  

  - Multi-cycle machines
    - 명령어 처리가 여러 cycles/stages로 나누어 들어감
    - 상태 업데이트는 명령어 실행 중에 이루어질 수 있음
    - 그러나 Architectural state 업데이트는 오직 명령어 실행의 끝에서만 이루어짐
    - **Advantage over single-cycle** : 가장 느린 "stage"가 cycle time을 결정지음  

  - Literally, Single-cycle machine과 multi-cycle machine 모두 microarchitecture level에서 von-Neumann machine을 따른다.  

<br>

- Instruction Processing "Cycle"
  - 명령어는 "control unit"의 방향으로 스텝 바이 스텝으로 처리된다.
  - Instruction cycle : 명령어를 처리하기 위한 스텝의 Sequence  
    - Fetch
    - Decode
    - Evaluate Address
    - Fetch Operands
    - Execute
    - Store Result  

  - 모든 명령어가 모든 6개의 단계를 거쳐야 하는 것은 아니다.  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/JeKEldY.png
[def2]: https://i.imgur.com/KBnisJB.png
[def3]: https://i.imgur.com/9wQh2U0.png
[def4]: https://i.imgur.com/LJM5FaY.png