---
layout: post
title: "[컴퓨터구조] 14주차 - MIPS Pipelining"
excerpt: "Advantages of Microprogramming, Update of Machine Behavior, New Attack Surfaces on ISA/uArch/uCode, Basic Idea of Pipelining, An Ideal Pipeline, Pipelined Operation, Pipeline Design"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-12-02
last_modified_at: 2025-12-03
---
## MIPS Microarchitecture
### 1. Advantages of Microprogramming
- The Power of Abstraction
  - Microinstructions의 control store 개념은 하드웨어 디자이너가, **microprogramming**이라는 새로운 추상화를 가능하게 한다.
  - 디자이너는 어떠한 operation이든 microinstructions의 시퀀스로 구현할 수 있다.
  - 모든 디자이너가 제공해야 할 것은,
    - 원하는 operation을 구현하는데 필요한 microinstruction 시퀀스
    - microinstruction을 통해 control logic이 올바르게 sequence되도록 보장하는 것
    - 필요한 어떠한 추가적인 datapath elements와 control signals

- Microprogrammed Control의 장점  
  - 아주 간단한 디자인으로 하여금 datapath를 컨트로함으로써 강력한 computation을 가능하게 한다.
    - High-level ISA가 microcode로 번역된다. (u-instructions의 시퀀스)
    - Microcode(u-code)는 minimal datapath가 ISA를 emulate하도록 해준다.
    - Microinstructions는 user-invisible ISA(u-ISA)로 생각될 수도 있다.

  - ISA의 쉬운 확장가능성을 제공한다.
    - microcode를 변경하는 것만으로도 새로운 명령어를 지원할 수 있다.
    - 복잡한 명령어들을 간단한 microinstructions의 시퀀스로 지원할 수 있다.

  - Machine behavior의 업데이트를 가능하게 한다.
    - 명령어 구현이 buggy하더라도, field에서 microcode를 변경하여 고칠 수 있다.
    - 바로 다음 섹션에서 다룬다.

    <br>

### 2. Update of Machine Behavior
- Field에서 차후에 micro code를 update/patch 가능하게 되면, 프로세서 변경 없이 새로운 명령어를 추가할 수 있게 해준다!

- Example
  - IBM 370 Model 145 : 메인 메모리에 저장된 microcode가 reboot후 업데이트 될 수 있다.
  - IBM System z : 370/145와 비슷하다.
  - B1700 microcode는 프로세서가 실행되는 동안에도 업데이트 될 수 있다.
    - User-microprogrammable machine !

  - Example of modern CPUs  
  ![modern_cpu_microcode_update][def]  

<br>

### 3. New Attack Surfaces on ISA/uArch/uCode  
- Example in terms of system security  
![microcode_security_attack_surface][def2]  

<br>

- Breaking the x86 instruction set, Blackhat 2017
- Reverse-engineering x86 Processor Microcode, Philipp Koppe et al., USENIX Security 2017
- An Exploratory Analysis of Microcode as a Building Block for System Defenses, Benjamin Kollenda et al., CCS 2018
- CHEx86: Context-Sensitive Enforcement of Memory Safety via Microcode-Enabled Capabilities, Rasool Sharifi, ISCA 2020
- On the Design and Misuse of Microcoded (Embedded) Processors - A Cautionary Note, Nils Albartus et al, USENIX Security 2021
- ...

<br>

## MIPS Pipelining
### 1. Basic Idea of Pipelining
- Can We Do Better?

- Concurrency를 향상시키기 위해 Idle Hardware를 사용할 수 있을까?
  - 목표 : **More concurrency** -> **Higher instruction throughput**  
  (즉, 한 사이클에 더 많은 "work" 수행)

  - 아이디어 : 명령어가 처리 단계에 리소스를 사용하는 동안, 해당 명령어가 필요로 하지 않는 idle 리소스로 다른 명령어를 처리
    - e.g., 명령어가 decode 되는 동안, 다음 명령어를 fetch
    - e.g., 명령어가 실행되는 동안, 다른 명령어를 decode
    - e.g., 명령어가 데이터 메모리에 접근하는 동안(ld/st), 다음 명령어를 실행
    - e.g., 명령어가 결과를 레지스터 파일에 쓰는 동안, 다음 명령어에 대한 데이터 메모리에 접근

- Pipelining: Basic Idea
  - More systematically, 여러 명령어의 실행을 Pipeline.
  - 아이디어
    - 명령어 처리 사이클을 별개의 처리 "단계(stages)"로 나눈다.
    - 물론, 각 단계에서 하나의 명령어를 처리할 수 있는 충분한 하드웨어 리소스가 필요하다.
    - 각 단계에서 서로 다른 명령어를 처리한다.
      - 프로그램 순서 상 연속된 명령어들은 연속된 stages에서 처리된다.  

  - 이점 : 명령어 처리 throughput(1/CPI)를 증가시킨다.
  - 단점 : 차후 다룬다.

<br>

- Example: Execution of Four Independent `ADD`
  - Multi-cycle : 명령어 당 `4` cycles  
  ![example_multi_cycle][def3]  

  - Pipelined : `4`개 명령어 당 `4`cycles (steady state)  
  ![example_pipelined][def4]  

- The Laundry Analogy  
![laundry_analogy][def5]  
  - 실제로는 각 단계의 실행 시간이 다르니, 가장 느린 step이 throughput을 결정한다.  
  ![laundry_pipeline_in_practice][def6]  
  - 그렇다면 가장 느린 단계를 수행하는 하드웨어를 여러 개 두면 개선할 수도 있겠다.  
  ![laundry_pipeline_with_replicas][def7]  
    - 또는 더 빠른 하드웨어를 사용한다거나...

<br>

### 2. An Ideal Pipeline
- 목표 : 최소한의 Cost 증가로 Throughput을 극대화하는 것 (명령어 처리의 경우, 하드웨어 cost)

- 동일한 operations의 반복
  - 다양한 많은 수의 inputs들에 대해 동일한 operation이 반복된다.  

- 독립적인 operations의 반복
  - 반복되는 operations 간에는 dependencies가 없어야 한다.

- 균등하게 나누어질 수 있는 sub-operations
  - 프로세싱 과정은 균등한 latency의 sub-operations으로 even하게 나누어질 수 있어야 한다.
  - sub-operations 간에는 리소스를 공유하지 않아야 한다.

- Ideal Pipelining  
![ideal_pipelining][def8]  

<br>

- More Realistic Pipeline: Cost
  - 각 stage는 latch를 필요로 한다. Latch에 저장하는 시간을 `L`이라고 하자.
  - combinational cost `G`의 Nonpipelined version  
  ![nonpipelined_cost][def9]  
    - `Cost` = `G` + `L`
  - `k`-stage Pipelined version  
  ![pipelined_cost][def10]  
    - `Cost`<sub>`k-stage`</sub> = `G` + `Lk`  
    - Latch는 hardware cost를 증가시킨다.

<br>

### 3. Pipelined Operation
- Dividing Into Stages  
![pipelined_operation_stages][def11]  
  - 올바른 Partitioning일까? Ideal에 가까워 보이지는 않는다.  

- Instruction Pipeline Throughput  
![instruction_pipeline_throughput][def12]  

- Enabling Pipelined Processing: Pipeline Registers  
![pipeline_registers][def13]  

<br>

- Illustrating Pipeline Operation: Operation View  
![pipeline_operation_view][def14]  

- Illustrating Pipeline Operation: Resource View  
![pipeline_resource_view][def15]  

<br>

- Control Points in a Pipeline  
![control_points_in_pipeline][def16]

- Control Signals in a Pipeline
  - 주어진 명령어에 대해,
    - 같은 control signals를 single-cycle처럼, 하지만
    - control signals는 다른 cycles에서 필요로 한다. (각 stage마다 다름)
    - Option 1 : 같은 logic을 single-cycle처럼 사용하여 한번만 decode하고, 소비될 때까지 signals를 buffer한다.  
    ![pipeline_control_signals_option1][def17]  
    - Option 2 : pipeline을 내려가며 관련있는 "명령어 word/field"를 carry하고, 각 or 이전 stage 내에서 locally decode한다.  

- Pipelined Control Signals  
![pipelined_control_signals][def18]  

<br>

### 4. Pipeline Design  
- Instruction Pipeline은 사실 이상적인 파이프라인이 아니다.
  - 동일한 operations.. -> NOT
    - 서로 다른 명령어는 같은 단계를 거치지 않는다.
      - 다른 명령어들이 같은 단계를 거치도록 강제할 수는 있지만, 비효율적이다.
      - External fragmentation 문제 발생

  - 균등하게 나누어질 수 있는 sub-operations.. -> NOT
    - 서로 다른 pipeline stages -> 서로 다른 latency
      - 각 stage가 같은 clock에 컨트롤되도록 강제할 수는 있지만, 비효율적이다.
      - Internal fragmentation 문제 발생

  - Independent operations.. -> NOT
    - 서로 다른 명령어들은 종종 dependencies를 가진다.
      - Pipeline이 올바른 결과를 내도록 보장하려면, 명령어 간의 종속성을 찾아서 해결해야한다.
      - **Pipeline stalls**

<br>

- 파이프라인 디자인 이슈
  - 각 stage를 어떻게 나눌 것인가?
    - 그리고 각 stage에서 무엇이 수행되는가?
    - 하지만 microarchitecture 레벨이 아닌 더 low-level에서 다룬다. 따라서 여기서는 생략

  - Pipeline flow를 해치는 여러 이벤트에서 파이프라인이 정상적으로 동작하고, full pipeline을 유지하려면 어떻게 해야하는가?
    - Data와 Control의 종속성 핸들링
    - 리소스 contention 핸들링
    - Long-latency(multi-cycle) operations 핸들링

  - Exceptions, Interrupts 핸들링
  - 심화: Pipeline throughput 향상
    - stalls 최소화  

<br>

- 파이프라인 Stall의 요인
  - Stall : 파이프라인의 진행이 멈추는 것
  - (1) 리소스 contention
  - (2) 명령어 간 종속성
    - Data
    - Control
  - (3) Long-latency (multi-cycle) operations

<br>

- Dependency Types
  - Dependences는 명령어 간의 순서 제약 조건을 나타낸다.
  - Data Dependency : 이전 명령어가 자신의 데이터 읽기/쓰기를 완료할 떄 까지 기다려야 하는 경우
  - Control Dependency : 컨트롤 액션에 대한 결정이 이전 명령어에 의존하는 경우

<br>

- 리소스 Contention (Resource dependency)
  - 리소스에 대한 사용의 Conflict
  - 두 파이프라인 단계의 명령어들이 같은 리소스를 필요로할 때 발생  
  ![resource_contention][def19]  

- 해결 방법
  - Solution 1 : 리소스 contention을 감지하고 stages 중 하나를 stall
    - 어느 stage를 stall할 지는 prioritization  
    ![resource_contention_solution1][def20]  

  - Solution 2 : Contention의 원인을 제거
    - 리소스 복제, Throughput 향상  

<br>

- Data Dependencies
  - Data dependences의 종류
    - Flow dependence (true dependence, read-after-write, RAW)
    - Anti dependence (write-after-read, WAR)
    - Output dependence (write-after-write, WAW)

  - 이들 중 어느 것이 pipelined machine을 멈추게 할까?
    - 이들 모두에 대해, 프로그램 semantic이 유지되도록 보장해야 한다.
    - Anti & Output dependences는 architectural 레지스터의 개수 제한 떄문에 존재
      - 이들은 value가 아니라 name에 의존한다.
      - 차차 다룬다.

<br>

- Data Dependence Types  
![data_dependence_types][def21]  

<br>

- Pipelined Operation Example  
![pipelined_operation_example][def22]  

<br>

### 5. Data Dependence Handling  
- 어떻게 Data Dependence를 핸들링할까?
  - Anti & Output Dependences는 핸들링하기 더 쉽다.
    - 순서대로 목적지에 값을 쓴다면, 문제 없음

  - Flow Dependences는 더 어렵다.

  - Flow Dependences를 핸들링하는 다섯가지 fundamental 방법
    - (1) 값이 레지스터 파일에서 available해질 때까지 **Wait**
    - (2) Dependent 명령어에 데이터를 **Forwarding/Bypassing**
    - (3) 소프트웨어 레벨에서 Dependence를 **Eliminate**
    - (4) 필요한 값을 **Predict**, speculatively execute 후 **Verify**
    - (5) **Do something else** (fine-grained multithreading 등)  

<br>

- Interlocking : 올바른 execution을 보장하기 위해 pipelined processor 내 명령어 간 의존성을 감지하는 것
  - Software Interlocking vs. Hardware Interlocking
  - MIPS = Microprocessor without Interlocked Pipeline Stages

<br>

- Dependence Detection에 대한 접근법 (1)
  - **Scoreboarding**
    - 레지스터 파일의 각 레지스터가 관련된 Valid bit를 가진다.
    - 현재 레지스터에 **쓰고있는** 명령어가 Valid bit를 `0`으로 초기화
    - Decode 단계에 있는 명령어는 모든 소스 레지스터와 목적지 레지스터의 Valid bit를 검사
      - 하나라도 `0`(invalid)이면, 명령어를 stall.
      - 그렇지 않으면, No need to stall. No dependence.

    - 장점 : 간단하고, 각 레지스터 당 `1`비트만 필요
    - 단점 : 모든 종류의 의존성에 대해 stall 해야함. 

- Dependence Detection에 대한 접근법 (2)
  - **Combination dependence check logic**
    - 이후 단계에 있는 어떠한 명령어가, 현재 Decode 단계에 있는 명령어의 소스 레지스터를 목적지 레지스터로 write하려고 하는 지 검사하는 스페셜 로직
      - Yes -> stall
      - No -> proceed. No flow dependence.

    - 장점 : Anti & Output dependences에 대해 stall하지 않아도 됨.
    - 단점
      - Scoreboarding보다 더 복잡한 로직 필요
      - Pipeline이 길어질수록 더 복잡해짐  

<br>

- 하드웨어에서 Dependence를 Detect 했다면...
  - 이후엔 어떻게 할까?
  - Option 1 : Detection 즉시 stall
  - Option 2 : 오직 필요할 때만 의존성이 있는 명령어를 stall -> Data forwarding/Bypassing  

- Data Forwarding/Bypassing
  - 현재 문제 : 리소스를 소비하는 명령어가, 리소스를 생산하는 명령어가 그 값을 레지스터 파일에 쓰기 전 까지 Decode 단계에서 stall해야 하는 상황
  - 목표 : Pipeline을 불필요하게 stall하지 않도록 하기
  - 직관 : 리소스를 소비하는 명령어가 필요로 하는 데이터 값이, Pipeline의 이후 단계에서 직접 얻어질 수 있으면 되지 않을까? (오직 레지스터 파일에서 가져오려고 하지 말고)
  - 아이디어 : 해당 값이 available해지는 즉시 공급해줄 수 있도록, 추가적인 Dependence check 로직과 data forwarding paths를 추가하자.
  - 이점 : 리소스를 소비하는 명령어가 해당 값이 공급될 수 있는 포인트까지 Pipeline을 진행할 수 있다.  

<br>

### 6. Control Dependence Handling
- Control Dependence
  - Data dependence의 Special case.
  - Instruction Pointer / Program Counter에 대한 Data dependence.

- Question : PC는 다음 사이클에 어느 것을 fetch해야 할까?
- Answer : 다음 명령어의 주소
  - 모든 명령어들은 이전의 명령어에 control dependent하다.

- 만약 Fetched된 명령어가 non-control-flow 명령어라면?
  - 다음 PC Fetch는 Next sequential instruction address
  - 만약 Fetched된 명령어의 사이즈를 알 수 있다면, 쉽게 계산 가능

- 만약 Fetched된 명령어가 Control-flow 명령어라면?
  - 다음 PC Fetch는 어떻게 계산할 수 있을까?

- 실제로 Fetched된 명령어가 Control-flow 명령어인지 아닌지 어떻게 알 수 있을까?  

<br>

### 7. Data Dependence Handling (Cont'd)  
- RAW Dependence Handling
  - 아래 5-단계 파이프라인의 Flow Dependence 중에서 어느 것이 Conflicts를 일으킬까?  
  ![raw_dependence_handling][def23]  

- Register Data Dependence Analysis  
![register_data_dependence_analysis][def24]  
  - 주어진 파이프라인에 대해, 두 Data Dependent instructions 간 발생가능한 potential conflict는 언제일까?
    - Dependency type : RAW, WAR, WAW?
    - 포함된 Instruction types?
    - 두 명령어 간 거리 (distance)?  

  <br>

- 파이프라인의 Safe & Unsafe Movement  
![safe_unsafe_movement][def25]  

- RAW Dependence Analysis Example  
![raw_dependence_analysis_example][def26]  
  - 명령어 `I`<sub>`A`</sub>와 `I`<sub>`B`</sub>는 RAW dependence를 가진다.  
    - `I`<sub>`B`</sub> 는 `I`<sub>`A`</sub>가 레지스터 `R`에 쓴 값을 읽는다.
    - `dist(I`<sub>`A`</sub>`, I`<sub>`B`</sub>`)` ≤ `dist(ID, WB)` = `3`  

<br>

- Pipeline Stall: Resolving Data Dependence  
![pipeline_stall_resolving_data_dependence][def27]  

<br>

- Pipeline Stall  
![pipeline_stall][def28]  

<br>

- How to Implement Stalling  
![how_to_implement_stalling][def29]  
  - Stall
    - `PC`와 `IR` latching을 disable. -> stalled된 명령어가 stage에 머무르도록 함
    - Stalled된 명령어("bubble")를 뒤따르는 stages에 "invalid" 명령어/nops를 삽입
  
- 언제 Stall 할까?
  - 명령어 `I`<sub>`A`</sub> 와 `I`<sub>`B`</sub> 가 RAW dependence를 가진다고 하자.
    - `I`<sub>`B`</sub> 가 `I`<sub>`A`</sub>가 레지스터 `R`에 쓴 값을 읽는다고 하자.
    - `dist(I`<sub>`A`</sub>`, I`<sub>`B`</sub>`)` ≤ `dist(ID, WB)` = `3`

  - `ID`단계에 있는 `I`<sub>`B`</sub> 가 `I`<sub>`A`</sub>가 `EX`, `MEM`, `WB` 단계에서 레지스터 `R`에 쓴 값을 읽으려고 할 때, stall 해야 한다.

<br>

- Stall Condition Evaluation Logic  
  - Helper functions
    - `rs(I)` : 명령어 `I`의 `rs` 필드 값 리턴
    - `use_rs(I)` : 만약 명령어 `I`가 `RF[rs]`를 필요로 하고 `rs!=r0`이면 `true` 리턴  

  - 아래 중 하나와 같을 때 stall
    - `(rs(IR_ID) == dest_EX)` && `use_rs(IR_ID)` && `RegWrite_EX`  
    - `(rs(IR_ID) == dest_MEM)` && `use_rs(IR_ID)` && `RegWrite_MEM`
    - `(rs(IR_ID) == dest_WB)` && `use_rs(IR_ID)` && `RegWrite_WB`  
    - `(rt(IR_ID) == dest_EX)` && `use_rt(IR_ID)` && `RegWrite_EX`  
    - `(rt(IR_ID) == dest_MEM)` && `use_rt(IR_ID)` && `RegWrite_MEM`  
    - `(rt(IR_ID) == dest_WB)` && `use_rt(IR_ID)` && `RegWrite_WB`  

  - Stall cycles 동안 `EX`, `MEM`, `WB` 단계에 있는 명령어들은 계속 진행되는 것이 중요하다.

- Stall이 성능에 미치는 영향
  - 각 Stall cycle은 아예 명령어가 수행되지 않는 하나의 lost cycle과 같다.
  - `N`개의 명령어와 `S`개의 stall cycles가 있는 프로그램에 대해,  
    - `Average CPI` = `(N + S) / N`
  
  - `S`는 아래와 같은 요인에 의해 결정된다.
    - RAW dependences의 빈도
    - Dependence instruction 간 정확한 거리
    - Dependences 간 거리
    
  - 만약 `I`<sub>`1`</sub>, `I`<sub>`2`</sub>, `I`<sub>`3`</sub> 가 모두 `I`<sub>`0`</sub>에 의존한다면, 일단 `I`<sub>`1`</sub>의 종속성이 해결되면 `I`<sub>`2`</sub>와 `I`<sub>`3`</sub>의 종속성도 해결될 것이다.  

<br>

- Sample Assembly  
![sample_assembly][def30]  

<br>

- Data Forwarding으로 Stall 줄이기
  - Data Bypassing이라고도 불림
  - 우리는 이미 basic idea를 다루었다.
  - Dependent 명령어가 필요로 하는 값을 가능한 즉시 공급해주자.

  - Dataflow를 기억하는가?
    - Dependent 명령어가 필요로 하는 값을 가능한 즉시 공급.
    - 명령어의 모든 operands가 available할 때 명령어를 실행.

  - Data forwarding은 파이프라인을 Data flow execution 모델에 더 가깝게 만든다.  

- Data Forwarding
  - 마치 `RF`를 state로 생각하는 것과 직관적으로 유사하다.
    - `add rx ry rz`는 말 그대로 `RF[ry]`와 `RF[rz]`에서 각각 값을 가져와 결과를 `RF[rx]`에 쓰는 것을 의미한다.  
  - 하지만, `RF`는 단지 communication abstraction의 일부에 불과하다.  
    - `add rx ry rz`의 의미는, 
      - 이전 명령어의 결과를 가져와서, `RF[ry]`와 `RF[rz]`의 값을 각각 정의하고,
      - 다른 명령어가 `RF[rx]`를 재정의하기 전까지 `RF[rx]`를 참조하는 younger instructions가 이 명령어의 결과를 사용하도록 보장하는 것이다.

  - 중요한 것은, operations 간의 "data flow"를 올바르게 유지하는 것이다. 따라서,  
  ![data_forwarding][def31]  

- Forwarding으로 RAW Dependence 해결하기
  - 명령어 `I`<sub>`A`</sub> 와 `I`<sub>`B`</sub> 가 RAW dependence를 가진다고 하자.
    - `I`<sub>`B`</sub> 는 `I`<sub>`A`</sub> 가 레지스터 `R`에 쓴 값을 읽는다.
    - `dist(I`<sub>`A`</sub>`, I`<sub>`B`</sub>`)` ≤ `dist(ID, WB)` = `3`  

  - 다시말해, 만약 `ID`단계에 있는 `I`<sub>`B`</sub> 가 `I`<sub>`A`</sub> 가 `EX`, `MEM`, `WB` 단계에서 레지스터 `R`에 쓴 값을 읽으려고 할 때, `I`<sub>`B`</sub>가 요청한 operand는 아직 **`RF`에 있지 않다.**
    - `RF` 대신 datapath에서 operand를 가져온다.
    - 만약 여러 definition이 outstanding하다면, 가장 최근의 definition에서 값을 가져온다.

- Data Forwarding Paths  
![data_forwarding_paths][def32]  

- Data Forwardiong (Dependence Analysis)  
![data_forwarding_dependence_analysis][def33]  
  - Data-forwarding으로도, `LW` 명령어 바로 앞의 RAW dependence는 stall을 요구한다.

- Sample Assembly, No Forwarding  
![sample_assembly_no_forwarding][def34]  

- Sample Assembly, Revisited  
![sample_assembly_revisited][def35]  

<br>

### 8. Control Dependence Handling (Cont'd)
- Branch Types  
![branch_types][def36]  

- Control Dependences를 어떻게 핸들링할까?
  - Dynamic instructions의 올바른 시퀀스로 파이프라인을 full로 유지하는 것이 중요하다.  

  - 만약 명령어가 control-flow 명령어인 경우 가능한 솔루션
    - 다음 Fetch 주소를 알 때까지 파이프라인을 stall
    - 다음 Fetch 주소를 예측 (Branch Prediction)
    - Delayed branching 사용 (Branch Delay Slots)
    - Do something else (Fine-grained multithreading 등)
    - Control-flow 명령어 제거 (Predicated execution)
    - 가능한 paths를 모두 Fetch (주소를 다 알고 있다면) (Multipath execution)

<br>

- 다음 PC가 Available해질 때까지 파이프라인을 Stall하는게 좋은 아이디어일까?  
![is_it_a_good_idea_to_stall][def37]  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/aabd7ky.png
[def2]: https://i.imgur.com/6dRhKI1.png
[def3]: https://i.imgur.com/Cexic7e.png
[def4]: https://i.imgur.com/jzrsn6q.png
[def5]: https://i.imgur.com/7IsIe66.png
[def6]: https://i.imgur.com/V8ouiq2.png
[def7]: https://i.imgur.com/XcKssg9.png
[def8]: https://i.imgur.com/b3U48Tl.png
[def9]: https://i.imgur.com/JmPkECO.png
[def10]: https://i.imgur.com/VTIpRhr.png
[def11]: https://i.imgur.com/zybYZVs.png
[def12]: https://i.imgur.com/fA84L2E.png
[def13]: https://i.imgur.com/8Nm8ZoM.png
[def14]: https://i.imgur.com/pnRiwo1.png
[def15]: https://i.imgur.com/nCSLhPk.png
[def16]: https://i.imgur.com/nN9b0Ww.png
[def17]: https://i.imgur.com/Lsie6a8.png
[def18]: https://i.imgur.com/nyBttUd.png
[def19]: https://i.imgur.com/NDZEvAQ.png
[def20]: https://i.imgur.com/OSfVTSF.png
[def21]: https://i.imgur.com/ADQnNvN.png
[def22]: https://i.imgur.com/oxPUkb0.png
[def23]: https://i.imgur.com/t1jgy1i.png
[def24]: https://i.imgur.com/6FI20rU.png
[def25]: https://i.imgur.com/DA5BhkY.png
[def26]: https://i.imgur.com/xJZ7ZcZ.png
[def27]: https://i.imgur.com/lLzSqGH.png
[def28]: https://i.imgur.com/sjlNI8U.png
[def29]: https://i.imgur.com/PVeyF5J.png
[def30]: https://i.imgur.com/ZeuSLXy.png
[def31]: https://i.imgur.com/a6JNmw2.png
[def32]: https://i.imgur.com/jqvKqUP.png
[def33]: https://i.imgur.com/frtgJYe.png
[def34]: https://i.imgur.com/ZeuSLXy.png
[def35]: https://i.imgur.com/3TMPADV.png
[def36]: https://i.imgur.com/RBUzbzy.png
[def37]: https://i.imgur.com/tvNBA3v.png