---
layout: post
title: "[컴퓨터구조] 14주차 - MIPS Pipelining"
excerpt: "Advantages of Microprogramming, Update of Machine Behavior, New Attack Surfaces on ISA/uArch/uCode, Basic Idea of Pipelining, An Ideal Pipeline, Pipelined Operation, Pipeline Design"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-12-02
last_modified_at: 2025-12-03
---
## MIPS Microarchitecture
### 1. Advantages of Microprogramming
- The Power of Abstraction
  - Microinstructions의 control store 개념은 하드웨어 디자이너가, **microprogramming**이라는 새로운 추상화를 가능하게 한다.
  - 디자이너는 어떠한 operation이든 microinstructions의 시퀀스로 구현할 수 있다.
  - 모든 디자이너가 제공해야 할 것은,
    - 원하는 operation을 구현하는데 필요한 microinstruction 시퀀스
    - microinstruction을 통해 control logic이 올바르게 sequence되도록 보장하는 것
    - 필요한 어떠한 추가적인 datapath elements와 control signals

- Microprogrammed Control의 장점  
  - TODOs

<br>

### 2. Update of Machine Behavior
- Field에서 차후에 micro code를 update/patch 가능하게 되면, 프로세서 변경 없이 새로운 명령어를 추가할 수 있게 해준다!

- Example
  - TODOs

<br>

### 3. New Attack Surfaces on ISA/uArch/uCode  
- TODO

<br>

## MIPS Pipelining
### 1. Basic Idea of Pipelining
- Can We Do Better?

- Concurrency를 향상시키기 위해 Idle Hardware를 사용할 수 있을까?
  - TODO

- Pipelining: Basic Idea

<br>

- Example: Execution of Four Independent `ADD`
  - Multi-cycle : 명령어 당 `4` cycles  
  ![example_multi_cycle](TODO)  

  - Pipelined : `4`개 명령어 당 `4`cycles (steady state)  
  ![example_pipelined](TODO)  

- The Laundry Analogy  
![laundry_analogy](TODO)  
  - 실제로는 각 단계의 실행 시간이 다르니, 가장 느린 step이 throughput을 결정한다.  
  ![laundry_pipeline_in_practice](TODO)  
  - 그렇다면 가장 느린 단계를 수행하는 하드웨어를 여러 개 두면 개선할 수도 있겠다.  
  ![laundry_pipeline_with_replicas](TODO)  
    - 또는 더 빠른 하드웨어를 사용한다거나...

<br>

### 2. An Ideal Pipeline
- 목표 : 최소한의 Cost 증가로 Throughput을 극대화하는 것 (명령어 처리의 경우, 하드웨어 cost)

- 동일한 operations의 반복
  - 다양한 많은 수의 inputs들에 대해 동일한 operation이 반복된다.  

- 독립적인 operations의 반복
  - 반복되는 operations 간에는 dependencies가 없어야 한다.

- 균등하게 나누어질 수 있는 sub-operations
  - 프로세싱 과정은 균등한 latency의 sub-operations으로 even하게 나누어질 수 있어야 한다.
  - sub-operations 간에는 리소스를 공유하지 않아야 한다.

- Ideal Pipelining  
![ideal_pipelining](TODO)  

<br>

- More Realistic Pipeline: Cost
  - 각 stage는 latch를 필요로 한다. Latch에 저장하는 시간을 `L`이라고 하자.
  - combinational cost `G`의 Nonpipelined version  
  ![nonpipelined_cost](TODO)  
    - `Cost` = `G` + `L`
  - `k`-stage Pipelined version  
  ![pipelined_cost](TODO)  
    - `Cost`<sub>`k-stage`</sub> = `G` + `Lk`  

<br>

### 3. Pipelined Operation
- Dividing Into Stages  
![pipelined_operation_stages](TODO)  
  - 올바른 Partitioning일까? Ideal에 가까워 보이지는 않는다.  

- Instruction Pipeline Throughput  
![instruction_pipeline_throughput](TODO)  

- Enabling Pipelined Processing: Pipeline Registers  
![pipeline_registers](TODO)  

<br>

- Illustrating Pipeline Operation: Operation View  
![pipeline_operation_view](TODO)  

- Illustrating Pipeline Operation: Resource View  
![pipeline_resource_view](TODO)  

<br>

- Control Points in a Pipeline  
![control_points_in_pipeline](TODO)

- Control Signals in a Pipeline
  - 주어진 명령어에 대해,
    - 같은 control signals를 single-cycle처럼, 하지만
    - control signals는 다른 cycles에서 필요로 한다. (각 stage마다 다름)
    - Option 1 : 같은 logic을 single-cycle처럼 사용하여 한번만 decode하고, 소비될 때까지 signals를 buffer한다.  
    ![pipeline_control_signals_option1](TODO)  
    - Option 2 : pipeline을 내려가며 관련있는 "명령어 word/field"를 carry하고, 각 or 이전 stage 내에서 locally decode한다.  

- Pipelined Control Signals  
![pipelined_control_signals](TODO)  

<br>

### 4. Pipeline Design  
- TODO  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>