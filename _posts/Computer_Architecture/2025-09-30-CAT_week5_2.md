---
layout: post
title: "[컴퓨터구조] 5주차 (2) - ISA: Fundamental Concepts"
excerpt: "Computer System Stack, Computer Architecture, ISA vs. Microarchitecture, Design Point, Instruction, Elements of ISA, State, Instruction Classes"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-09-30
last_modified_at: 2025-10-07
---
## ISA: Fundamental Concepts
### 1. Computer System Stack  
![computer_system_stack][def]  
  - Application은 H/W 변화를 Drive
  - Computer Architecture 또한 S/W 변화를 Drive  

- Example: Transaction Memory  
  - Transaction memory operation
    - Atomic한 방식으로 read/write 명령을 수행하기 위한 메모리 집합
    - e.g., concurrent programming, database transactions  

  - Intel TSX(Transactional Synchronization Extensions)
    - 2013년, Intel ISA에 새롭게 추가된 명령어 집합
    - 40% 더 빠른 애플리케이션 실행, 4~5배 더 많은 데이터베이스 트랜잭션 처리(TPS)  
    - 그러나..
      - 버그와 보안 이슈
        - "Breaking Kernel Address Space Layout Randomization with Intel TSX", CCS 2016
      - 2021년에 비활성화

- Example: int8 quantization, ARM, NVIDIA
   - Deep convolution neural networks(CNN)이 오늘날의 많은 분야에서 거대한 성공을 거둠
     - e.g., CV, NLP
    - 매우 expensive한 메모리와 컴퓨팅 costs가 deployment를 매우 지연시킴 (특히 real-time applications에서)
      - e.g., mobiles, IoT, autonomous vehicles, unmanned aerial vehicles (UAVs)  
    - 한 가지 solution -> Quantization
    - NVIDIA TensorRT, IntelCaffe, Tensor Processing Unit, TensorFlow, ARM NEON, ...

<br>

- [Aside] Deep Learning on CPUs
  - Motivation
    - CPU의 높은 Memory Capacity
    - 모바일 시스템에서의 Usefulness
    - Extreme Environments에서의 Usefulness
    - Overspecialization에 대한 Challenge

<br>

### 2. Computer Architecture
- Instruction Set Architecture (ISA)
  - HW와 SW 사이의 인터페이스
  - compatibility 문제 때문에, 변경(수정)이 어려움
  - 칩 제조사 별로 다양한 ISAs
    - x86, ARM, SPARC, etc.

- Microarchitecture
  - ISA를 구현하는 방법
  - **Not visible to the software**  
  - 프로세서의 Organization
  - Examples
    - Depth of pipelines
    - Cache sizes and organizations

<br>

- Mainstream ISAs  
![mainstream_ISAs][def2]  

<br>

- Two Key Principles of Machine Design
  - (1) 명령어는 숫자로 표현되며, 데이터와 구별할 수 없음.
  - (2) 프로그램은 alterable memory(RAM)에 데이터와 동일한 방식으로 저장됨.

- Stored Program Computers  
![stored_program_computers][def3]
  - 명령어는 binary로, 데이터처럼 표현됨
  - 명령어와 데이터는 메모리에 저장됨
  - 프로그램은 프로그램 위에서 동작할 수 있음
    - e.g., compilers, linkers, ...
  - Binary compatibility는 컴파일된 프로그램으로 하여금 서로 다른 컴퓨터에서 동작 가능하도록 함 (Backward compatibility)  
    - Standardized ISAs

- From Program to Process  
![program_to_process][def4]  

<br>

- The Von-Neumann Model/Architecture
  - *stored program computer*의 다른 이름 (instructions in memory)
  - 두 가지 속성
    - Stored program
      - 명령어들은 linear memory array에 저장됨
      - 메모리는 명령어와 데이터 간에 통합됨

    - Sequential instruction processing
      - 한 번에 하나의 명령어가 처리됨 ((fetch, execute, complete) -> 하나의 처리)
      - Program counter는 현재 명령어를 identify
      - Program counter는 control transfer instructions(branch, jump, call, return)을 제외하면 순차적으로 증가됨

  - 모든 오늘날의 major ISAs는 이 모델을 사용 (x86, ARM, MIPS, RISC-V, ...)

  - Underneath(at the microarchitecture level), 대부분의 구현(or microarchitectures)에 대한 execution model은 매우 다르다.  
    - Pipelined instruction execution : Intel 80486 uarch
    - Multiple instructions at a time : Intel Pentium uarch (superscalar)
    - Out-of-order execution : Intel Pentium Pro uarch
    - Seperate instruction and data caches

  - 그러나, Von-Neumann model에 unconsistent한 underneath에서 일어나는 일들은 software에 노출되지 않는다. (Difference between ISA and microarchitecture)  

<br>

### 3. ISA vs. Microarchitecture
- ISA vs. uArch를 비유하자면?
  - Gas pedal : "acceleration" 에 대한 Interface
  - Internals of the engine : Implementation of "acceleration"

- Implementation(uArch)는 specification(ISA)를 만족시키는 한, 다양하게 구현될 수 있음
  - Add instruction vs. Adder implementation
    - Bit serial, ripple carry, carry lookahead adders는 microarchitecture의 일부
  - x86 ISA는 많은 implementations를 가짐: 286, 386, 486, Pentium, Pentium Pro, Pentium 4, Core, ...

- Microarchitecture는 보통 ISA보다 빠르게 변화함
  - ISA는 많지 않지만(x86, ARM, SPARC, RISC-V), uArch는 매우 많음
  - Why? -> Software compatibility  

  <br>

- ISA
  - Instructions
    - Opcodes, Addressing Modes, Data Types
    - Instructions Types and Formats
    - Registers, Condition Codes
  - Memory
    - Address Space, Addressability, Alignment
    - Virtual memory management
  - Call, Interrupt/Exception Handling
  - Access Control, Priority/Privilege
  - I/O: memory-mapped vs. instruction-based
  - Task/Thread management
  - Power and thermal management
  - Multi-threading support, multiprocessor support  

<br>

- Microarchitecture
  - ISA의 구현에 대한 구체적인 디자인 제약(constraints)과 목표(goals)  
  - 소프트웨어에 노출 없이 하드웨어에서 일어나는 모든 일
    - Pipelining
    - In-order vs. out-of-order instruction execution
    - Superscalar processing
    - Speculative execution
    - Clock gating
    - Caching (levels, size, associativity, replacement policy)
    - Prefetching
    - Memory access scheduling policy
    - Voltage / frequency scaling
    - Error correction  

<br>

### 4. Design Point
- 이들의 중요성을 고려하여 어떻게 디자인하는 것이 좋을까?
  - ISA와 uArch에서의 trade-off로 이어진다.

- 고려사항
  - Cost
  - Performance
  - Maximum power consumption
  - Energy consumption (battery life)
  - Availability
  - Reliability & Correctness
  - Time-to-market

- 이렇게 Design point는 상황에 따라 다르다.

<br>

### 5. Instruction
- HW/SW 인터페이스의 기본 요소
- 아래로 구성된다.  
  - opcode : 명령어가 어느 일을 수행하는 지
  - operands : 그 일을 수행하는게 누구인지
  - Alpha ISA의 Example  
  ![alpha_ISA_example](TODO)  

<br>

- Instruction processing style
  - 명령어가 수행할 "operands"의 수와, 어떻게 수행할 지를 정의
  - `0`, `1`, `2`, `3` address machines
    - `0`-address : stack machine (`push A`, `pop A`, `op`)
    - `1`-address : accumulator machine (`load A`, `store A`, `op A`)
    - `2`-address : 2-operand machine (한 operand가 source & destination)
    - `3`-address : 3-operand machine (source와 destination이 분리됨)

  - Tradeoffs?
    - 더 많은 명령어 수 vs. 한 번에 더 많은 연산
    - 코드 크기 vs. 실행 시간 vs. on-chip 메모리 공간 

<br>

- Stack Machine  
![stack_machine_example](TODO)  
  - 장점
    - 적은 명령어 수 (operand가 필요하지 않음)
      - 간단한 로직
      - 컴팩트한 코드
  - 단점
    - "Postfix notation"(연산자가 피연산자 뒤에 위치)로 표현할 수 없는 연산은 stack machine에 매핑하기 어려움
      - 다시말해, 표현의 제약
      - 동시에 여러 값을 연산할 수 없음
      - 유연하지 못함

<br>

- Other examples
  - PDP-11 : A 2-address machine
  - x86 : A 2-address (memory / memory) machine
  - Alpha : A 3-address (load / store) machine
  - MIPS? : 추후 다룸

<br>

### 6. Elements of ISA
- Instructions
  - Opcode
  - Operand specifiers (addressing modes)
    - operand를 어떻게 찾는지

- Data types
  - Integer, floating point, character, binary, decimal
  - Doubly linked list, queue, string, bit vector, stack
    - VAX : `INSQUEUE`, `REMQUEUE` instructions (for doubly linked list)
    - x86 : `SCAS`와 같은 Scan string instructions

- Memory organization
  - Address space : 메모리 내 unique하게 식별가능한 위치의 수
  - Addressability : 메모리에서 주소 하나가 가리키는 데이터의 크기
    - Byte addressable : 대부분의 ISAs
    - Bit addressable : Burroughs B1700
    - 64-bit addressable : Some supercomputers
    - 32-bit addressable : First Alpha
  - 최근에는 virtual memory에 대한 지원도 포함

- Registers
  - 몇 개의 레지스터들이 소프트웨어 계층에 노출되는가?
  - 각 레지스터의 크기는?

- 왜 레지스터를 사용하는가?
  - 프로그램은 data locality라고 불리는 특징을 보이기 때문
  - 최근에 사용된 값은 곧 다시 사용될 가능성이 높음  

<br>

- Load/store vs. memory/memory architecture
  - Load/store architecture : 모든 operate 명령어들이 레지스터들에서만 동작
    - e.g., MIPS, ARM, many RISC ISAs

  - Memory/memory architecture : 모든 operate 명령어들이 메모리에서 직접 동작
    - e.g., x86, VAX, many CISC ISAs

<br>

- Addressing mode는 operands를 어떻게 얻을 지를 정의
  - Absolute : `LW rt, 10000`
    - 즉석값(immediate value)을 주소로 사용
  - Register Indirect : `LW rt, (r_base)`
    - `GPR[r_base]`을 주소로 사용 (GPR : general purpose register)
  - Displaced or based : `LW rt, offset(r_base)`
    - `GPR[r_base] + offset`을 주소로 사용
  - Indexed : `LW rt, (r_base, r_index)`
    - `GPR[r_base] + GPR[r_index]`을 주소로 사용
  - Memory Indirect : `LW rt, ((r_base))`
    - `GPR[r_base]`이 가리키는 메모리 위치의 값을 주소로 사용

<br>

- 서로 다른 Addressing modes가 가지는 이점?
  - programmer vs. microarchitect의 관점에서
  - 더 다양한 addressing modes의 장점
    - 서로 다른 상황에서 상황에 알맞는 접근법으로 명령어의 수와 코드 크기를 줄일 수 있음
      - e.g., 배열 접근, indirect 접근, sparse matrix 접근
  - 단점
    - 컴파일러가 복잡해짐 (어떤 addressing mode를 사용할 지 결정)
    - microarchitect가 복잡해짐

<br>

- I/O 디바이스와 어떻게 상호작용하는가?
  - Memory-mapped I/O
    - 특정 메모리 영역이 특정 I/O 디바이스에 매핑됨
    - Load/store 명령어로 I/O 디바이스와 상호작용
    - Trade-off
      - 장점 : 메모리 명령어를 I/O 디바이스에도 사용 가능
      - 단점 : 각 디바이스마다 전체 address에 대해 fully decoded 필요

  - Special I/O instruction
    - 별도의 IN/OUT 명령어로 I/O 디바이스와 상호작용
    - Trade-off
      - 장점 : Decode를 위한 추가적인 로직이 덜 필요
      - 단점 : 같은 작업을 수행하는데 더 많은 명령어 필요

<br>

- Privilege modes
  - User vs. supervisor
  - 누가 어떤 명령어를 실행할 수 있는가?

- Exception and interrupt handling
  - 명령어를 수행하다가 무언가 잘못되었을 때 어떤 절차를 밟는가?
  - Vectored vs. non-vectored interrupts

- Virtual memory
  - 각 프로그램이 전체 메모리 공간에 대한 illusion을 가지도록 지원

- Access protection

- Virtualization

- 각각에 대해서는 차후 자세하게 다룸

<br>

### 7. State
- State : 값을 저장하는 모든 것

- Programmer visible states  
  - Memory
    - 주소로 인덱싱되는 저장 공간의 배열

  - Registers
    - ISA에서 특수한 이름이 부여된 저장 공간
    - general vs. special purpose

  - Program Counter(PC)
    - special purpose register 중 하나
    - 다음에 실행할 명령어의 주소

- Programmer invisible states
  - Microarchitectural state
  - 프로그래머는 직접 접근 불가
  - e.g., cache state, pipeline register

<br>

### 9. Instruction Classes
- Operate instructions
  - 데이터 처리 : 산술 & 논리 연산
  - Fetch operands, compute result
  - Implicit sequential control flow

- Data movement instructions
  - 메모리, 레지스터, I/O 간의 데이터 이동
  - Implicit sequential control flow

- Control flow instructions
  - 실행되는 명령어의 순서를 변경

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/717j48V.png
[def2]: https://i.imgur.com/TS8eX1V.png
[def3]: https://i.imgur.com/hxdflUg.png
[def4]: https://i.imgur.com/w7NfENw.png