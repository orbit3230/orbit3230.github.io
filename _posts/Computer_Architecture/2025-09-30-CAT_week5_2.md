---
layout: post
title: "[컴퓨터구조] 5주차 (2) - ISA: Fundamental Concepts"
excerpt: "Computer System Stack, Computer Architecture, ISA vs. Microarchitecture"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-09-30
last_modified_at: 2025-10-01
---
## ISA: Fundamental Concepts
### 1. Computer System Stack  
![computer_system_stack][def]  
  - Application은 H/W 변화를 Drive
  - Computer Architecture 또한 S/W 변화를 Drive  

- Example: Transaction Memory  
  - Transaction memory operation
    - Atomic한 방식으로 read/write 명령을 수행하기 위한 메모리 집합
    - e.g., concurrent programming, database transactions  

  - Intel TSX(Transactional Synchronization Extensions)
    - 2013년, Intel ISA에 새롭게 추가된 명령어 집합
    - 40% 더 빠른 애플리케이션 실행, 4~5배 더 많은 데이터베이스 트랜잭션 처리(TPS)  
    - 그러나..
      - 버그와 보안 이슈
        - "Breaking Kernel Address Space Layout Randomization with Intel TSX", CCS 2016
      - 2021년에 비활성화

- Example: int8 quantization, ARM, NVIDIA
   - Deep convolution neural networks(CNN)이 오늘날의 많은 분야에서 거대한 성공을 거둠
     - e.g., CV, NLP
    - 매우 expensive한 메모리와 컴퓨팅 costs가 deployment를 매우 지연시킴 (특히 real-time applications에서)
      - e.g., mobiles, IoT, autonomous vehicles, unmanned aerial vehicles (UAVs)  
    - 한 가지 solution -> Quantization
    - NVIDIA TensorRT, IntelCaffe, Tensor Processing Unit, TensorFlow, ARM NEON, ...

<br>

- [Aside] Deep Learning on CPUs
  - Motivation
    - CPU의 높은 Memory Capacity
    - 모바일 시스템에서의 Usefulness
    - Extreme Environments에서의 Usefulness
    - Overspecialization에 대한 Challenge

<br>

### 2. Computer Architecture
- Instruction Set Architecture (ISA)
  - HW와 SW 사이의 인터페이스
  - compatibility 문제 때문에, 변경(수정)이 어려움
  - 칩 제조사 별로 다양한 ISAs
    - x86, ARM, SPARC, etc.

- Microarchitecture
  - ISA를 구현하는 방법
  - **Not visible to the software**  
  - 프로세서의 Organization
  - Examples
    - Depth of pipelines
    - Cache sizes and organizations

<br>

- Mainstream ISAs  
![mainstream_ISAs][def2]  

<br>

- Two Key Principles of Machine Design
  - (1) 명령어는 숫자로 표현되며, 데이터와 구별할 수 없음.
  - (2) 프로그램은 alterable memory(RAM)에 데이터와 동일한 방식으로 저장됨.

- Stored Program Computers  
![stored_program_computers][def3]
  - 명령어는 binary로, 데이터처럼 표현됨
  - 명령어와 데이터는 메모리에 저장됨
  - 프로그램은 프로그램 위에서 동작할 수 있음
    - e.g., compilers, linkers, ...
  - Binary compatibility는 컴파일된 프로그램으로 하여금 서로 다른 컴퓨터에서 동작 가능하도록 함 (Backward compatibility)  
    - Standardized ISAs

- From Program to Process  
![program_to_process](TODO)  

<br>

- The Von-Neumann Model/Architecture
  - *stored program computer*의 다른 이름 (instructions in memory)
  - 두 가지 속성
    - Stored program
      - 명령어들은 linear memory array에 저장됨
      - 메모리는 명령어와 데이터 간에 통합됨

    - Sequential instruction processing
      - 한 번에 하나의 명령어가 처리됨 ((fetch, execute, complete) -> 하나의 처리)
      - Program counter는 현재 명령어를 identify
      - Program counter는 control transfer instructions(branch, jump, call, return)을 제외하면 순차적으로 증가됨

  - 모든 오늘날의 major ISAs는 이 모델을 사용 (x86, ARM, MIPS, RISC-V, ...)

  - Underneath(at the microarchitecture level), 대부분의 구현(or microarchitectures)에 대한 execution model은 매우 다르다.  
    - Pipelined instruction execution : Intel 80486 uarch
    - Multiple instructions at a time : Intel Pentium uarch
    - Out-of-order execution : Intel Pentium Pro uarch
    - Seperate instruction and data caches

  - 그러나, Von-Neumann model에 unconsistent한 underneath에서 일어나는 일들은 software에 노출되지 않는다. (Difference between ISA and microarchitecture)  

<br>

### 3. ISA vs. Microarchitecture
- ISA vs. uArch를 비유하자면?
  - Gas pedal : "acceleration" 에 대한 Interface
  - Internals of the engine : Implementation of "acceleration"

- Implementation(uArch)는 specification(ISA)를 만족시키는 한, 다양하게 구현될 수 있음
  - Add instruction vs. Adder implementation
    - Bit serial, ripple carry, carry lookahead adders는 microarchitecture의 일부
  - x86 ISA는 많은 implementations를 가짐: 286, 386, 486, Pentium, Pentium Pro, Pentium 4, Core, ...

- Microarchitecture는 보통 ISA보다 빠르게 변화함
  - ISA는 많지 않지만(x86, ARM, SPARC, RISC-V), uArch는 매우 많음
  - Why? -> Software compatibility  

  <br>

- ISA
  - Instructions
    - Opcodes, Addressing Modes, Data Types
    - Instructions Types and Formats
    - Registers, Condition Codes
  - Memory
    - Address Space, Addressability, Alignment
    - Virtual memory management
  - Call, Interrupt/Exception Handling
  - Access Control, Priority/Privilege
  - I/O: memory-mapped vs. instruction-based
  - Task/Thread management
  - Power and thermal management
  - Multi-threading support, multiprocessor support

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/717j48V.png
[def2]: https://i.imgur.com/TS8eX1V.png
[def3]: https://i.imgur.com/hxdflUg.png