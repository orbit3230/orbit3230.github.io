---
layout: post
title: "[컴퓨터구조] 8주차 - ISA: MIPS Case Study"
excerpt: "Data Format, MIPS-32 ISA, MIPS Design Principles, MIPS Instructions, (Review+) Integers, Representing Instructions, Logical Operations, Review+: From Assembly to Machine Code, MIPS Control Flow Instructions, Procedure"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-10-21
last_modified_at: 2025-11-05
---
## ISA: MIPS Case Study
### 1. Data Format
- MIPS-32를 가정
- 대부분은 32 bits
  - 명령어 & 데이터 주소
  - signed & unsigned integers
- 또한 16-bit word & 8-bit (a.k.a., byte)도 지원
- Floating-point numbers
  - IEEE Standard 754
  - Single precision(e.g., `float`): 8-bit exponent(`E`) + 23-bit fraction(`F`, significand)  
    - `(-1)S` x `F` x `2`<sup>`(exponent - bias)`</sup>  
    - Fraction(a.k.a., significand)
  - Double precision(e.g., `double`): 11-bit exponent + 52-bit fraction(significand)

<br>

### 2. MIPS-32 ISA
- 명령어 카테고리  
![instruction_categories][def]  
  - Computational
  - Load/Store
  - Jump/Branch
  - Floating-point
  - Memory Management
  - Special

<br>

- 세 가지 명령어 포맷  
  - R-type, 3 register operands (반드시 레지스터)  
  ![R_type][def2]  
  - I-type, 2 register operands + 16-bit immediate  
  ![I_type][def3]  
  - J-type, 26-bit immediate operand  
  ![J_type][def4]  

- Simple Decoding
  - 명령어 당 4-byte 고정 길이, 형식에 상관없이.
  - 반드시 4-byte 정렬(aligned)
  - 형식과 필드가 readibly extractable(읽기 쉽게 추출 가능)  

<br>

### 3. MIPS Design Principles
- Simiplicity는 **regularity**를 갖추게끔 함 (Simplicity favors Regularity)  
  - 고정 길이 명령어
  - 적은 수의 명령어 포맷
  - Opcode는 항상 첫 6 bits

- **Smaller**는 곧 **faster** (Smaller is faster)  
  - 제한된 명령어 집합
  - 제한된 레지스터 수 (in register file)
  - 제한된 addressing modes 수

- Make the **common case fast**
  - Arithmetic operands를 메모리가 아닌 레지스터에서 가져옴
  - 명령어들로 하여금 immediate operands를 가지도록 허용  

<br>

### 4. MIPS Instructions
- Arithmetic Instructions
  - Add와 Subtract, 3 operands
    - 두 개의 sources와 하나의 destination  

    ```assembly
    add a, b, c  # a = b + c
    sub a, b, c  # a = b - c
    ```

    - 모든 arithmetic 연산은 이러한 형식을 가짐

  - Design Principle 1 : Simplicity favors regularity
    - Regularity는 구현을 간단하게 만들어 줌
    - Simplicity는 더 낮은 비용으로 높은 성능을 가능하게 함

<br>

- MIPS Register Operands
  - Arithmetic instructions는 레지스터 operands만 사용
  - MIPS는 32 x 32-bit register file을 가짐
    - 자주 액세스되는 데이터를 위해 사용
    - 32개의 레지스터는 `$0` ~ `$31`로 명명
    - 32-bit 데이터를 "word"라고 부름  

  - Assembler names
    - 임시 값들에 대해서 `$t0` ~ `$t9` (10개)
    - 저장된 변수들에 대해서 `$s0` ~ `$s7` (8개)  

  - Design Principle 2 : Smaller is faster
    - (cf.) 메인 메모리 : 수십만개의 locations  

  - Example
    - C code  

    ```c
    f = (g + h) - (i + j);
    ```

    - Compiled MIPS code  

    ```assembly
    add     $t0, $s1, $s2
    add     $t1, $s3, $s4
    sub     $s0, $t0, $t1
    ```

<br>

- MIPS Register Convention  

|Name|Register No.|Usage|
|:---|:---:|:---|
|`$zero`|`0`|The constant value `0`|
|`$v0`-`$v1`|`2`-`3`|Values for results & expression evaluation|
|`$a0`-`$a3`|`4`-`7`|Arguments|
|`$t0`-`$t7`|`8`-`15`|Temporaries (can be overwritten by callee)|
|`$s0`-`$s7`|`16`-`23`|Saved (must be saved/restored by callee)|
|`$t8`-`$t9`|`24`-`25`|More temporaries|
|`$gp`|`28`|Global pointer|
|`$sp`|`29`|Stack pointer|
|`$fp`|`30`|Frame pointer|
|`$ra`|`31`|Return address|

<br>

- MIPS Memory Operands
  - Compisite data에 대해서는 메인 메모리 사용  
    - Arrays, Structures, Dynamic data

  - Load/Store Instructions
    - *memory* -> *register*로 값을 Load
    - *register* -> *memory*로 값을 Store

  - 메모리는 Byte addressed
    - 각 주소는 `8`-bit(1 byte)로 식별  

  - Words는 메모리 내에서 aligned
    - 주소는 반드시 `4`의 배수여야 함

  - MIPS는 Big Endian
    - MSB(Most Significant Byte)가 Word의 가장 낮은 주소  

- Aside: Big Endian vs. Little Endian  
![endian_1][def5]  
![endian_2][def6]  

<br>

- MIPS Memory Operand Example (1)  
  - C code  

  ```c
  g = h + A[8];
  ```

  - Compiled MIPS code  

  ```assembly
  lw    $t0, 32($s3)   # load word
  add   $s1, $s2, $t0
  ```

<br>

- Register vs. Memory
  - 레지스터는 메모리보다 액세스가 훨씬 빠르다.
  - 메모리 데이터에 대한 연산은 더 많은 loads/stores를 필요로 한다.
    - 더 많은 명령어가 수행되어야 한다.
  - 컴파일러는 가능한 변수들에 대해 레지스터를 사용해야 한다.
    - 오직 덜 자주 사용되는 변수들에 대해서만 메모리로 내려보냄
    - Register optimization이 중요하다  

<br>

- MIPS Immediate Instructions
  - 명령어 내에서 specified 되는 constant data  
  `addi   $s3, $s3, 4`  

  - Immediate instruction에서 subtract는 없음
    - 대신 negative constant를 사용  
    `addi   $s2, $s2, -1`  

  - Design Principle 3 : Make the common case fast
    - Small constants는 자주 사용됨
    - Immediate operands는 load 명령을 줄여줌  

<br>

- MIPS Constant
  - The constant Zero
    - MIPS register `0`(`$zero`)는 항상 상수 `0`을 가짐
      - overwritten 될 수 없음

    - Common operations에 유용  
      - e.g., move between registers  
      `add   $t2, $s1, $zero`  

<br>

### 5. (Review+) Integers  
- 자세한 내용은 시스템 프로그래밍 포스팅을 참조  
  - [Bits, Bytes, and Integers (1)][def7]
  - [Bits, Bytes, and Integers (2)][def8]
  - [Bits, Bytes, and Integers (3)][def9]
- Unsigned Binary Integers
- 2s-Complement Signed Integers
- Signed Negation
- Integer C Puzzles
- Sign Extension  

<br>

### 6. Representing Instructions
- 명령어들은 binary로 인코딩된다.
  - machine code

- MIPS 명령어
  - 32-bit instruction words로 인코딩된다.
  - 인코딩 opcode 수, 레지스터 수가 적다.
  - Regularity !

- Register numbers
  - `$t0` ~ `$t7`은 `8` ~ `15` 레지스터
  - `$t8` ~ `$t9`은 `24` ~ `25` 레지스터
  - `$s0` ~ `$s7`은 `16` ~ `23` 레지스터

<br>

- Instructions Sets : A Thin Interface
  - Syntax : `ADD t0, t1, t2` (`ADD $8, $9, $10`)  
  - Semantics : `$8 = $9 + $10`  
  ![instruction_semantics][def10]  
    - opcode
      - 명령어의 기본 연산을 지정
      - 유사 명령어들은 동일한 opcode를 가짐
    - rs(register source), rt(register target), rd(register destination)
      - source & distination 레지스터의 숫자 표현
    - shamt(shift amount)
      - shift/rotate 명령어와 함께 사용
    - funct(function)
      - opcode를 공유하는 서로 다른 기능들을 구별
  
- MIPS R-format Instructions Example  
  - Procedure  
  ![r_format_instructions][def11]  

- MIPS R-format Example  
![r_format_example][def12]  

<br>

- MIPS I-format Instructions  
![MIPS_I_format][def13]  
  - Immediate arithmetic & load/store instructions
    - `rt` : destination or source register #
    - 표현 가능한 상수 : `-2`<sup>`15`</sup> ~ `2`<sup>`15`</sup> - `1` (`16` bits)  
    - 주소 : `rs`의 base address + 16-bit offset  

  - Design Principle 4 : Good design demands good compromises  
    - 서로 다른 형식은 디코딩을 어렵게 만드므로, 32-bit 고정 길이 명령어
    - 가능한 형식을 유지

- MIPS I-format Example  
![mips_i_format_example][def14]  

<br>

- Immediate Addressing on MIPS
  - 상수를 불러오는 데 유용하다.
    - `li $7, 12` : 상수 12를 레지스터 `7`에 로드
    - Opcode가 형식을 결정

  - `or`, `and`, `xor`, `add` 명령어들은 상수 형태인 `ori`, `andi`, `xori`, `addi`를 제공한다.  
    - `ori $8, $0, 0x123` : `0x00000123`를 레지스터 `8`에 로드 (zero-extension)  
    - `ori $9, $0, -6` : `0x0000FFFA`를 레지스터 `9`에 로드
    - `addi $10, $0, 0x123` : `0x00000123`를 레지스터 `10`에 로드
    - `addi $11, $0, -6` : `0xFFFF FFFA`를 레지스터 `11`에 로드 (sign-extension)

  - `lui` 명령어는 상위 16 bits를 로드하고, 나머지 16 bits는 `0`으로 설정한다.
    - `lui $8, 0xabcd` : `0xABCD0000`를 레지스터 `8`에 로드
    - `ori $8, $8, 0x123` : ls bits를 설정 (즉, `0xABCD0123`)  

<br>

- MIPS J-format Instructions
  - 오직 unconditional jumps에만 사용된다.  
  - `j dest_addr` : `dest_addr`로 무조건 점프
  - `2`<sup>`26`</sup> 개의 명령어 이상으로는 직접 점프할 수 없다.
  - Branch들은 J-type이 아닌 I-type을 사용한다.  
    - 반드시 비교할 두 개의 레지스터를 지정해야 한다.  
    - e.g., `beq $1, $2, dest` : 만약 `$1 == $2`이면 `dest`로 점프  
    - `16`-bit offset -> 반드시 `2`<sup>`16`</sup> 개의 명령어 이내로 점프  

<br>

### 7. Logical Operations  
- bitwise manipulation을 위한 명령어들  
![logical_operations][def15]  

<br>

- MIPS Shift Operations
  - `shamt` : 얼마나 shift할지 지정
  - Shift left logical
    - shift left 하고 `0`으로 채움
    - `sll`로 `i` bits만큼 shift -> `2`<sup>`i`</sup>만큼 곱함  

  - Shift right logical
    - shift right 하고 `0`으로 채움
    - `srl`로 `i` bits만큼 shift -> `2`<sup>`i`</sup>만큼 나눔 (unsigned)  

  - Intel 64 and IA-32 Architecture Software Developer’s Manual에 따르면...
    - `1 << 32` -> `1 << 0`
    - `1 << 33` -> `1 << 1`
    - `1 << 34` -> `1 << 2`  s
    - Apple M1과 MIPS 도 마찬가지.

<br>

- bitwise manipulation을 위한 명령어들 (cont'd)  
![logical_operations_contd][def16]  
  - 일련의 비트 그룹을 추출/삽입하는 데 유용

<br>

- MIPS AND Operations
  - 특정 bits 마스킹(masking)에 유용
    - 몇몇 bits를 선별하고, 나머지는 `0`으로 설정  
    ![masking_example][def17]  

- MIPS OR Operations
  - 특정 bits 설정에 유용
    - 몇몇 bits를 `1`로 설정 (나머지는 unchanged)  
    ![setting_bits_example][def18]  

- MIPS XOR Operations
  - 만약 bits가 다르면 `1`, 같으면 `0`으로 설정  
  ![xor_example][def19]  

- MIPS NOT Operations
  - bits invert에 유용
    - `0`은 `1`로, `1`은 `0`으로 변경
  - MIPS는 NOR 3-operand instruction을 제공 (단항 연산을 제공하는 Type이 없음)  
    - `a NOR b` == `NOT (a OR b)`  
  ![nor_example][def20]  

<br>

### 8. Review+: From Assembly to Machine Code  
![assembly_to_machine_code][def21]  

<br>

### 9. MIPS Control Flow Instructions
- Conditional Operations
  - 만약 condition이 true이면,labeled instruction으로 Branch
  - 그렇지 않으면, continue sequentially  

  - `if (rs == rt)` branch to `L1`  
  `beq  rs, rt, L1`

  - `if (rs != rt)` branch to `L1`  
  `bne  rs, rt, L1`  

  - unconditional jump to `L1`  
  `J   L1`  

<br>

- `if` statement를 컴파일하면,  
  - C code  
  ![if_statement][def22]  
    - `f`, `g`, `h`, `l`, `j`가 각각 `$s0`, `$s1`, `$s2`, `$s3`, `$s4`에 저장되어 있다고 가정  

  - 컴파일된 MIPS code  
  ![if_statement_mips][def23]  

<br>

- loop statement를 컴파일하면,  
  - C code  
  ![loop_statement][def29]  
    - `i`는 `$s3`에, `k`는 `$s5`dp, `save`의 주소는 `$s6`에 저장되어 있다고 가정
    - `save` 배열의 데이터 타입은 word라고 가정  

  - 컴파일된 MIPS code  
  ![loop_statement_mips][def30]  

<br>

- More conditional operations
  - condition이 true이면 `1`로, 그렇지 않으면 `0`으로 설정
    - `if (rs < rt) rd = 1; else rd = 0;`  
    `slt  rd, rs, rt`  
    - `if (rs < constant) rt = 1; else rt = 0;`  
    `slti rt, rs, constant`  

  - `beq`, `bne`와 조합하여 사용  
  
  ```assembly
  slt  $t0, $s1, $s2   # if ($s1 < $s2)
  bne  $t0, $zero, L1  # goto L1
  ```

<br>

- Signed vs. Unsigned
  - Signed comparison : `slt`, `slti`
  - Unsigned comparison : `sltu`, `sltiu`  
  ![signed_vs_unsigned][def24]  

<br>

- Basic Blocks
  - Basic Block은, 명령어 시퀀스이다.
    - No embedded branches (except at the end)
    - No branch targets (except at the beginning)  

  - 컴파일러는 optimization을 위해 Basic Blocks를 식별한다.
  - advanced 프로세서는 Basic blocks의 실행을 accelerate할 수 있다.  
  ![basic_blocks_example][def25]  

<br>

- Branch Instruction Design
  - `blt`, `bge` 등은 왜 없나?
  - `<`, `>=` 등을 위한 하드웨어는 `=`, `!=`보다 느리다.
    - 더 많은 명령어로 동작하는 branch를 포함하면, 더 느린 clock이 필요하다.
    - 모든 명령어들이 더 느려진다 ! (critical path)  
    ![critical_path][def26]  

  - 그리고 당시에는 `beq`, `bne`가 common case 이기도 했다.

  - 꽤 괜찮은 design compromise !  

  - Example  
  ![branch_instruction_example][def27]  

  <br>

### 10. Procedure
- Procedure 호출
  - (1) 레지스터에 파라미터를 위치
  - (2) 프로시터로 Transfer control
  - (3) 프로시저를 위한 공간 요청
  - (4) 프로시저 연산 수행
  - (5) caller를 위한 결과를 레지스터에 위치
  - (6) 호출 위치로 Return

<br>

- MIPS Register Convention  
![mips_register_convention][def28]  

- Procedure 호출 6 steps
  - (1) Main routine (`caller`)는 프로시저(`callee`)가 액세스할 수 있는 위치에 파라미터를 위치
    - `$a0` ~ `$a3` : 4 argument registers
  
  - (2) `caller`는 `callee`에게 transfer control
    
  - (3) `callee`는 필요한 스토리지 리소스 요청

  - (4) `callee`는 필요한 업무 수행  

  - (5) `callee`는 `caller`가 액세스할 수 있는 결과 값을 위치  
    - `$v0`, `$v1` : result values를 위한 2 value registers

  - (6) `callee`는 `caller`에게 teturn control  
    - `$ra` : 원래 return adress로 돌아오기 위한 1 return address register

<br>

- Procedure call : jump and link  
`jal  ProcedureLabel`  
  - 뒤따라오는 명령어의 주소(즉, return address)를 `$ra`에 저장
  - Target address로 점프

- Procedure return : jump register  
`jr  $ra`  
  - `$ra`를 program counter로 Copy
  - 또한 computed jumps에도 사용 가능 (jump랑 같은 의미라는 뜻)  
    - e.g., for case/switch statements  

<br>

- Leaf Procedure Example  
  - C code

  ```c
  int leaf_example(int g, h, i, j) {
    int f;
    f = (g + h) - (i + j);
    return f;
  }
  ```

  - 아래 가정을 따른다.
    - 인자 `g`, `h`, `i`, `j`는 각각 `$a0`, `$a1`, `$a2`, `$a3`에 저장
    - 반환 값 `f`는 `$s0`에 저장 (그러므로, 스택에 `$s0`를 저장해야 함)  
    - Result는 `$v0`에 저장  

  - 컴파일된 MIPS code  
  ![leaf_procedure_example](TODO)  

  - Stack & `$sp` in Leaf Procedure Example  
  ![stack_sp_leaf_procedure_example](TODO)  

<br>

- Non-leaf Procecures
  - 다른 프로시저를 호출하는 프로시저
  - *nested* call을 위해서, caller는 스택에 아래를 저장할 필요가 있다.
    - 자신의 return address
    - 호출 이후 필요한 인자나 지역 변수들
  - 호출 이후 스택으로부터 복원

  - Example C code  

  ```c
  int fact(int n) {
    if(n < 1) return 1;
    else return n * fact(n-1);
  }
  ```

  - 컴파일된 MIPS code  
  ![non_leaf_procedure_example](TODO)  

<br>

- Local data on the Stack  
![local_data_on_stack](TODO)  
  - 스택은 프로시저에 local인 변수를 저장할 때나, 변수가 레지스터에 맞지 않을 때 사용된다.  
    - e.g., local arrays or structures
  
  - 프로시저의 saved register와 지역 변수를 담고있는 스택의 segment를 procedure frame이라고 부른다. (a.k.a. activation record)  

  - Frame pointer (`$fp`)는 procedure frame의 첫 번째 word를 가리킨다. 즉, 프로시저를 위한 stable "base" register를 제공한다.  
    - `$fp`는 호출 시 `$sp`로 initialize되고, `$sp`는 리턴 시 `$fp`로 복원된다.

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/7Bq65As.png
[def2]: https://i.imgur.com/M83H5l4.png
[def3]: https://i.imgur.com/EmZBMf0.png
[def4]: https://i.imgur.com/5LKv14B.png
[def5]: https://i.imgur.com/4BMQIl1.png
[def6]: https://i.imgur.com/62nX9gU.png
[def7]: https://orbit3230.github.io/2024/09/05/SP_week1_2/
[def8]: https://orbit3230.github.io/2024/09/09/SP_week2/
[def9]: https://orbit3230.github.io/2024/09/19/SP_week3/
[def10]: https://i.imgur.com/hMoQLlv.png
[def11]: https://i.imgur.com/NVcjiU5.png
[def12]: https://i.imgur.com/UizLBWx.png
[def13]: https://i.imgur.com/s4txJz5.png
[def14]: https://i.imgur.com/wGDbhPI.png
[def15]: https://i.imgur.com/Vj27wDk.png
[def16]: https://i.imgur.com/Q0G8jQY.png
[def17]: https://i.imgur.com/e0EsepL.png
[def18]: https://i.imgur.com/gKy3iXT.png
[def19]: https://i.imgur.com/Tj1KqiV.png
[def20]: https://i.imgur.com/mw1ZKWK.png
[def21]: https://i.imgur.com/EbzEIP6.png
[def22]: https://i.imgur.com/1MLTDgd.png
[def23]: https://i.imgur.com/lF9bSP4.png
[def24]: https://i.imgur.com/U9qviKo.png
[def25]: https://i.imgur.com/axAaPcJ.png
[def26]: https://i.imgur.com/S9BzHLU.png
[def27]: https://i.imgur.com/fVGZQWw.png
[def28]: https://i.imgur.com/8BsBIyn.png
[def29]: https://i.imgur.com/YWNkIS7.png
[def30]: https://i.imgur.com/3TgvKA8.png