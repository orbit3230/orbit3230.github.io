---
layout: post
title: "[컴퓨터구조] 8주차 - ISA: MIPS Case Study"
excerpt: ""

tags:
  - [컴퓨터구조]

toc: true

date: 2025-10-21
last_modified_at: 2025-10-21
---
## ISA: MIPS Case Study
### 1. Data Format
- MIPS-32를 가정
- 대부분은 32 bits
  - 명령어 & 데이터 주소
  - signed & unsigned integers
- 또한 16-bit word & 8-bit (a.k.a., byte)도 지원
- Floating-point numbers
  - IEEE Standard 754
  - Single precision(e.g., `float`): 8-bit exponent(`E`) + 23-bit fraction(`F`, significand)  
    - `(-1)S` x `F` x `2`<sup>`(exponent - bias)`</sup>  
    - Fraction(a.k.a., significand)
  - Double precision(e.g., `double`): 11-bit exponent + 52-bit fraction(significand)

<br>

### 2. MIPS-32 ISA
- 명령어 카테고리  
![instruction_categories](TODO)  
  - Computational
  - Load/Store
  - Jump/Branch
  - Floating-point
  - Memory Management
  - Special

<br>

- 세 가지 명령어 포맷  
  - R-type, 3 register operands (반드시 레지스터)  
  ![R_type](TODO)  
  - I-type, 2 register operands + 16-bit immediate  
  ![I_type](TODO)  
  - J-type, 26-bit immediate operand  
  ![J_type](TODO)  

- Simple Decoding
  - 명령어 당 4-byte 고정 길이, 형식에 상관없이.
  - 반드시 4-byte 정렬(aligned)
  - 형식과 필드가 readibly extractable(읽기 쉽게 추출 가능)  

<br>

### 3. MIPS Design Principles
- Simiplicity는 **regularity**를 갖추게끔 함 (Simplicity favors Regularity)  
  - 고정 길이 명령어
  - 적은 수의 명령어 포맷
  - Opcode는 항상 첫 6 bits

- **Smaller**는 곧 **faster** (Smaller is faster)  
  - 제한된 명령어 집합
  - 제한된 레지스터 수 (in register file)
  - 제한된 addressing modes 수

- Make the **common case fast**
  - Arithmetic operands를 메모리가 아닌 레지스터에서 가져옴
  - 명령어들로 하여금 immediate operands를 가지도록 허용  

<br>

### 4. MIPS Instructions
- Arithmetic Instructions
  - Add와 Subtract, 3 operands
    - 두 개의 sources와 하나의 destination  

    ```assembly
    add a, b, c  # a = b + c
    sub a, b, c  # a = b - c
    ```

    - 모든 arithmetic 연산은 이러한 형식을 가짐

  - Design Principle 1 : Simplicity favors regularity
    - Regularity는 구현을 간단하게 만들어 줌
    - Simplicity는 더 낮은 비용으로 높은 성능을 가능하게 함

<br>

- MIPS Register Operands
  - Arithmetic instructions는 레지스터 operands만 사용
  - MIPS는 32 x 32-bit register file을 가짐
    - 자주 액세스되는 데이터를 위해 사용
    - 32개의 레지스터는 `$0` ~ `$31`로 명명
    - 32-bit 데이터를 "word"라고 부름  

  - Assembler names
    - 임시 값들에 대해서 `$t0` ~ `$t9` (10개)
    - 저장된 변수들에 대해서 `$s0` ~ `$s7` (8개)  

  - Design Principle 2 : Smaller is faster
    - (cf.) 메인 메모리 : 수십만개의 locations  

  - Example
    - C code  

    ```c
    f = (g + h) - (i + j);
    ```

    - Compiled MIPS code  

    ```assembly
    add     $t0, $s1, $s2
    add     $t1, $s3, $s4
    sub     $s0, $t0, $t1
    ```

<br>

- MIPS Register Convention  

|Name|Register No.|Usage|
|:---|:---:|:---|
|`$zero`|`0`|The constant value `0`|
|`$v0`-`$v1`|`2`-`3`|Values for results & expression evaluation|
|`$a0`-`$a3`|`4`-`7`|Arguments|
|`$t0`-`$t7`|`8`-`15`|Temporaries (can be overwritten by callee)|
|`$s0`-`$s7`|`16`-`23`|Saved (must be saved/restored by callee)|
|`$t8`-`$t9`|`24`-`25`|More temporaries|
|`$gp`|`28`|Global pointer|
|`$sp`|`29`|Stack pointer|
|`$fp`|`30`|Frame pointer|
|`$ra`|`31`|Return address|

<br>

- MIPS Memory Operands
  - Compisite data에 대해서는 메인 메모리 사용  
    - Arrays, Structures, Dynamic data

  - Load/Store Instructions
    - *memory* -> *register*로 값을 Load
    - *register* -> *memory*로 값을 Store

  - 메모리는 Byte addressed
    - 각 주소는 `8`-bit(1 byte)로 식별  

  - Words는 메모리 내에서 aligned
    - 주소는 반드시 `4`의 배수여야 함

  - MIPS는 Big Endian
    - MSB(Most Significant Byte)가 Word의 가장 낮은 주소  

- Aside: Big Endian vs. Little Endian  
![endian_1](TODO)  
![endian_2](TODO)  

<br>

- MIPS Memory Operand Example (1)  
  - C code  

  ```c
  g = h + A[8];
  ```

  - Compiled MIPS code  

  ```assembly
  lw    $t0, 32($s3)   # load word
  add   $s1, $s2, $t0
  ```

<br>

- Register vs. Memory
  - 레지스터는 메모리보다 액세스가 훨씬 빠르다.
  - 메모리 데이터에 대한 연산은 더 많은 loads/stores를 필요로 한다.
    - 더 많은 명령어가 수행되어야 한다.
  - 컴파일러는 가능한 변수들에 대해 레지스터를 사용해야 한다.
    - 오직 덜 자주 사용되는 변수들에 대해서만 메모리로 내려보냄
    - Register optimization이 중요하다  

<br>

- MIPS Immediate Instructions
  - 명령어 내에서 specified 되는 constant data  
  `addi   $s3, $s3, 4`  

  - Immediate instruction에서 subtract는 없음
    - 대신 negative constant를 사용  
    `addi   $s2, $s2, -1`  

  - Design Principle 3 : Make the common case fast
    - Small constants는 자주 사용됨
    - Immediate operands는 load 명령을 줄여줌  

<br>

- MIPS Constant
  - The constant Zero
    - MIPS register `0`(`$zero`)는 항상 상수 `0`을 가짐
      - overwritten 될 수 없음

    - Common operations에 유용  
      - e.g., move between registers  
      `add   $t2, $s1, $zero`  

<br>

### 5. (Review+) Integers  
- 자세한 내용은 시스템 프로그래밍 포스팅을 참조  
  - [Bits, Bytes, and Integers (1)](https://orbit3230.github.io/2024/09/05/SP_week1_2/)
  - [Bits, Bytes, and Integers (2)](https://orbit3230.github.io/2024/09/09/SP_week2/)
  - [Bits, Bytes, and Integers (3)](https://orbit3230.github.io/2024/09/19/SP_week3/)
- Unsigned Binary Integers
- 2s-Complement Signed Integers
- Signed Negation
- Integer C Puzzles
- Sign Extension  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>