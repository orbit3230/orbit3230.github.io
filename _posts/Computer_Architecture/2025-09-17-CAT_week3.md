---
layout: post
title: "[컴퓨터구조] 3주차 - Performance II"
excerpt: "Execution Time, Timer, Performance Counters"

tags:
  - [컴퓨터구조]

toc: true

date: 2025-09-17
last_modified_at: 2025-09-23
---
## Performances
### 1. (Review+) Execution Time
- 세 가지 서로 다른 종류의 시간
  - Elapsed time (a.k.a. wall-clock time)
    - 실제 시간에 기반 (계속적으로 흐름)
    - 모든 다른 활동에서의 시간을 포함

  - CPU time (a.k.a. virtual process time)
    - 프로세스가 실행된 시간 (CPU가 활성화 된)
      - user time + system time
    - 프로세스가 기다린 시간은 포함하지 않음

  - Parallel execution time
    - 멀티-코어 & 멀티 쓰레드 실행 환경
    - 병렬 바트가 실행될 때마다 동작
    - global time bases를 정의할 필요가 있음
    - 차후 다룰 예정  

<br>

- 특정 프로그램 or Task에 대한 execution time을 어떻게 측정할 수 있을까?  

<br>

### 2. Timer  
- `gettimeofday()`
  - UNIX 함수
  - 초/마이크로초 단위로 wall-clock time 반환
  - 실제 resolution(정확도)는 Hardware-dependent
  - Base : 1970년 1월 1일 00:00:00 UTC  

- `clock_gettime()`
  - POSIX 함수
  - `clock_id CLOCK_REALTIME` : 초/나노초 단위로 wall-clock time 반환
  - 더 많은 시간들이 구현되어 있지만 표준화 X
  - 실제 resolution(정확도)는 Hardware-dependent  

- `getusage()`  
  - UNIX 함수
  - 다양한 정보를 제공
    - user time, system time, memory usage, page faults, etc.
    - 제공되는 정보는 system-dependent  

- TSC (Time Stamp Counter)
  - H/W counter
  - clock cycle (or tick)을 카운트
  - `x86` 에서 `RDTSC` 명령어 (`EDX:EAX` 레지스터에 결과 저장)  
  ![RDTSC][def]  

  <br>

- Typical Usage
  - (1) Measurement start
  - (2) 측정하고자 하는 코드 실행
  - (3) Measurement end  
  - (4) (3) - (1) = Elapsed time  

- Example  
![Timer Example][def2]  

<br>

### 3. Performance Counters
- 특정 성능 이벤트를 카운트하기 위해 추가된 프로세서 로직  
  - Performance events : instructions, cycles, cache misses, cache hits, ...
  - 강점
    - Non-intrusive (프로그램 변경 X)
    - Very accurate (하드웨어 기반)
    - Low overhead
  - 약점
    - 오직 hard counts(raw values)만 제공
    - 프로세서나 제조사에 specific
    - end user에게 액세스가 어렵고, 잘 문서화 되어 있지 않음
    - 무엇이 측정되는 지에 대한 기준이 없음  

- Hardware Counter Issues
  - Kernel level
    - Handling of overflows
    - Thread accumulation (한 프로세스에 여러 쓰레드가 있을 때)
    - Thread migration
    - State inheritance
    - Multiplexing (동시에 여러 이벤트를 측정하고 싶을 때)
    - Overhead
    - Atomicity
  - Multi-platform interfaces
    - Performance API (PAPI)
    - LIKWID
  - Tools (Linux)
    - Perf tool (`$(KBUILD_SRC)/tools/perf`)  

<br>

- 일반적으로 특정되는 이벤트들은 다음을 포함
  - Functional units status
    - float point operations
    - fixed point operations
    - load/stores
  - Access to memory hierarchy (L1, L2, L3, DRAM)
  - Cache coherence protocol events (cache들 사이의 일관성 유지 관련 이벤트)  
  - Cycles and instructions counts (CPI-Cycles Per Instruction, IPC-Instructions Per Cycle)  
  - Speculative execution information
    - instructions dispatched
    - Branches mispredicted  

- Hardware Metrics

|Typical hardware counter|Useful derived metrics|  
|---|---|  
|Cycles/Instructions|IPC, CPI|  
|Floating point instructions|FLOPS|  
|Integer instructions|computation intensity|  
|Load/stores|instructions per load/store|  
|Cache misses, hits|cache miss rate|  
|Cache misses|MPKI (misses per kilo instructions) ★|  
|TLB misses, hits|TLB miss rate|  

- Hardware Events를 카운트 하는데 사용되는 Tools
  - CrayPat (Cray)
  - hpmcount (IBM)
  - pfmon from HP
  - cputrack, har (Sun)
  - perfex, ssrun (SGI)
  - **perf (Linux)**

- Perf subsystem  
![Perf subsystem][def3]  
  - PMCs 부분이 H/W, 나머지는 S/W  

- Hardware Counters Access on Linux
  - Performance Counter subsystem은 특수 performance counter hardware registers에 대한 추상화를 제공한다.  
  - perf
    - Linux를 위한 성능 분석 도구
    - `perf stat -e` 명령어로 executable을 실행
    - `-e` flag 다음에 오는 이벤트들을 카운트
    - `perf list` 명령어로 사전 정의된 이벤트들의 리스트를 볼 수 있음  
    ![perf_list][def4]  

    <br>

- SPEC2006(MCF) Example
  - `$ perf stat -e instructions,cpu-cycles,LLC-loads,LLC-load-misses,LLC-store-misses,LLC-stores runspec --iteration 1 --size ref --action run --config=linux64-amd64-gcc42.cfg --noreportable mcf`  
  ![spec2006_mcf_perf][def5]  

<br>

- Using Raw Event in Perf Tool
  - 프로세서 제조사는 해당 프로세서 모델에 대한 technical document(a.k.a. datasheet)를 제공한다. 이는 Performance Monitoring Unit(PMU)를 포함한 구현 디테일들을 담고 있다.  
    - Performance counters
    - Performance events
    - E.g., Intel 64 and IA-32 Architectures Software Developer's Manual Volume 3B: System Programming Guide  

  - `perf list`의 출력에 리스트되어 있지 않은 다양한 performance events에 대한 지원들이 존재한다.  

  - Datasheet example  
  ![intel_perf_event_doc_1][def6]  
  ![intel_perf_event_doc_2][def7]  

  - Event masking : `rUUEE`, `UU`는 umask, `EE`는 event number  
    - example - mcf (SPEC CPU 2006)  
    `$ perf state -e instructions,cpu-cycles,`**`r4f2e, r412e`**`runspec --iteration 1 --size ref --action run --config=linux64-amd64-gcc42.cfg --noreportable mcf`  
    ![intel_perf_event_doc_3][def8]  
    - example - hmmer (SPEC CPU 2006)  
    `$ perf state -e instructions,cpu-cycles,`**`r4f2e, r412e`**`runspec --iteration 1 --size ref --action run --config=linux64-amd64-gcc42.cfg --noreportable hmmer`  
    ![intel_perf_event_doc_4][def9]  

    <br>

- Perf.Counter의 Accuracy Issues
  - 측정된 코드의 기본 단위
    - 충분히 큰 값이 아니라면, counter interfaces의 overhead가 측정된 값에 과도하게 영향을 미칠 수 있음  
    ![perf_overhead_example_ls][def10]  

  - Accuracy issues
    - 종종 speculation이 포함된다.  
    - 무엇이 측정되는지에 대한 기준이 없다.  

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">  

이 포스팅은 강원대학교 송원준 교수님의 컴퓨터구조 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.  

</div>
</details>

[def]: https://i.imgur.com/WPXBPnS.png
[def2]: https://i.imgur.com/OOlxVC6.png
[def3]: https://i.imgur.com/OaxzPgU.png
[def4]: https://i.imgur.com/fHAkOxr.png
[def5]: https://i.imgur.com/DbAr1Fu.png
[def6]: https://i.imgur.com/29qzhdT.png
[def7]: https://i.imgur.com/bwhMP1a.png
[def8]: https://i.imgur.com/Hg1QoLd.png
[def9]: https://i.imgur.com/IUjWF6J.png
[def10]: https://i.imgur.com/d5g29Dj.png