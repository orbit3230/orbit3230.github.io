---
layout: post
title: "[고급 파이썬 프로그래밍] 2주차 - 변수와 자료형, 화면 입출력과 리스트"
excerpt: "변수와 메모리, 변수 선언, 기본 자료형, "

tags:
  - [파이썬 프로그래밍, python]

toc: true

date: 2024-03-12
last_modified_at: 2024-03-12
---
## 변수와 자료형
### 1. 변수와 메모리
- 변수는 어떠한 값을 저장하는 장소이다.  

  - 값은 메모리에 저장된다.  

  - 변수에 값을 넣으려고 선언하는 순간  
  OS와 python interpreter가 메모리 저장 위치를 할당해준다.  

    - 이 위치를 **메모리 주소** 라고 한다.  

  - 변수를 메모리에 저장할 때,  
  해당 메모리 주소에서 해당 변수의 크기만큼 공간을 할당 받는다.  

    - 이 때, 메모리 공간을 확보하는 행위는 ***실행 시점*** 에서 발생한다.  
    왜냐면 파이썬은 변수를 선언할 때 따로 타입을 지정 선언하지 않기 때문에,  
    해당 변수의 자료형을 프로그래머가 아닌 **interpreter**가 판단한다.  
    이렇게 실행 시점에 동적으로 자료형을 판단하는 방식을 ***동적 타이핑(dynamic typing)*** 이라고 한다.  
    파이썬은 *매우 유연한* 언어이다.

    - 이진수 한 자리를 비트(bit)라고 하며,  
    8bit는 1바이트(byte),  
    1,024byte는 1킬로바이트(kilobyte, KB),  


  - 이렇게 컴퓨터에서는 값이 CPU로 가기 전에 메모리 공간에 저장되고,  
  이 값을 CPU가 하나씩 처리한다.  

    - 이 구조를 현대 컴퓨터의 기본 구조인  
    *폰 노이만 아키텍처* 라고 한다.  

    - 

    <br>

### 2. 변수 선언  
- 변수 명에는 다음과 같은 rule이 존재한다.  
  - (1) 알파벳, 숫자, 밑줄(`_`)로 구성한다.  
  - (2) 의미 있는 단어로 표기하는 것이 좋다.  
  - (3) 대/소문자가 구분된다.
  - (4) 이미 기존에 특별한 의미가 존재하는 **예약어**는 변수명으로 사용할 수 없다.  

  <br>

### 3. 기본 자료형
- 파이썬은 크게 네 가지의 기본 자료형을 가진다.  
  - 정수형(integer type)
  - 실수형(floating-point type)
  - 문자형(string type)
  - 불린형(boolean type)

<br>

- 타입 변환 함수들
  - (1) 정수형 -> 실수형 : `float()`
  - (2) 실수형 -> 정수형 : `int()`
  - (3) 정수/실수형 -> 문자열형 : `str()`

- 명시적으로 형변환 하지 않아도 자연스럽게 형변환이 되는 경우도 존재한다.  

```python
# e.g.,
10 / 3       # 3.333333
1 == True    # True
" " == True  # False
```

<br>

- 타입을 확인하는 함수 : `type(변수)`

<br>

### 4. 연산자
- 파이썬도 다른 언어들과 마찬가지로 동일한 연산자들(산술, 증감, 논리 등)이 존재하는데,  

  - 특이하게도 파이썬에서만 존재하는 산술연산자가 두 개 존재한다.  

    - (1) `**` : 제곱 연산자
    - (2) `//` : 몫 연산자  

    <br>

## 화면 입출력과 리스트
### 1. 화면 입출력
- 표준 입력 함수 : `input()`
- 표준 출력 함수 : `print()`

<br>

### 2. 리스트
- 리스트(list) : 하나의 변수에 여러 값을 할당하는 자료형.  

  - 파이썬에서는 리스트처럼 여러 데이터를 하나의 변수에 할당하는 기법을  
  *시퀀스 자료형* 이라고 부르기도 한다.  

- 파이썬의 리스트는 특이하게도, 서로 다른 자료형의 값들을 담을 수가 있다.  
(like `C`의 구조체(`struct`))  

  - 심지어는 원소로서 리스트도 혼합하여 넣을 수 있다.  
  `[["red", "blue", "yellow"], 1, 2, 3]`

<br>

- 리스트의 선언은 다음과 같이 한다.  

```python
list = ["seoul", "korea", "yonsei"]
```

<br>

### 3. 리스트 인덱싱
- 인덱싱(indexing) : 리스트 값에 접근하는 방법으로서, 상대적인 주소를 이용하는 것을 말한다.  

```python
list = ["ronaldo", "messi", "salah"]
list[0]  # "ronaldo"
list[1]  # "messi"
list[2]  # "salah"
```

- 인덱스는 `0`부터 시작한다.  

<br>

### 4. 리스트 슬라이싱
- 슬라이싱(slicing) : 리스트 인덱스를 사용하여, 리스트의 일부 범위를 잘라내 반환하는 것을 말한다.  

```python
list = ["ronaldo", "messi", "salah", "son", "mbappe", "haaland", "nunez"]
list[0:5] # "ronaldo", "messi", "salah", "son", "mbappe"
list[5:]  # "haaland", "nunez"
```

- 파이썬의 리스트에는 리버스 인덱스 기능 또한 존재한다.  

  - 가장 마지막 원소는 `-1`의 인덱스를 가지고,  
  앞으로 갈 수록 더 작은 인덱스를 가진다. (-2, -3, -4, ...)  

```python
list[-4]  # "son"
list[-3:] # "mbappe", "haaland", "nunez"
```

- 파이썬의 리스트 슬라이싱에서는 범위를 넘어가더라도 괜찮다.  
범위를 넘어설 경우, 자동으로 최대 범위를 지정한다.  

```python
list[:]  # "ronaldo", "messi", "salah", "son", "mbappe", "haaland", "nunez"
list[-50:50]  # "ronaldo", "messi", "salah", "son", "mbappe", "haaland", "nunez"
```

- 파이썬의 리스트 슬라이싱에서는 증가값을 넣을 수도 있다.  

```python

```

### 5. 리스트의 연산
- 덧셈 연산

- 곱셈 연산

- `in` 연산

<br>

### 6. 리스트의 추가 및 삭제
- `append()` 함수

- `extend()` 함수

- `insert()` 함수

- `remove()` 함수

- 인덱스의 재할당

- 인덱스 삭제 - `del` 함수

<br>

### 7. 패킹/언패킹
- 패킹(packing) : 한 변수에 여러 개의 데이터를 할당하는 것  
(리스트를 만드는 행위)

- **언패킹**(unpacking) : 한 변수의 데이터를 각각의 변수로 반환하는 것  

```python
list = [1, 2, 3]  # 패킹
a, b, c = list    # 언패킹
print(t, a, b, c) # [1, 2, 3] 1 2 3
```

- 단, ~~

<br>

### 8. 이차원 리스트
- 리스트들의 리스트이다.  
여러 개의 리스트를 하나의 변수에 할당하는 것.  

```python
first_floor = [101, 102, 103, 104, 105]
second_floor = [201, 202, 203, 204, 205]
third_floor = [301, 302, 303, 304, 305]
apartment = [first_floor, second_floor, third_floor]
# [[101, 102, 103, 104, 105],
#  [201, 202, 203, 204, 205],
#  [301, 302, 303, 304, 305]]
```

<br>

### 9. 리스트의 메모리 저장
- 바로 위 코드의 리스트 원소 값을 변경해보자.  

```python
second_floor[0] = 1000
apartment
# [[101, 102, 103, 104, 105],
#  [1000, 202, 203, 204, 205],
#  [301, 302, 303, 304, 305]]
```

- `second_floor` 리스트의 원소 내용을 변경하였을 뿐인데,  
이를 담고있는 `apartment` 리스트의 내용도 변경되었다.  

  - 이는 파이선에서 리스트를 저장할 때,  
  값 자체가 아니라 값이 위치한 메모리 주소(reference)를 저장하기 때문이다.  
  리스트는 값을 연속적으로 저장하는 것이 아니라,  
  값이 있는 주소를 저장(참조)한다.

<br>

- `==`는 값을 비교하는 연산자이고,  
`is`는 메모리 주소를 비교하는 연산자이다.  

```python
a = 300
b = 300
a is b  # False
a == b  # True
```

- 그런데 신기하게도, 아래 코드는 모두 True를 반환한다.  

  - 파이썬의 interpreter를 구동할 때, `-5` ~ `256` 까지의 흔히 쓰이는 정수값은  
  특정 메모리에 이미 저장해놓고 시작하기 때문이다.  
  따라서 해당 값(숫자)를 할당할 때에는 새로운 주소가 아니라,  
  그 숫자가 가진 이미 정의된 메모리 주소로 연결해준다.  

```python
a = 1
b = 1
a is b  # True
a == b  # True
```

<br>

- `=` 대입 연산자로 리스트를 할당하면, 참조를 전달한다.  
다시말해, 리스트에 대한 참조를 공유하게 되는 것이다.  

```python
a = [5, 4, 3, 2 ,1]
b = [1, 2, 3, 4, 5]
b = a
print(b)  # [5, 4, 3, 2, 1]

a.sort()
printf(b) # [1, 2, 3, 4, 5]
```

- 만약 `b`에게 새로운 리스트를 대입하면,  
이제서야 `b`는 `a`가 가리키는 리스트를 참조하는게 아닌  
`b`만이 가리키는 새로운 리스트를 참조하게 된다.  

```python
b = [6, 7 ,8, 9, 10]
print(a, b)
# [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]
```