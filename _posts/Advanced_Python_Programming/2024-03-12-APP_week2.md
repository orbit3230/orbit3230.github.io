---
layout: post
title: "[고급 파이썬 프로그래밍] 2주차 - 변수와 자료형, 화면 입출력과 리스트"
excerpt: "변수와 메모리, 변수 선언, 기본 자료형, 리스트, 리스트의 연산, 리스트의 특징, 패킹/언패킹, etc."

tags:
  - [파이썬 프로그래밍, python]

toc: true

date: 2024-03-12
last_modified_at: 2024-03-12
---
## 변수와 자료형
### 1. 변수와 메모리
- 변수는 어떠한 값을 저장하는 장소이다.  

  - 값은 메모리에 저장된다.  

  - 변수에 값을 넣으려고 선언하는 순간  
  OS와 python interpreter가 메모리 저장 위치를 할당해준다.  

    - 이 위치를 **메모리 주소** 라고 한다.  

  - 변수를 메모리에 저장할 때,  
  해당 메모리 주소에서 해당 변수의 크기만큼 공간을 할당 받는다.  

    - 이 때, 메모리 공간을 확보하는 행위는 ***실행 시점*** 에서 발생한다.  
    왜냐면 파이썬은 변수를 선언할 때 따로 타입을 지정 선언하지 않기 때문에,  
    해당 변수의 자료형을 프로그래머가 아닌 **interpreter**가 판단한다.  
    이렇게 실행 시점에 동적으로 자료형을 판단하는 방식을 ***동적 타이핑(dynamic typing)*** 이라고 한다.  
    파이썬은 *매우 유연한* 언어이다.

    - 이진수 한 자리를 비트(bit)라고 하며,  
    8bit는 1바이트(byte),  
    1,024byte는 1킬로바이트(kilobyte, KB),  
    1,024KB 는 1메가바이트(megabyte, MB),  
    1,024MB 는 1기가바이트(gigabyte, GB)
    ...
    이다.  
    이러한 개념을 **메모리 공간** 이라고 한다.


  - 이렇게 컴퓨터에서는 값이 CPU로 가기 전에 메모리 공간에 저장되고,  
  이 값을 CPU가 하나씩 처리한다.  

    - 이 구조를 현대 컴퓨터의 기본 구조인  
    *폰 노이만 아키텍처* 라고 한다.  

    <br>

### 2. 변수 선언  
- 파이썬에서는 변수의 타입을 선언하지 않는다.  
변수의 타입은 interpreter가 동적으로 지정한다.  

```python
a = 10
int b = 20  # Type Annotation
```

- 물론 타입을 선언해도 되는데,  
그런 방식을 Type Annotation 또는 Type hint 라고 부른다.

- 변수 명에는 다음과 같은 rule이 존재한다.  
  - (1) 알파벳, 숫자, 밑줄(`_`)로 구성한다.  
  - (2) 의미 있는 단어로 표기하는 것이 좋다.  
  - (3) 대/소문자가 구분된다.
  - (4) 이미 기존에 특별한 의미가 존재하는 **예약어**는 변수명으로 사용할 수 없다.  

  <br>

### 3. 기본 자료형
- 파이썬은 크게 네 가지의 기본 자료형을 가진다.  
  - 정수형(integer type)
  - 실수형(floating-point type)
  - 문자형(string type)
  - 불린형(boolean type)

<br>

- 타입 변환 함수들
  - (1) 정수형 -> 실수형 : `float()`
  - (2) 실수형 -> 정수형 : `int()`
  - (3) 정수/실수형 -> 문자열형 : `str()`

- 명시적으로 형변환 하지 않아도 자연스럽게 형변환이 되는 경우도 존재한다.  

```python
# e.g.,
10 / 3       # 3.333333
1 == True    # True
" " == True  # False
```

<br>

- 타입을 확인하는 함수 : `type(변수)`

<br>

### 4. 연산자
- 파이썬도 다른 언어들과 마찬가지로 동일한 연산자들(산술, 증감, 논리 등)이 존재하는데,  

  - 특이하게도 파이썬에서만 존재하는 산술연산자가 두 개 존재한다.  

    - (1) `**` : 제곱 연산자
    - (2) `//` : 몫 연산자  

    <br>

## 화면 입출력과 리스트
### 1. 화면 입출력
- 표준 입력 함수 : `input()`
- 표준 출력 함수 : `print()`

<br>

### 2. 리스트
- 리스트(list) : 하나의 변수에 여러 값을 할당하는 자료형.  

  - 파이썬에서는 리스트처럼 여러 데이터를 하나의 변수에 할당하는 기법을  
  *시퀀스 자료형* 이라고 부르기도 한다.  

- 파이썬의 리스트는 특이하게도, 서로 다른 자료형의 값들을 담을 수가 있다.  
(like `C`의 구조체(`struct`))  

  - 심지어는 원소로서 리스트도 혼합하여 넣을 수 있다.  
  `[["red", "blue", "yellow"], 1, 2, 3]`

<br>

- 리스트의 선언은 다음과 같이 한다.  

```python
list = ["seoul", "korea", "yonsei"]
```

<br>

### 3. 리스트 인덱싱
- 인덱싱(indexing) : 리스트 값에 접근하는 방법으로서, 상대적인 주소를 이용하는 것을 말한다.  

```python
list = ["ronaldo", "messi", "salah"]
list[0]  # "ronaldo"
list[1]  # "messi"
list[2]  # "salah"
```

- 인덱스는 `0`부터 시작한다.  

<br>

### 4. 리스트 슬라이싱
- 슬라이싱(slicing) : 리스트 인덱스를 사용하여, 리스트의 일부 범위를 잘라내 반환하는 것을 말한다.  

```python
list = ["ronaldo", "messi", "salah", "son", "mbappe", "haaland", "nunez"]
list[0:5] # "ronaldo", "messi", "salah", "son", "mbappe"
list[5:]  # "haaland", "nunez"
```

- 파이썬의 리스트에는 리버스 인덱스 기능 또한 존재한다.  

  - 가장 마지막 원소는 `-1`의 인덱스를 가지고,  
  앞으로 갈 수록 더 작은 인덱스를 가진다. (`-2`, `-3`, `-4`, ...)  

```python
list[-4]  # "son"
list[-3:] # "mbappe", "haaland", "nunez"
```

- 파이썬의 리스트 슬라이싱에서는 범위를 넘어가더라도 괜찮다.  
범위를 넘어설 경우, 자동으로 최대 범위를 지정한다.  

```python
list[:]  # "ronaldo", "messi", "salah", "son", "mbappe", "haaland", "nunez"
list[-50:50]  # "ronaldo", "messi", "salah", "son", "mbappe", "haaland", "nunez"
```

- 파이썬의 리스트 슬라이싱에서는 증가값을 넣을 수도 있다.  

```python
list[::2]  # "ronaldo", "salah", "mbappe", "nunez"
list[::-1] # "nunez", "haaland", "mbappe", "son", "salah", "messi", "ronaldo"
```

### 5. 리스트의 연산
- 덧셈 연산
  - 파이썬에서는 리스트 간 덧셈 연산이 가능하다.  
  - 결과 값으로서 두 리스트 내 원소들이 모두 들어있는 **새로운** 리스트를 뱉어낸다.  
    - 따라서 어딘가 변수 따위에 이 결과 값을 할당해주지 않으면 저장되지 않고,  
    기존 변수는 변화가 없다.  

- 곱셈 연산
  - 파이썬에서는 리스트 간 곱셈 연산도 가능하다.  
  - 결과 값은 기준 리스트를 `n`배 만큼 늘린 **새로운** 리스트이다.
    - 따라서 똑같이, 기존 리스트는 변화가 없다.  

- `in` 연산
  - 특정 원소의 포함 여부를 확인하는 연산이다.  
  해당 값이 리스트에 들어있는지(`True`), 아닌지(`False`)를 확인할 수 있다.  

  ```python
  "salah" in list  # True
  "gakpo" in list  # False
  ```

<br>

### 6. 리스트의 추가 및 삭제
- `append()` 함수 : 새로운 값을 기존 리스트의 맨 끝에 추가

```python
list.append("kane")
```

- `extend()` 함수 : 새로운 리스트를 기존 리스트에 추가

```python
list.extend(["saka", "mudryk"])
```

- `insert()` 함수 : 기존 리스트의 `i` 번째 인덱스에 새로운 값을 삽입

```python
list.insert(1, "Rashford")
```

- `remove()` 함수 : 리스트 내의 특정 값을 삭제

```python
list.remove("haaland")
```

- 인덱스의 재할당 : 인덱스에 새로운 값을 할당

```python
list[1] = "neymar"
```

- 인덱스 삭제 : `del` 함수

```python
del list[1]
```

- 리스트 정렬 : `sort()` 함수

```python
list = [1, 5, 3, 4, 2]
list.sort()  # [1, 2, 3, 4, 5]
```

<sub> 지금은 생략되었지만, `sort()` 함수의 인자로서 `key`와 `reverse`를 넣어줄 수 있다.  
각각은 `key` 값을 기준으로 정렬시키거나, 반대로 정렬시키는 기능을 갖는다.    

<br>

### 7. 패킹/언패킹
- 패킹(packing) : 한 변수에 여러 개의 데이터를 할당하는 것  
(리스트를 만드는 행위)

- **언패킹**(unpacking) : 한 변수의 데이터를 각각의 변수로 반환하는 것  

```python
list = [1, 2, 3]  # 패킹
a, b, c = list    # 언패킹
print(t, a, b, c) # [1, 2, 3] 1 2 3
```

- 단, **언패킹** 시  
***리스트의 원소 개수***와, 데이터를 ***담을 변수의 개수는 같아야 한다.***  
적거나 많으면 모두 ERROR !

<br>

### 8. 이차원 리스트
- **리스트들의 리스트**이다.  
여러 개의 리스트를 하나의 변수에 할당하는 것.  

```python
first_floor = [101, 102, 103, 104, 105]
second_floor = [201, 202, 203, 204, 205]
third_floor = [301, 302, 303, 304, 305]
apartment = [first_floor, second_floor, third_floor]
# [[101, 102, 103, 104, 105],
#  [201, 202, 203, 204, 205],
#  [301, 302, 303, 304, 305]]

apartment[0][2]  # 103
```

<br>

### 9. 리스트의 메모리 저장
#### [1] 리스트는 값의 주소를 저장
- 바로 위 코드의 리스트 원소 값을 변경해보자.  

```python
second_floor[0] = 1000
apartment
# [[101, 102, 103, 104, 105],
#  [1000, 202, 203, 204, 205],
#  [301, 302, 303, 304, 305]]
```

- `second_floor` 리스트의 원소 내용을 변경하였을 뿐인데,  
이를 담고있는 `apartment` 리스트의 내용도 변경되었다.  

  - 이는 파이선에서 **리스트**를 저장할 때,  
  값 자체가 아니라 값이 위치한 메모리 **주소(reference)를 저장**하기 때문이다.  
  리스트는 값을 연속적으로 저장하는 것이 아니라,  
  **값이 있는 주소를 저장(참조)**한다.

<br>

#### [2] 메모리 주소를 비교하는 연산자 `is`
- `==`는 값을 비교하는 연산자이고,  
**`is`**는 **메모리 주소를 비교**하는 연산자이다.  

```python
a = 300
b = 300
a is b  # False
a == b  # True
```

- 그런데 신기하게도, 아래 코드는 모두 True를 반환한다.  

  - 파이썬의 interpreter를 구동할 때, **`-5` ~ `256` 까지의 흔히 쓰이는 정수값**은  
  **특정 메모리에 이미 저장해놓고 시작**하기 때문이다.  
  따라서 해당 값(숫자)를 할당할 때에는 새로운 주소가 아니라,  
  그 숫자가 가진 **이미 정의된 메모리 주소로 연결**해준다.  

```python
a = 1
b = 1
a is b  # True
a == b  # True
```

- 추가적으로, `id()` 함수는 변수의 주소를 리턴한다.  

<br>

- `=` 대입 연산자로 리스트를 할당하면, 참조를 전달한다.  
다시말해, 리스트에 대한 참조를 공유하게 되는 것이다.  

```python
a = [5, 4, 3, 2 ,1]
b = [1, 2, 3, 4, 5]
b = a
print(b)  # [5, 4, 3, 2, 1]

a.sort()
printf(b) # [1, 2, 3, 4, 5]
```

- 만약 `b`에게 새로운 리스트를 대입하면,  
이제서야 `b`는 `a`가 가리키는 리스트를 참조하는게 아닌  
`b`만이 가리키는 새로운 리스트를 참조하게 된다.  

```python
b = [6, 7 ,8, 9, 10]
print(a, b)
# [1, 2, 3, 4, 5] [6, 7, 8, 9, 10]
```

<br>

## 부가적인 요소들
### 1. 파이썬 내장 모듈  
#### [1] `__name__` 변수
- 파이썬 파일(`.py` 파일)에는 `__name__` 이라는 이름의 숨겨진 변수가 있다.  
해당 변수는 모듈의 이름을 가지고 있는 변수로서,  
다시말해 현재 `.py` 파일의 이름을 가지고 있는 변수이다.  

  - 만약 파일 이름이 `ronaldo.py` 라면,  
  `__name__` 변수는 `ronaldo` 라는 문자열을 값으로 갖는다.  
  
  - 그리고 현재 실행중인 파일의 경우,  
  `__name__` 변수는 `__main__` 이라는 문자열을 값으로 갖는다.  

    - 따라서, 파이썬에서 모듈을 `import` 하면 해당 파일을 한 번 읽기 때문에,  
    현재 파일 내용만 실행하라는 의미에서  

    ```python
    if __name__ == '__main__' :
      main()
    ```

    - 과 같은 표현을 많이 쓴다.  

    <br>

### 2. `__str__`와 `__repr__`
- `__str__` 메소드는 `str()` 함수에 해당 객체를 인자로 주었을 때 호출되는 메소드이다.  
- `__repr__` 메소드는 `repr()` 함수에 해당 객체를 인자로 주었을 때 호출되는 메소드이다.

  - 두 메소드 모두 `toString` 개념의 문자열 변환 메소드이다.

    - 다만, `__repr__` 메소드는 객체를 표현(representation)하는게 목적이라서, formal한, 추가적인 작업이 가능한 문자열 형태의 객체에대한 정보를 제공한다.  
      - 따라서 `eval(repr(object))`는 해당 object를 얻을 수 있다.  

    - `__str__` 메소드는 우리가 편하게 볼 수 있도록, 객체를 평문화(stringify)하는게 목적이라서, informal하다.  
    단지 문자열형태로 읽을 수 있도록 변환해줄 뿐이다.  

- 만약 `print(객체)` 하였을 때,  
  - `__repr__`와 `__str__`이 모두 정의되어 있었다면  
  `__str__`를 호출한다.  

  - `__repr__`만 정의되어 있었다면  
  `__repr__`를 호출한다.  

- `__str__`이 정의되어 있지 않을 때
  - `str()`를 호출하면, `__repr__` 메소드를 호출하여 대신 사용한다.  

- `__repr__`이 정의되어 있지 않을 때
  - `repr()`를 호출하면, 재정의하지 않은 쌩 날것의, 위에서 상속받은 기존의 원시 `__repr__` 메소드를 호출한다.

<br>

### 3. print() 함수 심화
- print() 함수에서 문자열을 출력할 때,  
특정 부분을 `{ }`로 감싸주어 해당 부분만 변수로 취급할 수도 있다.  

```python
n = 7
print('Ronaldo - {n}')  # Ronaldo 7

h = 168.5
print('messi height : {:.2f}'.format(h))  # messi height : 168.50
```

<br>

### 4. 파일 입출력
- 특정 파일(`.txt` 등)에서 입출력을 주고 받고 싶을 때가 있다.  

  - 그럴 때는 `with expression as target` 형식의 `with ~ as` 문을 사용한다.  

  ```python
  # 쓰기
  with open('file.txt', 'w') as fw :
    fw.write("~~")

  # 읽기
  with open('file.txt') as fr :
    for line in fr :
      print(line)
  ```

  - 주로 `expression`은 `open()` 함수를 작성하여 사용하는데,  
  이 때 두 번째 인자로 주는 `w`, `r` 따위는 각각 파일을 **읽기 타입** 으로 열 것인지, **쓰기 타입**으로 열 것인지를 선택하는 인자이다.

<br>
<br>
<br>
<br>
<details>
<summary>주의사항</summary>
<div markdown="1">

이 포스팅은 강원대학교 최미정 교수님의 고급파이썬프로그래밍 수업을 들으며 내용을 정리 한 것입니다.  
수업 내용에 대한 저작권은 교수님께 있으니,  
다른 곳으로의 무분별한 내용 복사를 자제해 주세요.

</div>
</details> 